{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autonomi Documentation","text":"<p>Welcome to the Autonomi documentation! This guide will help you get started with using the Autonomi network client.</p>"},{"location":"#what-is-autonomi","title":"What is Autonomi?","text":"<p>Autonomi is a decentralized network client that provides:</p> <ul> <li>Distributed data storage and retrieval</li> <li>EVM network integration</li> <li>Secure pointer management</li> <li>Linked list data structures</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Local Network Setup</li> </ul>"},{"location":"#language-support","title":"Language Support","text":"<p>Autonomi provides client libraries for multiple languages:</p> Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nconst client = new Client();\nawait client.connect();\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client()\nawait client.connect()\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new()?;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol> <p>For more details, see our Contributing Guide.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues</li> <li>API Reference</li> <li>Testing Guide</li> </ul>"},{"location":"pointer_design_doc/","title":"Pointer Data Type Design Document","text":""},{"location":"pointer_design_doc/#overview","title":"Overview","text":"<p>The <code>Pointer</code> data type is designed to represent a reference to a <code>LinkedList</code> in the system. It will include metadata such as the owner, a counter, and a signature to ensure data integrity and authenticity.</p>"},{"location":"pointer_design_doc/#structure","title":"Structure","text":"<pre><code>struct Pointer {\n    owner: PubKey, // This is the address of this data type\n    counter: U32,\n    target: PointerTarget, // Can be PointerAddress, LinkedListAddress, ChunksAddress, or ScratchpadAddress\n    signature: Sig, // Signature of counter and pointer (and target)\n}\n</code></pre>"},{"location":"pointer_design_doc/#pointer-target","title":"Pointer Target","text":"<p>The <code>PointerTarget</code> enum will define the possible target types for a <code>Pointer</code>:</p> <pre><code>enum PointerTarget {\n    PointerAddress(PointerAddress),\n    LinkedListAddress(LinkedListAddress),\n    ChunkAddress(ChunkAddress),\n    ScratchpadAddress(ScratchpadAddress),\n}\n</code></pre>"},{"location":"pointer_design_doc/#detailed-implementation-and-testing-strategy","title":"Detailed Implementation and Testing Strategy","text":"<ol> <li>Define the <code>Pointer</code> Struct:</li> <li>Implement the <code>Pointer</code> struct in a new Rust file alongside <code>linked_list.rs</code>.</li> <li> <p>Testing: Write unit tests to ensure the struct is correctly defined and can be instantiated.</p> </li> <li> <p>Address Handling:</p> </li> <li>Implement address handling similar to <code>LinkedListAddress</code>.</li> <li> <p>Testing: Verify address conversion and serialization through unit tests.</p> </li> <li> <p>Integration with <code>record_store.rs</code>:</p> </li> <li>Ensure that the <code>Pointer</code> type is properly integrated into the <code>record_store.rs</code> to handle storage and retrieval operations.</li> <li> <p>Testing: Use integration tests to confirm that <code>Pointer</code> records can be stored and retrieved correctly.</p> </li> <li> <p>Signature Verification:</p> </li> <li>Implement methods to sign and verify the <code>Pointer</code> data using the owner's private key.</li> <li> <p>Testing: Write tests to validate the signature creation and verification process.</p> </li> <li> <p>Output Handling:</p> </li> <li>The <code>Pointer</code> will point to a <code>LinkedList</code>, and the <code>LinkedList</code> output will be used as the value. If there is more than one output, the return will be a vector of possible values.</li> <li> <p>Testing: Test the output handling logic to ensure it returns the correct values.</p> </li> <li> <p>Integration with ant-networking:</p> </li> <li>Implement methods to serialize and deserialize <code>Pointer</code> records, similar to how <code>LinkedList</code> records are handled.</li> <li>Ensure that the <code>Pointer</code> type is supported in the <code>NodeRecordStore</code> for storage and retrieval operations.</li> <li> <p>Testing: Conduct end-to-end tests to verify the integration with <code>ant-networking</code>.</p> </li> <li> <p>Payment Handling:</p> </li> <li>Introduce <code>RecordKind::PointerWithPayment</code> to handle <code>Pointer</code> records with payments.</li> <li>Implement logic to process <code>Pointer</code> records with payments, similar to <code>LinkedListWithPayment</code>.</li> <li> <p>Testing: Test the payment processing logic to ensure it handles payments correctly.</p> </li> <li> <p>Documentation and Review:</p> </li> <li>Update documentation to reflect the new <code>Pointer</code> type and its usage.</li> <li>Conduct code reviews to ensure quality and adherence to best practices.</li> </ol>"},{"location":"pointer_design_doc/#next-steps","title":"Next Steps","text":"<ul> <li>Develop a detailed implementation plan for each component.</li> <li>Identify any additional dependencies or libraries required.</li> <li>Plan for testing and validation of the <code>Pointer</code> data type.</li> </ul>"},{"location":"pointer_design_doc/#conclusion","title":"Conclusion","text":"<p>The <code>Pointer</code> data type will enhance the system's ability to reference and manage <code>LinkedList</code> structures efficiently. Further details will be added as the implementation progresses.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#getting-started","title":"Getting Started","text":"<p>The Autonomi API provides a flexible interface for interacting with the network. You can start with a read-only client for browsing and reading data, then optionally upgrade to write capabilities when needed. See the Client Modes Guide for details.</p>"},{"location":"api/#core-concepts","title":"Core Concepts","text":"<ul> <li>Client Modes: Choose between read-only and read-write access</li> <li>Data Storage: Store and retrieve data on the network</li> <li>Linked Lists: Create and manage linked data structures</li> <li>Pointers: Reference and update data locations</li> <li>Vaults: Secure data storage with encryption</li> <li>Payments: Handle storage payments using EVM wallets</li> </ul>"},{"location":"api/#language-support","title":"Language Support","text":"<ul> <li>Rust API</li> <li>Node.js API</li> <li>Python API</li> </ul>"},{"location":"api/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Read-Only Access</li> <li>Browse network data</li> <li>Retrieve files and content</li> <li> <p>Query linked lists and pointers</p> </li> <li> <p>Write Operations</p> </li> <li>Store public and private data</li> <li>Create and update data structures</li> <li> <p>Manage user data in vaults</p> </li> <li> <p>Payment Handling</p> </li> <li>Get storage quotes</li> <li>Make payments for write operations</li> <li>Manage wallet balances</li> </ol>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ol> <li>Start with a read-only client for browsing</li> <li>Upgrade to read-write mode only when needed</li> <li>Handle errors appropriately</li> <li>Follow security guidelines for wallet management</li> <li>Use appropriate payment options for write operations</li> </ol>"},{"location":"api/#further-reading","title":"Further Reading","text":"<ul> <li>Local Network Setup</li> <li>Client Modes Guide</li> <li>Data Storage Guide</li> <li>Payment Guide</li> </ul>"},{"location":"api/nodejs/","title":"Node.js API Reference","text":""},{"location":"api/nodejs/#installation","title":"Installation","text":"<pre><code>npm install @autonomi/client\n</code></pre>"},{"location":"api/nodejs/#core-classes","title":"Core Classes","text":""},{"location":"api/nodejs/#client","title":"Client","text":"<p>The main interface for interacting with the Autonomi network.</p> <pre><code>class Client {\n  constructor(config?: ClientConfig);\n\n  // Linked List Operations\n  async linkedListPut(list: LinkedList): Promise&lt;LinkedListAddress&gt;;\n  async linkedListGet(address: LinkedListAddress): Promise&lt;LinkedList&gt;;\n\n  // Pointer Operations\n  async pointerPut(pointer: Pointer): Promise&lt;PointerAddress&gt;;\n  async pointerGet(address: PointerAddress): Promise&lt;Pointer&gt;;\n\n  // Network Operations\n  async connect(): Promise&lt;void&gt;;\n  async disconnect(): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/nodejs/#linkedlist","title":"LinkedList","text":"<p>Represents a linked list data structure.</p> <pre><code>class LinkedList {\n  constructor();\n\n  append(data: any): void;\n  prepend(data: any): void;\n  remove(index: number): void;\n  get(index: number): any;\n  toString(): string;\n}\n</code></pre>"},{"location":"api/nodejs/#pointer","title":"Pointer","text":"<p>Represents a pointer in the network.</p> <pre><code>class Pointer {\n  constructor();\n\n  setTarget(target: string): void;\n  getTarget(): string;\n  isValid(): boolean;\n}\n</code></pre>"},{"location":"api/nodejs/#scratchpad","title":"Scratchpad","text":"<p>Represents a mutable storage location with versioning and encryption.</p> <pre><code>interface ScratchpadConfig {\n  contentType: number;\n  data: Uint8Array;\n  secretKey: Uint8Array;\n}\n\nclass Scratchpad {\n  constructor(config: ScratchpadConfig);\n\n  // Get the network address\n  getAddress(): string;\n\n  // Get the current version counter\n  getCounter(): number;\n\n  // Update the data and sign with secret key\n  update(data: Uint8Array, secretKey: Uint8Array): void;\n\n  // Verify the signature\n  verify(): boolean;\n\n  // Decrypt the data using the secret key\n  decrypt(secretKey: Uint8Array): Uint8Array;\n}\n</code></pre>"},{"location":"api/nodejs/#self-encryption","title":"Self-Encryption","text":"<p>Utilities for data encryption and chunking.</p> <pre><code>interface EncryptionResult {\n  dataMap: DataMap;\n  chunks: Chunk[];\n}\n\ninterface DataMap {\n  chunks: ChunkInfo[];\n  totalSize: number;\n}\n\ninterface ChunkInfo {\n  hash: string;\n  size: number;\n  offset: number;\n}\n\nclass SelfEncryption {\n  static async encrypt(data: Uint8Array): Promise&lt;EncryptionResult&gt;;\n  static async decrypt(dataMap: DataMap, chunks: Chunk[]): Promise&lt;Uint8Array&gt;;\n  static async packDataMap(dataMap: DataMap): Promise&lt;Chunk&gt;;\n}\n\n### Files and Directories\n\nUtilities for managing files and directories in the network.\n\n```typescript\ninterface FileMetadata {\n  name: string;\n  size: number;\n  created: Date;\n  modified: Date;\n  contentType: string;\n}\n\ninterface DirectoryEntry {\n  name: string;\n  type: 'file' | 'directory';\n  metadata?: FileMetadata;\n}\n\nclass File {\n  constructor(name: string, data?: Uint8Array);\n\n  // Get file metadata\n  getMetadata(): FileMetadata;\n\n  // Read file contents\n  async read(): Promise&lt;Uint8Array&gt;;\n\n  // Write file contents\n  async write(data: Uint8Array): Promise&lt;void&gt;;\n\n  // Update file metadata\n  async updateMetadata(metadata: Partial&lt;FileMetadata&gt;): Promise&lt;void&gt;;\n}\n\nclass Directory {\n  constructor(name: string);\n\n  // List directory contents\n  async list(): Promise&lt;DirectoryEntry[]&gt;;\n\n  // Create a new file\n  async createFile(name: string, data?: Uint8Array): Promise&lt;File&gt;;\n\n  // Create a new subdirectory\n  async createDirectory(name: string): Promise&lt;Directory&gt;;\n\n  // Get a file or directory by name\n  async get(name: string): Promise&lt;File | Directory&gt;;\n\n  // Delete a file or directory\n  async delete(name: string): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/nodejs/#archive","title":"Archive","text":"<p>Utilities for creating and managing archives.</p> <pre><code>interface ArchiveOptions {\n  compression?: 'none' | 'gzip' | 'bzip2';\n  encryption?: {\n    algorithm: 'aes-256-gcm';\n    key: Uint8Array;\n  };\n}\n\ninterface ArchiveEntry {\n  name: string;\n  size: number;\n  compressed: boolean;\n  encrypted: boolean;\n}\n\nclass Archive {\n  constructor(options?: ArchiveOptions);\n\n  // Add a file or directory to the archive\n  async add(path: string, source: File | Directory): Promise&lt;void&gt;;\n\n  // Extract files from the archive\n  async extract(destination: Directory, pattern?: string): Promise&lt;void&gt;;\n\n  // List archive contents\n  async list(): Promise&lt;ArchiveEntry[]&gt;;\n\n  // Verify archive integrity\n  async verify(): Promise&lt;boolean&gt;;\n}\n\n### Vault\n\nSecure storage for sensitive data.\n\n```typescript\ninterface VaultConfig {\n  secretKey: Uint8Array;\n  algorithm?: 'aes-256-gcm' | 'xchacha20-poly1305';\n  iterations?: number;\n}\n\ninterface VaultEntry {\n  key: string;\n  created: Date;\n  modified: Date;\n  tags?: string[];\n}\n\nclass Vault {\n  constructor(config: VaultConfig);\n\n  // Store encrypted data\n  async put(key: string, data: Uint8Array, tags?: string[]): Promise&lt;void&gt;;\n\n  // Retrieve and decrypt data\n  async get(key: string): Promise&lt;Uint8Array&gt;;\n\n  // List vault contents\n  async list(tag?: string): Promise&lt;VaultEntry[]&gt;;\n\n  // Delete data\n  async delete(key: string): Promise&lt;void&gt;;\n\n  // Rotate encryption key\n  async rotateKey(newKey: Uint8Array): Promise&lt;void&gt;;\n}\n\n## Types\n\n```typescript\ninterface ClientConfig {\n  networkUrl?: string;\n  timeout?: number;\n  retries?: number;\n}\n\ntype LinkedListAddress = string;\ntype PointerAddress = string;\n</code></pre>"},{"location":"api/nodejs/#error-handling","title":"Error Handling","text":"<pre><code>class AutonomiError extends Error {\n  constructor(message: string, code: string);\n\n  readonly code: string;\n  readonly message: string;\n}\n</code></pre>"},{"location":"api/nodejs/#examples","title":"Examples","text":""},{"location":"api/nodejs/#basic-usage","title":"Basic Usage","text":"<pre><code>import { Client, LinkedList } from '@autonomi/client';\n\nasync function example() {\n  const client = new Client();\n\n  // Create and store a linked list\n  const list = new LinkedList();\n  list.append(\"Hello\");\n  list.append(\"World\");\n\n  const address = await client.linkedListPut(list);\n  console.log(`List stored at: ${address}`);\n\n  // Retrieve the list\n  const retrieved = await client.linkedListGet(address);\n  console.log(retrieved.toString()); // \"Hello World\"\n}\n</code></pre>"},{"location":"api/nodejs/#error-handling_1","title":"Error Handling","text":"<pre><code>try {\n  const client = new Client();\n  await client.connect();\n} catch (error) {\n  if (error instanceof AutonomiError) {\n    console.error(`Error code: ${error.code}`);\n    console.error(`Message: ${error.message}`);\n  }\n}\n</code></pre>"},{"location":"api/nodejs/#best-practices","title":"Best Practices","text":"<ol> <li>Always use TypeScript for better type safety</li> <li>Handle errors appropriately</li> <li>Use async/await for all asynchronous operations</li> <li>Properly dispose of resources</li> <li>Follow the provided examples for memory management</li> </ol>"},{"location":"api/python/","title":"Python API Reference","text":""},{"location":"api/python/#installation","title":"Installation","text":"<pre><code>pip install autonomi-client\n</code></pre>"},{"location":"api/python/#core-classes","title":"Core Classes","text":""},{"location":"api/python/#client","title":"Client","text":"<p>The main interface for interacting with the Autonomi network.</p> <pre><code>from typing import Optional, Dict, Any\nfrom autonomi import LinkedList, Pointer, LinkedListAddress, PointerAddress\n\nclass Client:\n    def __init__(self, config: Optional[Dict[str, Any]] = None) -&gt; None:\n        \"\"\"Initialize a new Autonomi client.\n\n        Args:\n            config: Optional configuration dictionary\n        \"\"\"\n        pass\n\n    async def linked_list_put(self, list_obj: LinkedList) -&gt; LinkedListAddress:\n        \"\"\"Store a linked list in the network.\n\n        Args:\n            list_obj: The linked list to store\n\n        Returns:\n            The address where the list is stored\n        \"\"\"\n        pass\n\n    async def linked_list_get(self, address: LinkedListAddress) -&gt; LinkedList:\n        \"\"\"Retrieve a linked list from the network.\n\n        Args:\n            address: The address of the list to retrieve\n\n        Returns:\n            The retrieved linked list\n        \"\"\"\n        pass\n\n    async def pointer_put(self, pointer: Pointer) -&gt; PointerAddress:\n        \"\"\"Store a pointer in the network.\n\n        Args:\n            pointer: The pointer to store\n\n        Returns:\n            The address where the pointer is stored\n        \"\"\"\n        pass\n\n    async def pointer_get(self, address: PointerAddress) -&gt; Pointer:\n        \"\"\"Retrieve a pointer from the network.\n\n        Args:\n            address: The address of the pointer to retrieve\n\n        Returns:\n            The retrieved pointer\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/python/#linkedlist","title":"LinkedList","text":"<p>Represents a linked list data structure.</p> <pre><code>from typing import Any\n\nclass LinkedList:\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize a new linked list.\"\"\"\n        pass\n\n    def append(self, data: Any) -&gt; None:\n        \"\"\"Append data to the list.\n\n        Args:\n            data: The data to append\n        \"\"\"\n        pass\n\n    def prepend(self, data: Any) -&gt; None:\n        \"\"\"Prepend data to the list.\n\n        Args:\n            data: The data to prepend\n        \"\"\"\n        pass\n\n    def remove(self, index: int) -&gt; None:\n        \"\"\"Remove an item at the specified index.\n\n        Args:\n            index: The index to remove\n        \"\"\"\n        pass\n\n    def get(self, index: int) -&gt; Any:\n        \"\"\"Get an item at the specified index.\n\n        Args:\n            index: The index to retrieve\n\n        Returns:\n            The item at the specified index\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/python/#pointer","title":"Pointer","text":"<p>Represents a pointer in the network.</p> <pre><code>class Pointer:\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize a new pointer.\"\"\"\n        pass\n\n    def set_target(self, target: str) -&gt; None:\n        \"\"\"Set the target of the pointer.\n\n        Args:\n            target: The target to set\n        \"\"\"\n        pass\n\n    def get_target(self) -&gt; str:\n        \"\"\"Get the target of the pointer.\n\n        Returns:\n            The current target\n        \"\"\"\n        pass\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if the pointer is valid.\n\n        Returns:\n            True if valid, False otherwise\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/python/#scratchpad","title":"Scratchpad","text":"<p>Represents a mutable storage location with versioning and encryption.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Optional, Union\n\n@dataclass\nclass ScratchpadConfig:\n    content_type: int\n    data: bytes\n    secret_key: bytes\n\nclass Scratchpad:\n    def __init__(self, config: ScratchpadConfig) -&gt; None:\n        \"\"\"Initialize a new scratchpad.\n\n        Args:\n            config: Configuration for the scratchpad\n        \"\"\"\n        pass\n\n    def get_address(self) -&gt; str:\n        \"\"\"Get the network address of the scratchpad.\n\n        Returns:\n            The network address\n        \"\"\"\n        pass\n\n    def get_counter(self) -&gt; int:\n        \"\"\"Get the current version counter.\n\n        Returns:\n            The current counter value\n        \"\"\"\n        pass\n\n    def update(self, data: bytes, secret_key: bytes) -&gt; None:\n        \"\"\"Update the data and sign with secret key.\n\n        Args:\n            data: New data to store\n            secret_key: Key for signing\n        \"\"\"\n        pass\n\n    def verify(self) -&gt; bool:\n        \"\"\"Verify the signature.\n\n        Returns:\n            True if signature is valid\n        \"\"\"\n        pass\n\n    def decrypt(self, secret_key: bytes) -&gt; bytes:\n        \"\"\"Decrypt the data using the secret key.\n\n        Args:\n            secret_key: Key for decryption\n\n        Returns:\n            The decrypted data\n        \"\"\"\n        pass\n\n### Self-Encryption\n\nUtilities for data encryption and chunking.\n\n```python\nfrom typing import List, NamedTuple\n\nclass ChunkInfo(NamedTuple):\n    hash: str\n    size: int\n    offset: int\n\nclass DataMap(NamedTuple):\n    chunks: List[ChunkInfo]\n    total_size: int\n\nclass EncryptionResult(NamedTuple):\n    data_map: DataMap\n    chunks: List[bytes]\n\nclass SelfEncryption:\n    @staticmethod\n    async def encrypt(data: bytes) -&gt; EncryptionResult:\n        \"\"\"Encrypt and chunk the data.\n\n        Args:\n            data: Data to encrypt\n\n        Returns:\n            Encryption result containing data map and chunks\n        \"\"\"\n        pass\n\n    @staticmethod\n    async def decrypt(data_map: DataMap, chunks: List[bytes]) -&gt; bytes:\n        \"\"\"Decrypt and reassemble the data.\n\n        Args:\n            data_map: Map of chunks\n            chunks: List of encrypted chunks\n\n        Returns:\n            The decrypted data\n        \"\"\"\n        pass\n\n    @staticmethod\n    async def pack_data_map(data_map: DataMap) -&gt; bytes:\n        \"\"\"Pack a data map into a chunk.\n\n        Args:\n            data_map: Map to pack\n\n        Returns:\n            The packed chunk\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/python/#files-and-directories","title":"Files and Directories","text":"<p>Utilities for managing files and directories in the network.</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional, Union, List\n\n@dataclass\nclass FileMetadata:\n    name: str\n    size: int\n    created: datetime\n    modified: datetime\n    content_type: str\n\n@dataclass\nclass DirectoryEntry:\n    name: str\n    type: str  # 'file' or 'directory'\n    metadata: Optional[FileMetadata] = None\n\nclass File:\n    def __init__(self, name: str, data: Optional[bytes] = None) -&gt; None:\n        \"\"\"Initialize a new file.\n\n        Args:\n            name: Name of the file\n            data: Optional initial data\n        \"\"\"\n        pass\n\n    def get_metadata(self) -&gt; FileMetadata:\n        \"\"\"Get file metadata.\n\n        Returns:\n            File metadata\n        \"\"\"\n        pass\n\n    async def read(self) -&gt; bytes:\n        \"\"\"Read file contents.\n\n        Returns:\n            File contents as bytes\n        \"\"\"\n        pass\n\n    async def write(self, data: bytes) -&gt; None:\n        \"\"\"Write file contents.\n\n        Args:\n            data: Data to write\n        \"\"\"\n        pass\n\n    async def update_metadata(self, metadata: FileMetadata) -&gt; None:\n        \"\"\"Update file metadata.\n\n        Args:\n            metadata: New metadata\n        \"\"\"\n        pass\n\nclass Directory:\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"Initialize a new directory.\n\n        Args:\n            name: Name of the directory\n        \"\"\"\n        pass\n\n    async def list(self) -&gt; List[DirectoryEntry]:\n        \"\"\"List directory contents.\n\n        Returns:\n            List of directory entries\n        \"\"\"\n        pass\n\n    async def create_file(self, name: str, data: Optional[bytes] = None) -&gt; File:\n        \"\"\"Create a new file.\n\n        Args:\n            name: Name of the file\n            data: Optional initial data\n\n        Returns:\n            The created file\n        \"\"\"\n        pass\n\n    async def create_directory(self, name: str) -&gt; 'Directory':\n        \"\"\"Create a new subdirectory.\n\n        Args:\n            name: Name of the directory\n\n        Returns:\n            The created directory\n        \"\"\"\n        pass\n\n    async def get(self, name: str) -&gt; Union[File, 'Directory']:\n        \"\"\"Get a file or directory by name.\n\n        Args:\n            name: Name to look up\n\n        Returns:\n            File or Directory object\n        \"\"\"\n        pass\n\n    async def delete(self, name: str) -&gt; None:\n        \"\"\"Delete a file or directory.\n\n        Args:\n            name: Name to delete\n        \"\"\"\n        pass\n\n### Archive\n\nUtilities for creating and managing archives.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, List\n\n@dataclass\nclass ArchiveOptions:\n    compression: str = 'none'  # 'none', 'gzip', or 'bzip2'\n    encryption: Optional[dict] = None  # {'algorithm': 'aes-256-gcm', 'key': bytes}\n\n@dataclass\nclass ArchiveEntry:\n    name: str\n    size: int\n    compressed: bool\n    encrypted: bool\n\nclass Archive:\n    def __init__(self, options: Optional[ArchiveOptions] = None) -&gt; None:\n        \"\"\"Initialize a new archive.\n\n        Args:\n            options: Optional archive configuration\n        \"\"\"\n        pass\n\n    async def add(self, path: str, source: Union[File, Directory]) -&gt; None:\n        \"\"\"Add a file or directory to the archive.\n\n        Args:\n            path: Path within the archive\n            source: Source file or directory\n        \"\"\"\n        pass\n\n    async def extract(self, destination: Directory, pattern: Optional[str] = None) -&gt; None:\n        \"\"\"Extract files from the archive.\n\n        Args:\n            destination: Destination directory\n            pattern: Optional glob pattern\n        \"\"\"\n        pass\n\n    async def list(self) -&gt; List[ArchiveEntry]:\n        \"\"\"List archive contents.\n\n        Returns:\n            List of archive entries\n        \"\"\"\n        pass\n\n    async def verify(self) -&gt; bool:\n        \"\"\"Verify archive integrity.\n\n        Returns:\n            True if archive is valid\n        \"\"\"\n        pass\n\n### Vault\n\nSecure storage for sensitive data.\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional, List\n\n@dataclass\nclass VaultConfig:\n    secret_key: bytes\n    algorithm: str = 'aes-256-gcm'  # or 'xchacha20-poly1305'\n    iterations: int = 100000\n\n@dataclass\nclass VaultEntry:\n    key: str\n    created: datetime\n    modified: datetime\n    tags: Optional[List[str]] = None\n\nclass Vault:\n    def __init__(self, config: VaultConfig) -&gt; None:\n        \"\"\"Initialize a new vault.\n\n        Args:\n            config: Vault configuration\n        \"\"\"\n        pass\n\n    async def put(self, key: str, data: bytes, tags: Optional[List[str]] = None) -&gt; None:\n        \"\"\"Store encrypted data.\n\n        Args:\n            key: Key to store under\n            data: Data to encrypt and store\n            tags: Optional tags\n        \"\"\"\n        pass\n\n    async def get(self, key: str) -&gt; bytes:\n        \"\"\"Retrieve and decrypt data.\n\n        Args:\n            key: Key to retrieve\n\n        Returns:\n            Decrypted data\n        \"\"\"\n        pass\n\n    async def list(self, tag: Optional[str] = None) -&gt; List[VaultEntry]:\n        \"\"\"List vault contents.\n\n        Args:\n            tag: Optional tag to filter by\n\n        Returns:\n            List of vault entries\n        \"\"\"\n        pass\n\n    async def delete(self, key: str) -&gt; None:\n        \"\"\"Delete data.\n\n        Args:\n            key: Key to delete\n        \"\"\"\n        pass\n\n    async def rotate_key(self, new_key: bytes) -&gt; None:\n        \"\"\"Rotate encryption key.\n\n        Args:\n            new_key: New encryption key\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/python/#examples","title":"Examples","text":""},{"location":"api/python/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom autonomi import Client, LinkedList\n\nasync def example():\n    client = Client()\n\n    # Create and store a linked list\n    list_obj = LinkedList()\n    list_obj.append(\"Hello\")\n    list_obj.append(\"World\")\n\n    address = await client.linked_list_put(list_obj)\n    print(f\"List stored at: {address}\")\n\n    # Retrieve the list\n    retrieved = await client.linked_list_get(address)\n    print(str(retrieved))  # \"Hello World\"\n\n# Run the example\nasyncio.run(example())\n</code></pre>"},{"location":"api/python/#error-handling","title":"Error Handling","text":"<pre><code>from autonomi import Client, AutonomiError\n\nasync def example():\n    try:\n        client = Client()\n        await client.connect()\n    except AutonomiError as e:\n        print(f\"Error code: {e.code}\")\n        print(f\"Message: {e.message}\")\n</code></pre>"},{"location":"api/python/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints for better code quality</li> <li>Handle errors appropriately using try/except</li> <li>Use async/await for all asynchronous operations</li> <li>Follow the provided examples for proper resource management</li> <li>Use context managers when appropriate</li> </ol>"},{"location":"api/rust/","title":"Rust API Reference","text":""},{"location":"api/rust/#installation","title":"Installation","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nautonomi = \"0.1.0\"\n</code></pre>"},{"location":"api/rust/#core-types","title":"Core Types","text":""},{"location":"api/rust/#client","title":"Client","text":"<p>The main interface for interacting with the Autonomi network.</p> <pre><code>use autonomi::{Client, LinkedList, Pointer, Result};\n\npub struct Client {\n    // ... implementation details ...\n}\n\nimpl Client {\n    /// Create a new client with default configuration\n    pub fn new() -&gt; Result&lt;Self&gt;;\n\n    /// Create a new client with custom configuration\n    pub fn with_config(config: ClientConfig) -&gt; Result&lt;Self&gt;;\n\n    /// Store a linked list in the network\n    pub fn linked_list_put(&amp;self, list: &amp;LinkedList) -&gt; Result&lt;LinkedListAddress&gt;;\n\n    /// Retrieve a linked list from the network\n    pub fn linked_list_get(&amp;self, address: &amp;LinkedListAddress) -&gt; Result&lt;LinkedList&gt;;\n\n    /// Store a pointer in the network\n    pub fn pointer_put(&amp;self, pointer: &amp;Pointer) -&gt; Result&lt;PointerAddress&gt;;\n\n    /// Retrieve a pointer from the network\n    pub fn pointer_get(&amp;self, address: &amp;PointerAddress) -&gt; Result&lt;Pointer&gt;;\n}\n</code></pre>"},{"location":"api/rust/#linkedlist","title":"LinkedList","text":"<p>Represents a linked list data structure.</p> <pre><code>pub struct LinkedList {\n    // ... implementation details ...\n}\n\nimpl LinkedList {\n    /// Create a new empty linked list\n    pub fn new() -&gt; Self;\n\n    /// Append data to the list\n    pub fn append&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, data: T);\n\n    /// Prepend data to the list\n    pub fn prepend&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, data: T);\n\n    /// Remove an item at the specified index\n    pub fn remove(&amp;mut self, index: usize) -&gt; Result&lt;()&gt;;\n\n    /// Get an item at the specified index\n    pub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;[u8]&gt;;\n}\n</code></pre>"},{"location":"api/rust/#pointer","title":"Pointer","text":"<p>Represents a pointer in the network.</p> <pre><code>pub struct Pointer {\n    // ... implementation details ...\n}\n\nimpl Pointer {\n    /// Create a new pointer\n    pub fn new() -&gt; Self;\n\n    /// Set the target of the pointer\n    pub fn set_target&lt;T: Into&lt;String&gt;&gt;(&amp;mut self, target: T);\n\n    /// Get the target of the pointer\n    pub fn target(&amp;self) -&gt; &amp;str;\n\n    /// Check if the pointer is valid\n    pub fn is_valid(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"api/rust/#scratchpad","title":"Scratchpad","text":"<p>Represents a mutable storage location with versioning and encryption.</p> <pre><code>pub struct ScratchpadConfig {\n    pub content_type: u64,\n    pub data: Vec&lt;u8&gt;,\n    pub secret_key: SecretKey,\n}\n\npub struct Scratchpad {\n    // ... implementation details ...\n}\n\nimpl Scratchpad {\n    /// Create a new scratchpad with the given configuration\n    pub fn new(config: ScratchpadConfig) -&gt; Result&lt;Self&gt;;\n\n    /// Get the network address of the scratchpad\n    pub fn address(&amp;self) -&gt; &amp;str;\n\n    /// Get the current version counter\n    pub fn counter(&amp;self) -&gt; u64;\n\n    /// Update the data and sign with secret key\n    pub fn update_and_sign(&amp;mut self, data: Vec&lt;u8&gt;, secret_key: &amp;SecretKey) -&gt; Result&lt;()&gt;;\n\n    /// Verify the signature\n    pub fn verify(&amp;self) -&gt; bool;\n\n    /// Decrypt the data using the secret key\n    pub fn decrypt(&amp;self, secret_key: &amp;SecretKey) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n}\n\n### Self-Encryption\n\nUtilities for data encryption and chunking.\n\n```rust\npub struct ChunkInfo {\n    pub hash: String,\n    pub size: usize,\n    pub offset: usize,\n}\n\npub struct DataMap {\n    pub chunks: Vec&lt;ChunkInfo&gt;,\n    pub total_size: usize,\n}\n\npub struct EncryptionResult {\n    pub data_map: DataMap,\n    pub chunks: Vec&lt;Vec&lt;u8&gt;&gt;,\n}\n\npub mod self_encryption {\n    use super::*;\n\n    /// Encrypt and chunk the data\n    pub fn encrypt(data: &amp;[u8]) -&gt; Result&lt;EncryptionResult&gt;;\n\n    /// Decrypt and reassemble the data\n    pub fn decrypt(data_map: &amp;DataMap, chunks: &amp;[Vec&lt;u8&gt;]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n\n    /// Pack a data map into a chunk\n    pub fn pack_data_map(data_map: &amp;DataMap) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n}\n\n### Files and Directories\n\nUtilities for managing files and directories in the network.\n\n```rust\nuse chrono::{DateTime, Utc};\n\npub struct FileMetadata {\n    pub name: String,\n    pub size: u64,\n    pub created: DateTime&lt;Utc&gt;,\n    pub modified: DateTime&lt;Utc&gt;,\n    pub content_type: String,\n}\n\npub enum DirectoryEntry {\n    File {\n        name: String,\n        metadata: FileMetadata,\n    },\n    Directory {\n        name: String,\n    },\n}\n\npub struct File {\n    // ... implementation details ...\n}\n\nimpl File {\n    /// Create a new file with optional initial data\n    pub fn new(name: &amp;str, data: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Self&gt;;\n\n    /// Get file metadata\n    pub fn metadata(&amp;self) -&gt; &amp;FileMetadata;\n\n    /// Read file contents\n    pub async fn read(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n\n    /// Write file contents\n    pub async fn write(&amp;mut self, data: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;\n\n    /// Update file metadata\n    pub async fn update_metadata(&amp;mut self, metadata: FileMetadata) -&gt; Result&lt;()&gt;;\n}\n\npub struct Directory {\n    // ... implementation details ...\n}\n\nimpl Directory {\n    /// Create a new directory\n    pub fn new(name: &amp;str) -&gt; Result&lt;Self&gt;;\n\n    /// List directory contents\n    pub async fn list(&amp;self) -&gt; Result&lt;Vec&lt;DirectoryEntry&gt;&gt;;\n\n    /// Create a new file\n    pub async fn create_file(&amp;mut self, name: &amp;str, data: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;File&gt;;\n\n    /// Create a new subdirectory\n    pub async fn create_directory(&amp;mut self, name: &amp;str) -&gt; Result&lt;Directory&gt;;\n\n    /// Get a file or directory by name\n    pub async fn get(&amp;self, name: &amp;str) -&gt; Result&lt;DirectoryEntry&gt;;\n\n    /// Delete a file or directory\n    pub async fn delete(&amp;mut self, name: &amp;str) -&gt; Result&lt;()&gt;;\n}\n\n### Archive\n\nUtilities for creating and managing archives.\n\n```rust\npub enum Compression {\n    None,\n    Gzip,\n    Bzip2,\n}\n\npub struct EncryptionConfig {\n    pub algorithm: String,  // \"aes-256-gcm\"\n    pub key: Vec&lt;u8&gt;,\n}\n\npub struct ArchiveOptions {\n    pub compression: Compression,\n    pub encryption: Option&lt;EncryptionConfig&gt;,\n}\n\npub struct ArchiveEntry {\n    pub name: String,\n    pub size: u64,\n    pub compressed: bool,\n    pub encrypted: bool,\n}\n\npub struct Archive {\n    // ... implementation details ...\n}\n\nimpl Archive {\n    /// Create a new archive with optional configuration\n    pub fn new(options: Option&lt;ArchiveOptions&gt;) -&gt; Result&lt;Self&gt;;\n\n    /// Add a file or directory to the archive\n    pub async fn add&lt;P: AsRef&lt;str&gt;&gt;(&amp;mut self, path: P, source: &amp;(impl AsRef&lt;File&gt; + AsRef&lt;Directory&gt;)) -&gt; Result&lt;()&gt;;\n\n    /// Extract files from the archive\n    pub async fn extract(&amp;self, destination: &amp;mut Directory, pattern: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;;\n\n    /// List archive contents\n    pub async fn list(&amp;self) -&gt; Result&lt;Vec&lt;ArchiveEntry&gt;&gt;;\n\n    /// Verify archive integrity\n    pub async fn verify(&amp;self) -&gt; Result&lt;bool&gt;;\n}\n\n### Vault\n\nSecure storage for sensitive data.\n\n```rust\npub struct VaultConfig {\n    pub secret_key: Vec&lt;u8&gt;,\n    pub algorithm: String,  // \"aes-256-gcm\" or \"xchacha20-poly1305\"\n    pub iterations: u32,\n}\n\npub struct VaultEntry {\n    pub key: String,\n    pub created: DateTime&lt;Utc&gt;,\n    pub modified: DateTime&lt;Utc&gt;,\n    pub tags: Option&lt;Vec&lt;String&gt;&gt;,\n}\n\npub struct Vault {\n    // ... implementation details ...\n}\n\nimpl Vault {\n    /// Create a new vault with the given configuration\n    pub fn new(config: VaultConfig) -&gt; Result&lt;Self&gt;;\n\n    /// Store encrypted data\n    pub async fn put(&amp;mut self, key: &amp;str, data: Vec&lt;u8&gt;, tags: Option&lt;Vec&lt;String&gt;&gt;) -&gt; Result&lt;()&gt;;\n\n    /// Retrieve and decrypt data\n    pub async fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n\n    /// List vault contents\n    pub async fn list(&amp;self, tag: Option&lt;&amp;str&gt;) -&gt; Result&lt;Vec&lt;VaultEntry&gt;&gt;;\n\n    /// Delete data\n    pub async fn delete(&amp;mut self, key: &amp;str) -&gt; Result&lt;()&gt;;\n\n    /// Rotate encryption key\n    pub async fn rotate_key(&amp;mut self, new_key: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;\n}\n\n## Error Handling\n\n```rust\npub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;\n\n#[derive(Debug)]\npub enum Error {\n    /// Network-related errors\n    Network(String),\n    /// Storage-related errors\n    Storage(String),\n    /// Invalid data format\n    InvalidData(String),\n    /// Other errors\n    Other(String),\n}\n\nimpl std::error::Error for Error {}\n</code></pre>"},{"location":"api/rust/#examples","title":"Examples","text":""},{"location":"api/rust/#basic-usage","title":"Basic Usage","text":"<pre><code>use autonomi::{Client, LinkedList, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Create a new client\n    let client = Client::new()?;\n\n    // Create and store a linked list\n    let mut list = LinkedList::new();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    let address = client.linked_list_put(&amp;list)?;\n    println!(\"List stored at: {}\", address);\n\n    // Retrieve the list\n    let retrieved = client.linked_list_get(&amp;address)?;\n    println!(\"{}\", retrieved);\n\n    Ok(())\n}\n</code></pre>"},{"location":"api/rust/#error-handling","title":"Error Handling","text":"<pre><code>use autonomi::{Client, Error};\n\nfn main() {\n    match Client::new() {\n        Ok(client) =&gt; {\n            // Use the client\n            println!(\"Client created successfully\");\n        }\n        Err(Error::Network(msg)) =&gt; {\n            eprintln!(\"Network error: {}\", msg);\n        }\n        Err(Error::Storage(msg)) =&gt; {\n            eprintln!(\"Storage error: {}\", msg);\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Other error: {}\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"api/rust/#best-practices","title":"Best Practices","text":"<ol> <li>Use proper error handling with <code>Result</code> types</li> <li>Implement proper resource cleanup with <code>Drop</code> trait</li> <li>Use strong typing and avoid unwrap/expect</li> <li>Follow Rust's ownership and borrowing rules</li> <li>Use async/await for network operations when available</li> </ol>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide will help you install the Autonomi client for your preferred programming language.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 16+ (for Node.js client)</li> <li>Python 3.8+ (for Python client)</li> <li>Rust toolchain (for Rust client)</li> <li>Docker (for local network)</li> </ul>"},{"location":"getting-started/installation/#nodejs-installation","title":"Node.js Installation","text":"<pre><code># Using npm\nnpm install @autonomi/client\n\n# Using yarn\nyarn add @autonomi/client\n\n# Using pnpm\npnpm add @autonomi/client\n</code></pre>"},{"location":"getting-started/installation/#typescript-configuration","title":"TypeScript Configuration","text":"<p>Add these settings to your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n</code></pre>"},{"location":"getting-started/installation/#python-installation","title":"Python Installation","text":"<pre><code># Using pip\npip install autonomi-client\n\n# Using poetry\npoetry add autonomi-client\n</code></pre>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (recommended)","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\nsource venv/bin/activate  # Unix\n.\\venv\\Scripts\\activate   # Windows\n\n# Install package\npip install autonomi-client\n</code></pre>"},{"location":"getting-started/installation/#rust-installation","title":"Rust Installation","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nautonomi = \"0.1.0\"\n</code></pre> <p>Or using cargo-edit:</p> <pre><code>cargo add autonomi\n</code></pre>"},{"location":"getting-started/installation/#docker-setup-for-local-network","title":"Docker Setup (for Local Network)","text":"<ol> <li>Install Docker:</li> <li>Docker Desktop for Mac</li> <li>Docker Desktop for Windows</li> <li> <p>Docker Engine for Linux</p> </li> <li> <p>Pull the Autonomi image:</p> </li> </ol> <pre><code>docker pull autonomi/node:latest\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"getting-started/installation/#nodejs","title":"Node.js","text":"<pre><code>import { Client } from '@autonomi/client';\n\nasync function verify() {\n    const client = new Client();\n    await client.connect();\n    console.log('Connected successfully!');\n}\n\nverify().catch(console.error);\n</code></pre>"},{"location":"getting-started/installation/#python","title":"Python","text":"<pre><code>import asyncio\nfrom autonomi import Client\n\nasync def verify():\n    client = Client()\n    await client.connect()\n    print('Connected successfully!')\n\nasyncio.run(verify())\n</code></pre>"},{"location":"getting-started/installation/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = Client::new()?;\n    println!(\"Connected successfully!\");\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Local Network Setup</li> <li>API Reference</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Autonomi quickly. We'll create a simple application that stores and retrieves data using linked lists.</p>"},{"location":"getting-started/quickstart/#choose-your-language","title":"Choose Your Language","text":"Node.jsPythonRust <pre><code>import { Client, LinkedList } from '@autonomi/client';\n\nasync function main() {\n    // Initialize client\n    const client = new Client();\n    await client.connect();\n\n    // Create a linked list\n    const list = new LinkedList();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    const address = await client.linkedListPut(list);\n    console.log(`List stored at: ${address}`);\n\n    // Retrieve the list\n    const retrieved = await client.linkedListGet(address);\n    console.log(retrieved.toString()); // \"Hello World\"\n}\n\nmain().catch(console.error);\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, LinkedList\n\nasync def main():\n    # Initialize client\n    client = Client()\n    await client.connect()\n\n    # Create a linked list\n    list_obj = LinkedList()\n    list_obj.append(\"Hello\")\n    list_obj.append(\"World\")\n\n    # Store the list\n    address = await client.linked_list_put(list_obj)\n    print(f\"List stored at: {address}\")\n\n    # Retrieve the list\n    retrieved = await client.linked_list_get(address)\n    print(str(retrieved))  # \"Hello World\"\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, LinkedList, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Initialize client\n    let client = Client::new()?;\n\n    // Create a linked list\n    let mut list = LinkedList::new();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    let address = client.linked_list_put(&amp;list)?;\n    println!(\"List stored at: {}\", address);\n\n    // Retrieve the list\n    let retrieved = client.linked_list_get(&amp;address)?;\n    println!(\"{}\", retrieved);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-pointers","title":"Working with Pointers","text":"<p>Pointers allow you to create references to data in the network:</p> Node.jsPythonRust <pre><code>import { Client, Pointer } from '@autonomi/client';\n\nasync function main() {\n    const client = new Client();\n    await client.connect();\n\n    // Create a pointer\n    const pointer = new Pointer();\n    pointer.setTarget(\"example-target\");\n\n    // Store the pointer\n    const address = await client.pointerPut(pointer);\n    console.log(`Pointer stored at: ${address}`);\n\n    // Retrieve the pointer\n    const retrieved = await client.pointerGet(address);\n    console.log(`Target: ${retrieved.getTarget()}`);\n}\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, Pointer\n\nasync def main():\n    client = Client()\n    await client.connect()\n\n    # Create a pointer\n    pointer = Pointer()\n    pointer.set_target(\"example-target\")\n\n    # Store the pointer\n    address = await client.pointer_put(pointer)\n    print(f\"Pointer stored at: {address}\")\n\n    # Retrieve the pointer\n    retrieved = await client.pointer_get(address)\n    print(f\"Target: {retrieved.get_target()}\")\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, Pointer, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Create a pointer\n    let mut pointer = Pointer::new();\n    pointer.set_target(\"example-target\");\n\n    // Store the pointer\n    let address = client.pointer_put(&amp;pointer)?;\n    println!(\"Pointer stored at: {}\", address);\n\n    // Retrieve the pointer\n    let retrieved = client.pointer_get(&amp;address)?;\n    println!(\"Target: {}\", retrieved.target());\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Local Network Setup</li> <li>EVM Integration</li> <li>Testing Guide</li> <li>API Reference</li> </ul>"},{"location":"guides/client_modes/","title":"Client Modes Guide","text":"<p>This guide explains how to use Autonomi's client modes to browse the network (read-only) and optionally upgrade to write capabilities.</p>"},{"location":"guides/client_modes/#overview","title":"Overview","text":"<p>Autonomi clients can operate in two modes:</p> <ol> <li>Read-Only Mode: Browse and read data from the network without requiring a wallet</li> <li>Read-Write Mode: Full access to both read and write operations, requires a wallet</li> </ol>"},{"location":"guides/client_modes/#read-only-client","title":"Read-Only Client","text":"<p>A read-only client allows you to browse and read data from the network without needing a wallet or making payments.</p>"},{"location":"guides/client_modes/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::init_read_only().await?;\n\n// Verify it's read-only\nassert!(!client.can_write());\nassert!(client.wallet().is_none());\n\n// Read operations work normally\nlet data = client.get_bytes(address).await?;\nlet file = client.get_file(file_map, \"output.txt\").await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Initialize a read-only client\nconst client = await Client.connect({\n    readOnly: true,\n    peers: ['/ip4/127.0.0.1/tcp/12000']\n});\n\n// Read operations\nconst data = await client.dataGetPublic(address);\nconst list = await client.linkedListGet(listAddress);\n</code></pre>"},{"location":"guides/client_modes/#python","title":"Python","text":"<pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.new()\n\n# Read operations\ndata = client.get_bytes(\"safe://example_address\")\nfile = client.get_file(file_map, \"output.txt\")\n</code></pre>"},{"location":"guides/client_modes/#upgrading-to-read-write-mode","title":"Upgrading to Read-Write Mode","text":"<p>You can upgrade a read-only client to read-write mode by adding a wallet. This enables write operations like storing data or updating linked lists.</p>"},{"location":"guides/client_modes/#rust_1","title":"Rust","text":"<pre><code>use autonomi::{Client, EvmWallet};\n\n// Start with a read-only client\nlet mut client = Client::init_read_only().await?;\n\n// Get a wallet (e.g., from a private key or create new)\nlet wallet = EvmWallet::from_private_key(private_key)?;\n\n// Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)?;\n\n// Now write operations are available\nlet address = client.store_bytes(data).await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript_1","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Start with a read-only client\nconst client = await Client.connect({\n    readOnly: true\n});\n\n// Upgrade with a wallet\nawait client.upgradeToReadWrite({\n    type: 'wallet',\n    wallet: 'your_wallet_address'\n});\n\n// Now you can perform write operations\nconst address = await client.dataPutPublic(\n    Buffer.from('Hello World'),\n    { type: 'wallet', wallet: client.wallet }\n);\n</code></pre>"},{"location":"guides/client_modes/#python_1","title":"Python","text":"<pre><code>from autonomi import Client, Wallet\n\n# Start with a read-only client\nclient = Client.new()\n\n# Create or import a wallet\nwallet = Wallet.from_private_key(\"your_private_key\")\n\n# Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)\n\n# Now write operations are available\naddress = client.store_bytes(b\"Hello World\")\n</code></pre>"},{"location":"guides/client_modes/#write-operations","title":"Write Operations","text":"<p>The following operations require a wallet (read-write mode):</p> <ul> <li>Storing public data (<code>dataPutPublic</code>)</li> <li>Creating/updating linked lists (<code>linkedListPut</code>)</li> <li>Setting pointers (<code>pointerPut</code>)</li> <li>Writing to vaults (<code>writeBytesToVault</code>)</li> <li>Updating user data (<code>putUserDataToVault</code>)</li> </ul> <p>Attempting these operations in read-only mode will result in an error.</p>"},{"location":"guides/client_modes/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start Read-Only: Begin with a read-only client if you only need to read data. This is simpler and more secure since no wallet is needed.</p> </li> <li> <p>Lazy Wallet Loading: Only upgrade to read-write mode when you actually need to perform write operations.</p> </li> <li> <p>Error Handling: Always handle potential errors when upgrading modes or performing write operations:</p> </li> </ol> <pre><code>try {\n    await client.upgradeToReadWrite(wallet);\n    await client.dataPutPublic(data, payment);\n} catch (error) {\n    if (error.code === 'NO_WALLET') {\n        console.error('Write operation attempted without wallet');\n    } else if (error.code === 'ALREADY_READ_WRITE') {\n        console.error('Client is already in read-write mode');\n    }\n}\n</code></pre> <ol> <li>Check Capabilities: Use the provided methods to check client capabilities:</li> </ol> <pre><code>if client.can_write() {\n    // Perform write operation\n} else {\n    // Handle read-only state\n}\n</code></pre>"},{"location":"guides/client_modes/#common-issues","title":"Common Issues","text":"<ol> <li>Attempting Write Operations in Read-Only Mode</li> <li>Error: <code>NO_WALLET</code> or <code>WriteAccessRequired</code></li> <li> <p>Solution: Upgrade to read-write mode by adding a wallet</p> </li> <li> <p>Multiple Upgrade Attempts</p> </li> <li>Error: <code>ALREADY_READ_WRITE</code></li> <li> <p>Solution: Check client mode before attempting upgrade</p> </li> <li> <p>Invalid Wallet</p> </li> <li>Error: <code>InvalidWallet</code> or <code>WalletError</code></li> <li>Solution: Ensure wallet is properly initialized with valid credentials</li> </ol>"},{"location":"guides/data_storage/","title":"Data Storage Guide","text":"<p>This guide explains how Autonomi handles data storage, including self-encryption and scratchpad features.</p>"},{"location":"guides/data_storage/#self-encryption","title":"Self-Encryption","text":"<p>Self-encryption is a core feature that provides secure data storage by splitting and encrypting data into chunks.</p>"},{"location":"guides/data_storage/#how-it-works","title":"How It Works","text":"<ol> <li>Data is split into chunks</li> <li>Each chunk is encrypted</li> <li>A data map is created to track the chunks</li> <li>Additional encryption layers are added for larger files</li> </ol>"},{"location":"guides/data_storage/#usage-examples","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nasync function storeEncryptedData(data: Uint8Array) {\n    const client = new Client();\n\n    // Data is automatically self-encrypted when stored\n    const address = await client.data_put_public(data);\n    console.log(`Data stored at: ${address}`);\n\n    // Retrieve and decrypt data\n    const retrieved = await client.data_get_public(address);\n    console.log('Data retrieved successfully');\n}\n</code></pre> <pre><code>from autonomi import Client\n\nasync def store_encrypted_data(data: bytes):\n    client = Client()\n\n    # Data is automatically self-encrypted when stored\n    address = await client.data_put_public(data)\n    print(f\"Data stored at: {address}\")\n\n    # Retrieve and decrypt data\n    retrieved = await client.data_get_public(address)\n    print(\"Data retrieved successfully\")\n</code></pre> <pre><code>use autonomi::{Client, Bytes, Result};\n\nasync fn store_encrypted_data(data: Bytes) -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Data is automatically self-encrypted when stored\n    let address = client.data_put_public(data).await?;\n    println!(\"Data stored at: {}\", address);\n\n    // Retrieve and decrypt data\n    let retrieved = client.data_get_public(&amp;address).await?;\n    println!(\"Data retrieved successfully\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#scratchpad","title":"Scratchpad","text":"<p>Scratchpad provides a mutable storage location for encrypted data with versioning support.</p>"},{"location":"guides/data_storage/#features","title":"Features","text":"<ul> <li>Mutable data storage</li> <li>Version tracking with monotonic counter</li> <li>Owner-based access control</li> <li>Data encryption</li> <li>Signature verification</li> </ul>"},{"location":"guides/data_storage/#usage-examples_1","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client, Scratchpad } from '@autonomi/client';\n\nasync function useScratchpad() {\n    const client = new Client();\n    const secretKey = await client.generate_secret_key();\n\n    // Create or get existing scratchpad\n    const [scratchpad, isNew] = await client.get_or_create_scratchpad(\n        secretKey,\n        42 // content type\n    );\n\n    // Update scratchpad data\n    const data = new TextEncoder().encode('Hello World');\n    await client.update_scratchpad(scratchpad, data, secretKey);\n\n    // Read scratchpad data\n    const retrieved = await client.get_scratchpad(scratchpad.address);\n    const decrypted = await client.decrypt_scratchpad(retrieved, secretKey);\n    console.log(new TextDecoder().decode(decrypted));\n}\n</code></pre> <pre><code>from autonomi import Client, Scratchpad\n\nasync def use_scratchpad():\n    client = Client()\n    secret_key = client.generate_secret_key()\n\n    # Create or get existing scratchpad\n    scratchpad, is_new = await client.get_or_create_scratchpad(\n        secret_key,\n        42  # content type\n    )\n\n    # Update scratchpad data\n    data = b\"Hello World\"\n    await client.update_scratchpad(scratchpad, data, secret_key)\n\n    # Read scratchpad data\n    retrieved = await client.get_scratchpad(scratchpad.address)\n    decrypted = await client.decrypt_scratchpad(retrieved, secret_key)\n    print(decrypted.decode())\n</code></pre> <pre><code>use autonomi::{Client, Scratchpad, SecretKey, Bytes, Result};\n\nasync fn use_scratchpad() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n    let secret_key = SecretKey::random();\n\n    // Create or get existing scratchpad\n    let (mut scratchpad, is_new) = client\n        .get_or_create_scratchpad(&amp;secret_key, 42)\n        .await?;\n\n    // Update scratchpad data\n    let data = Bytes::from(\"Hello World\");\n    scratchpad.update_and_sign(data, &amp;secret_key);\n\n    // Store updated scratchpad\n    client.put_scratchpad(&amp;scratchpad).await?;\n\n    // Read scratchpad data\n    let retrieved = client.get_scratchpad(scratchpad.address()).await?;\n    let decrypted = retrieved.decrypt_data(&amp;secret_key)?;\n    println!(\"Data: {}\", String::from_utf8_lossy(&amp;decrypted));\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#best-practices","title":"Best Practices","text":"<ol> <li>Version Management</li> <li>Always check the counter before updates</li> <li>Handle version conflicts appropriately</li> <li> <p>Use monotonic counters for ordering</p> </li> <li> <p>Security</p> </li> <li>Keep secret keys secure</li> <li>Verify signatures before trusting data</li> <li> <p>Always encrypt sensitive data</p> </li> <li> <p>Error Handling</p> </li> <li>Handle decryption failures gracefully</li> <li>Implement proper retry logic for network operations</li> <li> <p>Validate data before storage</p> </li> <li> <p>Performance</p> </li> <li>Cache frequently accessed data</li> <li>Batch updates when possible</li> <li>Monitor storage size</li> </ol>"},{"location":"guides/data_storage/#implementation-details","title":"Implementation Details","text":""},{"location":"guides/data_storage/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data Splitting</li> </ol> <pre><code>// Internal process when storing data\nlet (data_map, chunks) = self_encryption::encrypt(data)?;\nlet (data_map_chunk, additional_chunks) = pack_data_map(data_map)?;\n</code></pre> <ol> <li>Chunk Management</li> <li>Each chunk is stored separately</li> <li>Chunks are encrypted individually</li> <li>Data maps track chunk locations</li> </ol>"},{"location":"guides/data_storage/#scratchpad-structure","title":"Scratchpad Structure","text":"<pre><code>pub struct Scratchpad {\n    // Network address\n    address: ScratchpadAddress,\n    // Data type identifier\n    data_encoding: u64,\n    // Encrypted content\n    encrypted_data: Bytes,\n    // Version counter\n    counter: u64,\n    // Owner's signature\n    signature: Option&lt;Signature&gt;,\n}\n</code></pre>"},{"location":"guides/data_storage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/data_storage/#custom-data-types","title":"Custom Data Types","text":"<p>You can use scratchpads to store any custom data type by implementing proper serialization:</p> <pre><code>#[derive(Serialize, Deserialize)]\nstruct CustomData {\n    field1: String,\n    field2: u64,\n}\n\n// Serialize before storing\nlet custom_data = CustomData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet bytes = serde_json::to_vec(&amp;custom_data)?;\nscratchpad.update_and_sign(Bytes::from(bytes), &amp;secret_key);\n</code></pre>"},{"location":"guides/data_storage/#batch-operations","title":"Batch Operations","text":"<p>For better performance when dealing with multiple data items:</p> <pre><code>async fn batch_store(items: Vec&lt;Bytes&gt;) -&gt; Result&lt;Vec&lt;ChunkAddress&gt;&gt; {\n    let mut addresses = Vec::new();\n    for item in items {\n        let (data_map_chunk, chunks) = encrypt(item)?;\n        // Store chunks in parallel\n        futures::future::join_all(chunks.iter().map(|c| store_chunk(c))).await;\n        addresses.push(data_map_chunk.address());\n    }\n    Ok(addresses)\n}\n</code></pre>"},{"location":"guides/evm_integration/","title":"EVM Integration Guide","text":"<p>This guide explains how to integrate Autonomi with EVM-compatible networks for testing and development.</p>"},{"location":"guides/evm_integration/#supported-networks","title":"Supported Networks","text":"<ul> <li>Local Hardhat network</li> <li>Sepolia testnet</li> <li>Goerli testnet</li> <li>Custom EVM networks</li> </ul>"},{"location":"guides/evm_integration/#setting-up-test-networks","title":"Setting Up Test Networks","text":""},{"location":"guides/evm_integration/#local-hardhat-network","title":"Local Hardhat Network","text":"<pre><code>npx hardhat node\n</code></pre>"},{"location":"guides/evm_integration/#connecting-to-test-networks","title":"Connecting to Test Networks","text":"<pre><code>import { EvmNetwork } from '@autonomi/client';\n\nconst network = new EvmNetwork({\n  chainId: 31337, // Local hardhat network\n  rpcUrl: 'http://127.0.0.1:8545'\n});\n</code></pre>"},{"location":"guides/evm_integration/#deploying-test-contracts","title":"Deploying Test Contracts","text":"<ol> <li>Compile contracts</li> <li>Deploy using Hardhat</li> <li>Interact with contracts</li> </ol>"},{"location":"guides/evm_integration/#testing-with-different-networks","title":"Testing with Different Networks","text":"<ul> <li>Network configuration</li> <li>Gas settings</li> <li>Contract deployment</li> <li>Transaction handling</li> </ul>"},{"location":"guides/evm_integration/#best-practices","title":"Best Practices","text":"<ul> <li>Error handling</li> <li>Gas optimization</li> <li>Security considerations</li> <li>Testing strategies</li> </ul>"},{"location":"guides/local_development/","title":"Local Development Environment","text":"<p>This guide will help you set up a local development environment for building applications with Autonomi. We'll use a script that sets up a local network with all the necessary components for development and testing.</p>"},{"location":"guides/local_development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain installed</li> <li>Git repository cloned</li> <li>Basic understanding of terminal/command line</li> </ul>"},{"location":"guides/local_development/#setup-script","title":"Setup Script","text":"<p>Save the following script as <code>start-local-network.sh</code> in your project root:</p> <pre><code>#!/bin/bash\nset -e\n\n# Configuration\nNODE_DATA_DIR=\"$HOME/Library/Application Support/autonomi/node\"\nCLIENT_DATA_DIR=\"$HOME/Library/Application Support/autonomi/client\"\nEVM_PORT=4343\nEVM_RPC_URL=\"http://localhost:8545\"\nWALLET_ADDRESS=\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\nTOKEN_ADDRESS=\"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\nLOG_LEVEL=\"info\"\nNODE_PORT=5000\n\n# ... (rest of the script content) ...\n</code></pre> <p>Make the script executable:</p> <pre><code>chmod +x start-local-network.sh\n</code></pre>"},{"location":"guides/local_development/#using-the-development-environment","title":"Using the Development Environment","text":"<ol> <li>Start the local network:</li> </ol> <pre><code>./start-local-network.sh\n</code></pre> <ol> <li>The script will:</li> <li>Build all necessary components (ant-node, evm-testnet, ant CLI)</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li> <p>Set up the development environment</p> </li> <li> <p>Once running, you'll see information about:</p> </li> <li>Network endpoints</li> <li>Environment variables</li> <li>Example commands</li> </ol>"},{"location":"guides/local_development/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables should be set for your development environment:</p> <pre><code>export ANT_PEERS=/ip4/127.0.0.1/udp/5000/quic-v1\nexport ANT_LOG=info\nexport CLIENT_DATA_PATH=$HOME/Library/Application Support/autonomi/client\n</code></pre>"},{"location":"guides/local_development/#example-usage","title":"Example Usage","text":""},{"location":"guides/local_development/#file-operations","title":"File Operations","text":"<p>Upload a file:</p> <pre><code>./target/debug/ant file upload path/to/file\n</code></pre> <p>Download a file:</p> <pre><code>./target/debug/ant file download &lt;file-address&gt;\n</code></pre>"},{"location":"guides/local_development/#node-operations","title":"Node Operations","text":"<p>Check node status:</p> <pre><code>./target/debug/ant node status\n</code></pre> <p>Get wallet balance:</p> <pre><code>./target/debug/ant wallet balance\n</code></pre>"},{"location":"guides/local_development/#development-tips","title":"Development Tips","text":"<ol> <li> <p>Local Testing: The local network is perfect for testing your applications without affecting the main network.</p> </li> <li> <p>Quick Iterations: Changes to your application can be tested immediately without waiting for network confirmations.</p> </li> <li> <p>Clean State: Each time you start the network, it begins with a clean state, making it ideal for testing different scenarios.</p> </li> <li> <p>Debugging: The local environment provides detailed logs and quick feedback for debugging.</p> </li> </ol>"},{"location":"guides/local_development/#customization","title":"Customization","text":"<p>You can customize the development environment by modifying the configuration variables at the top of the script:</p> <ul> <li><code>NODE_PORT</code>: Change the port the node listens on</li> <li><code>LOG_LEVEL</code>: Adjust logging verbosity (\"trace\", \"debug\", \"info\", \"warn\", \"error\")</li> <li><code>EVM_PORT</code>: Change the EVM testnet port</li> <li>Other settings as needed</li> </ul>"},{"location":"guides/local_development/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Port Conflicts: If you see port-in-use errors, modify the <code>NODE_PORT</code> or <code>EVM_PORT</code> in the script.</p> </li> <li> <p>Process Cleanup: If the script fails to start, ensure no old processes are running:</p> </li> </ol> <pre><code>pkill -f \"antnode\"\npkill -f \"evm-testnet\"\n</code></pre> <ol> <li>Data Cleanup: To start completely fresh, remove the data directories:</li> </ol> <pre><code>rm -rf \"$HOME/Library/Application Support/autonomi/node\"\nrm -rf \"$HOME/Library/Application Support/autonomi/client\"\n</code></pre>"},{"location":"guides/local_network/","title":"Local Network Setup Guide","text":"<p>This guide explains how to set up and run a local Autonomi network for development and testing purposes.</p>"},{"location":"guides/local_network/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (with <code>cargo</code> installed)</li> <li>Git (for cloning the repository)</li> </ul> <p>That's it! Everything else needed will be built from source.</p>"},{"location":"guides/local_network/#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/dirvine/autonomi\ncd autonomi\n</code></pre> <ol> <li>Start the local network:</li> </ol> <pre><code>./test-local.sh\n</code></pre> <p>This script will:</p> <ul> <li>Build all necessary components</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li>Set up the development environment</li> </ul>"},{"location":"guides/local_network/#network-components","title":"Network Components","text":"<p>The local network consists of:</p> <ul> <li>An Autonomi node running in local mode</li> <li>A local EVM test network with pre-funded accounts</li> <li>Test wallets for development</li> </ul>"},{"location":"guides/local_network/#testing-with-evm-networks","title":"Testing with EVM Networks","text":"<p>The local EVM network provides a complete testing environment for blockchain interactions:</p>"},{"location":"guides/local_network/#pre-deployed-contracts","title":"Pre-deployed Contracts","text":"<p>The following contracts are automatically deployed:</p> <ul> <li>Payment Vault Contract (<code>PaymentVaultNoProxy</code>)</li> <li>Handles data storage payments</li> <li>Manages token approvals and transfers</li> <li>Verifies payment proofs</li> <li>Test Token Contract (<code>TestToken</code>)</li> <li>ERC20 token for testing payments</li> <li>Pre-minted supply for test accounts</li> <li>Automatic approval for test wallets</li> </ul>"},{"location":"guides/local_network/#test-accounts","title":"Test Accounts","text":"<p>Several accounts are pre-funded and ready to use:</p> <pre><code>Primary Test Account:\nAddress: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nPrivate Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nBalance: 10000 TEST tokens\n\nSecondary Test Account:\nAddress: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8\nPrivate Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\nBalance: 1000 TEST tokens\n</code></pre>"},{"location":"guides/local_network/#rpc-endpoint","title":"RPC Endpoint","text":"<p>The local EVM network exposes an RPC endpoint at <code>http://localhost:8545</code> with:</p> <ul> <li>Full JSON-RPC API support</li> <li>WebSocket subscriptions</li> <li>Low block time (1 second)</li> <li>Zero gas costs</li> <li>Instant transaction confirmations</li> </ul>"},{"location":"guides/local_network/#interacting-with-the-network","title":"Interacting with the Network","text":""},{"location":"guides/local_network/#javascripttypescript","title":"JavaScript/TypeScript","text":"<pre><code>import { ethers } from 'ethers';\n\n// Connect to local network\nconst provider = new ethers.JsonRpcProvider('http://localhost:8545');\nconst wallet = new ethers.Wallet(PRIVATE_KEY, provider);\n\n// Get contract instances\nconst paymentVault = new ethers.Contract(\n  PAYMENT_VAULT_ADDRESS,\n  PAYMENT_VAULT_ABI,\n  wallet\n);\n\n// Interact with contracts\nawait paymentVault.getQuote([metrics]);\nawait paymentVault.payForQuotes(payments);\n</code></pre>"},{"location":"guides/local_network/#python","title":"Python","text":"<pre><code>from web3 import Web3\nfrom eth_account import Account\n\n# Connect to local network\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\naccount = Account.from_key(PRIVATE_KEY)\n\n# Get contract instances\npayment_vault = w3.eth.contract(\n    address=PAYMENT_VAULT_ADDRESS,\n    abi=PAYMENT_VAULT_ABI\n)\n\n# Interact with contracts\npayment_vault.functions.getQuote([metrics]).call()\npayment_vault.functions.payForQuotes(payments).transact()\n</code></pre>"},{"location":"guides/local_network/#rust","title":"Rust","text":"<pre><code>use ethers::prelude::*;\n\n// Connect to local network\nlet provider = Provider::&lt;Http&gt;::try_from(\"http://localhost:8545\")?;\nlet wallet = LocalWallet::from_bytes(&amp;PRIVATE_KEY)?;\nlet client = SignerMiddleware::new(provider, wallet);\n\n// Get contract instances\nlet payment_vault = PaymentVault::new(\n    PAYMENT_VAULT_ADDRESS,\n    Arc::new(client)\n);\n\n// Interact with contracts\npayment_vault.get_quote(metrics).call().await?;\npayment_vault.pay_for_quotes(payments).send().await?;\n</code></pre>"},{"location":"guides/local_network/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are set up automatically:</p> <ul> <li><code>ANT_PEERS</code> - Local node endpoint</li> <li><code>ANT_LOG</code> - Logging level</li> <li><code>CLIENT_DATA_PATH</code> - Client data directory</li> </ul>"},{"location":"guides/local_network/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"guides/local_network/#logging","title":"Logging","text":""},{"location":"guides/local_network/#node-logs","title":"Node Logs","text":"<p>The Autonomi node generates detailed logs that can be controlled via <code>RUST_LOG</code>:</p> <pre><code># Trace level for maximum detail\nRUST_LOG=trace ./test-local.sh\n\n# Focus on specific modules\nRUST_LOG=autonomi=debug,ant_node=trace ./test-local.sh\n\n# Log locations:\n- Node logs: $NODE_DATA_DIR/node.log\n- EVM logs: $NODE_DATA_DIR/evm.log\n</code></pre>"},{"location":"guides/local_network/#log-levels","title":"Log Levels","text":"<ul> <li><code>error</code>: Critical issues that need immediate attention</li> <li><code>warn</code>: Important events that aren't failures</li> <li><code>info</code>: General operational information</li> <li><code>debug</code>: Detailed information for debugging</li> <li><code>trace</code>: Very detailed protocol-level information</li> </ul>"},{"location":"guides/local_network/#following-logs","title":"Following Logs","text":"<pre><code># Follow node logs\ntail -f \"$NODE_DATA_DIR/node.log\"\n\n# Follow EVM logs\ntail -f \"$NODE_DATA_DIR/evm.log\"\n\n# Filter for specific events\ntail -f \"$NODE_DATA_DIR/node.log\" | grep \"payment\"\n</code></pre>"},{"location":"guides/local_network/#debugging","title":"Debugging","text":""},{"location":"guides/local_network/#node-debugging","title":"Node Debugging","text":"<p>Using <code>rust-lldb</code>:</p> <pre><code># Start node with debugger\nrust-lldb target/debug/antnode -- --features test\n\n# Common commands:\nb autonomi::client::payment::pay  # Set breakpoint\nr                                # Run\nbt                              # Backtrace\np variable                      # Print variable\nc                              # Continue\n</code></pre> <p>Using <code>rust-gdb</code>:</p> <pre><code># Start node with debugger\nrust-gdb target/debug/antnode -- --features test\n\n# Common commands:\nbreak autonomi::client::payment::pay  # Set breakpoint\nrun                                  # Run\nbacktrace                           # Show backtrace\nprint variable                      # Examine variable\ncontinue                            # Continue execution\n</code></pre>"},{"location":"guides/local_network/#network-monitoring","title":"Network Monitoring","text":"<p>Monitor network activity:</p> <pre><code># Watch network connections\nnetstat -an | grep 5000  # Default node port\n\n# Monitor network traffic\nsudo tcpdump -i lo0 port 5000\n\n# Check EVM network\ncurl -X POST -H \"Content-Type: application/json\" \\\n  --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' \\\n  http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#contract-debugging","title":"Contract Debugging","text":"<p>Debug contract interactions:</p> <pre><code># Get payment vault state\ncast call $PAYMENT_VAULT_ADDRESS \\\n  \"payments(bytes32)\" \\\n  $QUOTE_HASH \\\n  --rpc-url http://localhost:8545\n\n# Watch for payment events\ncast events $PAYMENT_VAULT_ADDRESS \\\n  --rpc-url http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"guides/local_network/#port-conflicts","title":"Port Conflicts","text":"<p>If you see port-in-use errors:</p> <ol> <li>Check if another instance is running</li> <li>Use different ports in the script</li> <li>Kill existing processes if needed</li> </ol>"},{"location":"guides/local_network/#build-issues","title":"Build Issues","text":"<ol> <li>Make sure Rust toolchain is up to date</li> <li>Clean and rebuild: <code>cargo clean &amp;&amp; cargo build</code></li> <li>Check for missing dependencies</li> </ol>"},{"location":"guides/local_network/#network-issues","title":"Network Issues","text":"<ol> <li>Verify the node is running</li> <li>Check log output for errors</li> <li>Ensure EVM testnet is accessible</li> </ol>"},{"location":"guides/local_network/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/local_network/#custom-configuration","title":"Custom Configuration","text":"<p>You can modify the test script to:</p> <ul> <li>Change ports</li> <li>Adjust logging levels</li> <li>Configure node parameters</li> </ul>"},{"location":"guides/local_network/#multiple-nodes","title":"Multiple Nodes","text":"<p>To run multiple nodes:</p> <ol> <li>Copy the script</li> <li>Modify ports and directories</li> <li>Run each instance separately</li> </ol>"},{"location":"guides/payments/","title":"Payments Guide","text":"<p>This guide explains how payments work in Autonomi, particularly for put operations that store data on the network.</p>"},{"location":"guides/payments/#overview","title":"Overview","text":"<p>When storing data on the Autonomi network, you need to pay for the storage space. Payments are made using EVM-compatible tokens through a smart contract system. There are two ways to handle payments:</p> <ol> <li>Direct payment using an EVM wallet</li> <li>Pre-paid operations using a receipt</li> </ol>"},{"location":"guides/payments/#payment-options","title":"Payment Options","text":""},{"location":"guides/payments/#using-an-evm-wallet","title":"Using an EVM Wallet","text":"<p>The simplest way to pay for put operations is to use an EVM wallet:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\n\n# Create or load a wallet\nwallet = EvmWallet.create()  # or load from private key\npayment = PaymentOption.from_wallet(wallet)\n\n# Put data with wallet payment\ndata = b\"Hello, World!\"\naddress = client.data_put_public(data, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\n\n// Create or load a wallet\nconst wallet = EvmWallet.create();  // or load from private key\nconst payment = PaymentOption.fromWallet(wallet);\n\n// Put data with wallet payment\nconst data = Buffer.from(\"Hello, World!\");\nconst address = await client.dataPutPublic(data, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\n\n// Create or load a wallet\nlet wallet = EvmWallet::create()?;  // or load from private key\nlet payment = wallet.into();  // Converts to PaymentOption\n\n// Put data with wallet payment\nlet data = b\"Hello, World!\".to_vec();\nlet address = client.data_put_public(data.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#using-pre-paid-receipts","title":"Using Pre-paid Receipts","text":"<p>For better efficiency when doing multiple put operations, you can pre-pay for storage and reuse the receipt:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\nwallet = EvmWallet.create()\n\n# Get receipt for multiple operations\ndata1 = b\"First piece of data\"\ndata2 = b\"Second piece of data\"\n\n# Create payment receipt\nreceipt = client.create_payment_receipt([data1, data2], wallet)\npayment = PaymentOption.from_receipt(receipt)\n\n# Use receipt for puts\naddr1 = client.data_put_public(data1, payment)\naddr2 = client.data_put_public(data2, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\nconst wallet = EvmWallet.create();\n\n// Get receipt for multiple operations\nconst data1 = Buffer.from(\"First piece of data\");\nconst data2 = Buffer.from(\"Second piece of data\");\n\n// Create payment receipt\nconst receipt = await client.createPaymentReceipt([data1, data2], wallet);\nconst payment = PaymentOption.fromReceipt(receipt);\n\n// Use receipt for puts\nconst addr1 = await client.dataPutPublic(data1, payment);\nconst addr2 = await client.dataPutPublic(data2, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\nlet wallet = EvmWallet::create()?;\n\n// Get receipt for multiple operations\nlet data1 = b\"First piece of data\".to_vec();\nlet data2 = b\"Second piece of data\".to_vec();\n\n// Create payment receipt\nlet receipt = client.create_payment_receipt(\n    vec![data1.clone(), data2.clone()].into_iter(), \n    &amp;wallet\n).await?;\nlet payment = receipt.into();  // Converts to PaymentOption\n\n// Use receipt for puts\nlet addr1 = client.data_put_public(data1.into(), payment.clone()).await?;\nlet addr2 = client.data_put_public(data2.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#cost-calculation","title":"Cost Calculation","text":"<p>The cost of storing data depends on several factors:</p> <ul> <li>Size of the data</li> <li>Network density</li> <li>Storage duration</li> <li>Current network conditions</li> </ul> <p>You can calculate the cost before performing a put operation:</p> <pre><code># Python\ncost = client.calculate_storage_cost(data)\nprint(f\"Storage will cost {cost} tokens\")\n</code></pre> <pre><code>// Node.js\nconst cost = await client.calculateStorageCost(data);\nconsole.log(`Storage will cost ${cost} tokens`);\n</code></pre> <pre><code>// Rust\nlet cost = client.calculate_storage_cost(&amp;data).await?;\nprintln!(\"Storage will cost {} tokens\", cost);\n</code></pre>"},{"location":"guides/payments/#token-management","title":"Token Management","text":"<p>Before you can pay for storage, you need to ensure your wallet has sufficient tokens and has approved the payment contract to spend them:</p> <pre><code># Python\n# Check balance\nbalance = wallet.get_balance()\n\n# Approve tokens if needed\nif not wallet.has_approved_tokens():\n    wallet.approve_tokens()\n</code></pre> <pre><code>// Node.js\n// Check balance\nconst balance = await wallet.getBalance();\n\n// Approve tokens if needed\nif (!await wallet.hasApprovedTokens()) {\n    await wallet.approveTokens();\n}\n</code></pre> <pre><code>// Rust\n// Check balance\nlet balance = wallet.get_balance().await?;\n\n// Approve tokens if needed\nif !wallet.has_approved_tokens().await? {\n    wallet.approve_tokens().await?;\n}\n</code></pre>"},{"location":"guides/payments/#error-handling","title":"Error Handling","text":"<p>Common payment-related errors you might encounter:</p> <ol> <li><code>InsufficientBalance</code> - Wallet doesn't have enough tokens</li> <li><code>TokenNotApproved</code> - Token spending not approved for the payment contract</li> <li><code>PaymentExpired</code> - Payment quote has expired (when using receipts)</li> <li><code>PaymentVerificationFailed</code> - Payment verification failed on the network</li> </ol> <p>Example error handling:</p> <pre><code># Python\ntry:\n    address = client.data_put_public(data, payment)\nexcept InsufficientBalance:\n    print(\"Not enough tokens in wallet\")\nexcept TokenNotApproved:\n    print(\"Need to approve token spending\")\nexcept PaymentError as e:\n    print(f\"Payment failed: {e}\")\n</code></pre> <pre><code>// Node.js\ntry {\n    const address = await client.dataPutPublic(data, payment);\n} catch (e) {\n    if (e instanceof InsufficientBalance) {\n        console.log(\"Not enough tokens in wallet\");\n    } else if (e instanceof TokenNotApproved) {\n        console.log(\"Need to approve token spending\");\n    } else {\n        console.log(`Payment failed: ${e}`);\n    }\n}\n</code></pre> <pre><code>// Rust\nmatch client.data_put_public(data.into(), payment).await {\n    Err(PutError::InsufficientBalance) =&gt; {\n        println!(\"Not enough tokens in wallet\");\n    }\n    Err(PutError::TokenNotApproved) =&gt; {\n        println!(\"Need to approve token spending\");\n    }\n    Err(e) =&gt; {\n        println!(\"Payment failed: {}\", e);\n    }\n    Ok(address) =&gt; {\n        println!(\"Data stored at {}\", address);\n    }\n}\n</code></pre>"},{"location":"guides/payments/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-approve Tokens: Approve token spending before starting put operations to avoid extra transactions.</p> </li> <li> <p>Use Receipts: When doing multiple put operations, use receipts to avoid making separate payments for each operation.</p> </li> <li> <p>Check Costs: Always check storage costs before proceeding with large data uploads.</p> </li> <li> <p>Handle Errors: Implement proper error handling for payment-related issues.</p> </li> <li> <p>Monitor Balance: Keep track of your wallet balance to ensure sufficient funds for operations.</p> </li> </ol>"},{"location":"guides/payments/#testing-payments","title":"Testing Payments","text":"<p>When testing your application, you can use the local development environment which provides a test EVM network with pre-funded wallets. See the Local Development Guide for details.</p>"},{"location":"guides/testing_guide/","title":"Testing Guide","text":"<p>This guide covers testing strategies for Autonomi applications across different languages and environments.</p>"},{"location":"guides/testing_guide/#test-environment-setup","title":"Test Environment Setup","text":""},{"location":"guides/testing_guide/#nodejs","title":"Node.js","text":"<pre><code>npm install --save-dev jest @types/jest ts-jest\n</code></pre>"},{"location":"guides/testing_guide/#python","title":"Python","text":"<pre><code>pip install pytest pytest-asyncio\n</code></pre>"},{"location":"guides/testing_guide/#rust","title":"Rust","text":"<pre><code>cargo install cargo-test\n</code></pre>"},{"location":"guides/testing_guide/#writing-tests","title":"Writing Tests","text":""},{"location":"guides/testing_guide/#nodejs-example","title":"Node.js Example","text":"<pre><code>import { Client, LinkedList } from '@autonomi/client';\n\ndescribe('LinkedList Operations', () =&gt; {\n  let client: Client;\n\n  beforeEach(() =&gt; {\n    client = new Client();\n  });\n\n  test('should store and retrieve linked list', async () =&gt; {\n    const list = new LinkedList();\n    list.append(\"test data\");\n\n    const address = await client.linkedListPut(list);\n    const retrieved = await client.linkedListGet(address);\n\n    expect(retrieved.toString()).toBe(\"test data\");\n  });\n});\n</code></pre>"},{"location":"guides/testing_guide/#python-example","title":"Python Example","text":"<pre><code>import pytest\nfrom autonomi import Client, LinkedList\n\n@pytest.mark.asyncio\nasync def test_linked_list_operations():\n    client = Client()\n\n    # Create and store list\n    list_obj = LinkedList()\n    list_obj.append(\"test data\")\n\n    address = await client.linked_list_put(list_obj)\n    retrieved = await client.linked_list_get(address)\n\n    assert str(retrieved) == \"test data\"\n</code></pre>"},{"location":"guides/testing_guide/#rust-example","title":"Rust Example","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_linked_list_operations() {\n        let client = Client::new();\n\n        let mut list = LinkedList::new();\n        list.append(\"test data\");\n\n        let address = client.linked_list_put(&amp;list).unwrap();\n        let retrieved = client.linked_list_get(&amp;address).unwrap();\n\n        assert_eq!(retrieved.to_string(), \"test data\");\n    }\n}\n</code></pre>"},{"location":"guides/testing_guide/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests</li> <li>Integration Tests</li> <li>Network Tests</li> <li>EVM Integration Tests</li> </ol>"},{"location":"guides/testing_guide/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>GitHub Actions configuration</li> <li>Test automation</li> <li>Coverage reporting</li> </ul>"},{"location":"guides/testing_guide/#best-practices","title":"Best Practices","text":"<ul> <li>Test isolation</li> <li>Mock network calls</li> <li>Error scenarios</li> <li>Performance testing</li> </ul>"}]}