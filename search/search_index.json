{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autonomi Documentation","text":"<p>Welcome to the Autonomi documentation! This guide will help you get started with using the Autonomi network client.</p>"},{"location":"#what-is-autonomi","title":"What is Autonomi?","text":"<p>Autonomi is a decentralized network client that provides:</p> <ul> <li>Distributed data storage and retrieval</li> <li>EVM network integration</li> <li>Secure pointer management</li> <li>Linked list data structures</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Local Network Setup</li> </ul>"},{"location":"#language-support","title":"Language Support","text":"<p>Autonomi provides client libraries for multiple languages:</p> Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nconst client = new Client();\nawait client.connect();\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client()\nawait client.connect()\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new()?;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol> <p>For more details, see our Contributing Guide.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues</li> <li>API Reference</li> <li>Testing Guide</li> </ul>"},{"location":"api/","title":"Autonomi API Reference","text":"<p>The Autonomi API provides a consistent interface across multiple programming languages, making it easy to build applications in your preferred language while maintaining the same powerful capabilities.</p>"},{"location":"api/#installation","title":"Installation","text":""},{"location":"api/#rust","title":"Rust","text":"<pre><code>[dependencies]\nautonomi = \"0.1.0\"\n</code></pre>"},{"location":"api/#python","title":"Python","text":"<pre><code>pip install autonomi\n</code></pre>"},{"location":"api/#typescriptnodejs","title":"TypeScript/Node.js","text":"<pre><code>npm install autonomi\n</code></pre>"},{"location":"api/#client-initialization","title":"Client Initialization","text":"<p>Initialize a client with flexible options for security and performance:</p>"},{"location":"api/#rust_1","title":"Rust","text":"<pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::init_read_only().await?;\n\n// Initialize with write capabilities and config\nlet config = ClientConfig::builder()\n    .with_quantum_security(true)\n    .with_compression(true)\n    .build();\nlet client = Client::init_with_wallet_and_config(wallet, config).await?;\n</code></pre>"},{"location":"api/#python_1","title":"Python","text":"<pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.init_read_only()\n\n# Initialize with write capabilities and config\nconfig = {\n    'quantum_security': True,\n    'compression': True,\n    'cache_size': '1GB'\n}\nclient = Client.init_with_wallet_and_config(wallet, config)\n</code></pre>"},{"location":"api/#typescriptnodejs_1","title":"TypeScript/Node.js","text":"<pre><code>import { Client, ClientConfig } from 'autonomi';\n\n// Initialize a read-only client\nconst client = await Client.initReadOnly();\n\n// Initialize with write capabilities and config\nconst config: ClientConfig = {\n    quantumSecurity: true,\n    compression: true,\n    cacheSize: '1GB'\n};\nconst client = await Client.initWithWalletAndConfig(wallet, config);\n</code></pre>"},{"location":"api/#core-data-types","title":"Core Data Types","text":""},{"location":"api/#chunk-quantum-secure-storage","title":"Chunk - Quantum-Secure Storage","text":"<p>Store and retrieve immutable, quantum-secure encrypted data:</p>"},{"location":"api/#rust_2","title":"Rust","text":"<pre><code>use autonomi::Chunk;\n\n// Store raw data\nlet data = b\"Hello, World!\";\nlet chunk = client.store_chunk(data).await?;\n\n// Retrieve data\nlet retrieved = client.get_chunk(chunk.address()).await?;\nassert_eq!(data, &amp;retrieved[..]);\n\n// Get metadata\nlet metadata = client.get_chunk_metadata(chunk.address()).await?;\nprintln!(\"Size: {}, Replicas: {}\", metadata.size, metadata.replicas);\n</code></pre>"},{"location":"api/#python_2","title":"Python","text":"<pre><code>from autonomi import Chunk\nimport numpy as np\n\n# Store raw data\ndata = b\"Hello, World!\"\nchunk = client.store_chunk(data)\n\n# Store numpy array\narray_data = np.random.randn(1000, 1000)\nchunk = client.store_chunk_compressed(array_data.tobytes())\n\n# Retrieve data\nretrieved = client.get_chunk(chunk.address)\nassert data == retrieved\n\n# Get metadata\nmetadata = client.get_chunk_metadata(chunk.address)\nprint(f\"Size: {metadata.size}, Replicas: {metadata.replicas}\")\n</code></pre>"},{"location":"api/#typescriptnodejs_2","title":"TypeScript/Node.js","text":"<pre><code>import { Chunk } from 'autonomi';\n\n// Store raw data\nconst data = Buffer.from('Hello, World!');\nconst chunk = await client.storeChunk(data);\n\n// Store with streaming\nconst stream = createReadStream('large-file.dat');\nconst chunk = await client.storeChunkStream(stream);\n\n// Retrieve data\nconst retrieved = await client.getChunk(chunk.address);\nassert(Buffer.compare(data, retrieved) === 0);\n\n// Get metadata\nconst metadata = await client.getChunkMetadata(chunk.address);\nconsole.log(`Size: ${metadata.size}, Replicas: ${metadata.replicas}`);\n</code></pre>"},{"location":"api/#pointer-mutable-references","title":"Pointer - Mutable References","text":"<p>Create and manage version-tracked references:</p>"},{"location":"api/#rust_3","title":"Rust","text":"<pre><code>use autonomi::Pointer;\n\n// Create a pointer with metadata\nlet pointer = client.create_pointer_with_metadata(\n    target_address,\n    metadata,\n).await?;\n\n// Update with version checking\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve with caching\nlet target = client.resolve_pointer_cached(pointer.address()).await?;\n\n// Get metadata\nlet metadata = client.get_pointer_metadata(pointer.address()).await?;\nprintln!(\"Version: {}, Updates: {}\", metadata.version, metadata.update_count);\n</code></pre>"},{"location":"api/#python_3","title":"Python","text":"<pre><code>from autonomi import Pointer\nfrom datetime import datetime\n\n# Create a pointer with metadata\nmetadata = {\n    'created_at': datetime.utcnow(),\n    'description': 'Latest model weights'\n}\npointer = client.create_pointer_with_metadata(\n    target_address,\n    metadata\n)\n\n# Update with version checking\nclient.update_pointer(pointer.address, new_target_address)\n\n# Resolve with caching\ntarget = client.resolve_pointer_cached(pointer.address)\n\n# Get metadata\nmetadata = client.get_pointer_metadata(pointer.address)\nprint(f\"Version: {metadata.version}, Updates: {metadata.update_count}\")\n</code></pre>"},{"location":"api/#typescriptnodejs_3","title":"TypeScript/Node.js","text":"<pre><code>import { Pointer } from 'autonomi';\n\n// Create a pointer with metadata\nconst metadata = {\n    createdAt: new Date(),\n    description: 'Latest application state'\n};\nconst pointer = await client.createPointerWithMetadata(\n    targetAddress,\n    metadata\n);\n\n// Update with version checking\nawait client.updatePointer(pointer.address, newTargetAddress);\n\n// Subscribe to updates\nclient.subscribeToPointer(pointer.address, (update) =&gt; {\n    console.log(`New target: ${update.target}`);\n});\n\n// Get metadata\nconst metadata = await client.getPointerMetadata(pointer.address);\nconsole.log(`Version: ${metadata.version}, Updates: ${metadata.updateCount}`);\n</code></pre>"},{"location":"api/#linkedlist-transaction-chains","title":"LinkedList - Transaction Chains","text":"<p>Build decentralized DAG structures:</p>"},{"location":"api/#rust_4","title":"Rust","text":"<pre><code>use autonomi::LinkedList;\n\n// Create with configuration\nlet config = LinkedListConfig::new()\n    .with_fork_detection(true)\n    .with_history_compression(true);\nlet list = client.create_linked_list_with_config(config).await?;\n\n// Batch appends\nclient.append_to_list_batch(list.address(), items).await?;\n\n// Stream contents\nlet mut items = client.stream_list(list.address());\nwhile let Some(item) = items.next().await {\n    process_item(item?);\n}\n\n// Fork detection\nmatch client.detect_forks_detailed(list.address()).await? {\n    Fork::None =&gt; println!(\"No forks detected\"),\n    Fork::Detected(branches) =&gt; {\n        let resolved = client.resolve_fork_automatically(branches).await?;\n        println!(\"Fork resolved: {:?}\", resolved);\n    }\n}\n</code></pre>"},{"location":"api/#python_4","title":"Python","text":"<pre><code>from autonomi import LinkedList\nimport pandas as pd\n\n# Create with configuration\nconfig = {\n    'fork_detection': True,\n    'history_compression': True\n}\nlist = client.create_linked_list_with_config(config)\n\n# Batch appends\nclient.append_to_list_batch(list.address, items)\n\n# Stream contents\nfor item in client.stream_list(list.address):\n    process_item(item)\n\n# Stream as DataFrame\nfor chunk in client.stream_list_as_dataframe(list.address):\n    process_dataframe(chunk)\n\n# Fork detection\nforks = client.detect_forks_detailed(list.address)\nif not forks:\n    print(\"No forks detected\")\nelse:\n    resolved = client.resolve_fork_automatically(forks.branches)\n    print(f\"Fork resolved: {resolved}\")\n</code></pre>"},{"location":"api/#typescriptnodejs_4","title":"TypeScript/Node.js","text":"<pre><code>import { LinkedList } from 'autonomi';\n\n// Create with configuration\nconst config = {\n    forkDetection: true,\n    historyCompression: true,\n    realtime: true\n};\nconst list = await client.createLinkedListWithConfig(config);\n\n// Batch appends\nawait client.appendToListBatch(list.address, items);\n\n// Subscribe to updates\nclient.subscribeToList(list.address, (update) =&gt; {\n    console.log(`New item: ${update.data}`);\n});\n\n// Fork detection\nconst forks = await client.detectForksDetailed(list.address);\nif (!forks) {\n    console.log('No forks detected');\n} else {\n    const resolved = await client.resolveForkAutomatically(forks.branches);\n    console.log(`Fork resolved: ${resolved}`);\n}\n</code></pre>"},{"location":"api/#scratchpad-temporary-workspace","title":"ScratchPad - Temporary Workspace","text":"<p>Efficient unstructured data storage with CRDT properties:</p>"},{"location":"api/#rust_5","title":"Rust","text":"<pre><code>use autonomi::{ScratchPad, ContentType};\n\n// Create with configuration\nlet config = ScratchpadConfig::new()\n    .with_compression(true)\n    .with_encryption(true);\nlet pad = client.create_scratchpad_with_config(\n    ContentType::UserSettings,\n    config,\n).await?;\n\n// Batch updates\nlet updates = vec![Update::new(key1, value1), Update::new(key2, value2)];\nclient.update_scratchpad_batch(pad.address(), updates).await?;\n\n// Stream updates\nlet mut updates = client.stream_scratchpad_updates(pad.address());\nwhile let Some(update) = updates.next().await {\n    process_update(update?);\n}\n</code></pre>"},{"location":"api/#python_5","title":"Python","text":"<pre><code>from autonomi import ScratchPad, ContentType\n\n# Create with configuration\nconfig = {\n    'compression': True,\n    'encryption': True\n}\npad = client.create_scratchpad_with_config(\n    ContentType.USER_SETTINGS,\n    config\n)\n\n# Batch updates\nupdates = [\n    ('key1', value1),\n    ('key2', value2)\n]\nclient.update_scratchpad_batch(pad.address, updates)\n\n# Store DataFrame\ndf = pd.DataFrame({'A': range(1000), 'B': range(1000)})\nclient.update_scratchpad_dataframe(pad.address, df)\n\n# Stream updates\nfor update in client.stream_scratchpad_updates(pad.address):\n    process_update(update)\n</code></pre>"},{"location":"api/#typescriptnodejs_5","title":"TypeScript/Node.js","text":"<pre><code>import { ScratchPad, ContentType } from 'autonomi';\n\n// Create with configuration\nconst config = {\n    compression: true,\n    encryption: true,\n    realtime: true\n};\nconst pad = await client.createScratchpadWithConfig(\n    ContentType.UserSettings,\n    config\n);\n\n// Update with JSON\nconst settings = { theme: 'dark', fontSize: 14 };\nawait client.updateScratchpadJson(pad.address, settings);\n\n// Subscribe to updates\nclient.subscribeToScratchpad(pad.address, (update) =&gt; {\n    console.log(`New data: ${update.data}`);\n});\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>Each language provides comprehensive error handling:</p>"},{"location":"api/#rust_6","title":"Rust","text":"<pre><code>use autonomi::error::{ChunkError, PointerError};\n\nmatch client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound { address }) =&gt; {\n        println!(\"Chunk not found: {}\", address);\n        handle_missing()\n    },\n    Err(ChunkError::NetworkError(e)) =&gt; {\n        println!(\"Network error: {}\", e);\n        handle_network_error(e)\n    },\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"api/#python_6","title":"Python","text":"<pre><code>from autonomi.errors import ChunkError, PointerError\n\ntry:\n    data = client.get_chunk(address)\n    process_data(data)\nexcept ChunkError.NotFound as e:\n    print(f\"Chunk not found: {e.address}\")\n    handle_missing()\nexcept ChunkError.NetworkError as e:\n    print(f\"Network error: {e}\")\n    handle_network_error(e)\nexcept Exception as e:\n    handle_other_error(e)\n</code></pre>"},{"location":"api/#typescriptnodejs_6","title":"TypeScript/Node.js","text":"<pre><code>import { ChunkError, PointerError } from 'autonomi/errors';\n\ntry {\n    const data = await client.getChunk(address);\n    processData(data);\n} catch (error) {\n    if (error instanceof ChunkError.NotFound) {\n        console.log(`Chunk not found: ${error.address}`);\n        handleMissing();\n    } else if (error instanceof ChunkError.NetworkError) {\n        console.log(`Network error: ${error.message}`);\n        handleNetworkError(error);\n    } else {\n        handleOtherError(error);\n    }\n}\n</code></pre>"},{"location":"api/#further-reading","title":"Further Reading","text":"<ul> <li>Web Development Guide</li> <li>Data Science Guide</li> <li>Quantum Security Guide</li> <li>Error Handling Guide</li> <li>Rust Performance Guide</li> </ul>"},{"location":"api/nodejs/","title":"Node.js/TypeScript API Documentation","text":"<p>The TypeScript/Node.js implementation of Autonomi provides a modern, type-safe interface for web and server applications. It's ideal for:</p> <ul> <li>Building decentralized web applications</li> <li>Creating secure backend services</li> <li>Developing real-time applications</li> <li>Integration with modern web frameworks</li> </ul>"},{"location":"api/nodejs/#installation","title":"Installation","text":"<pre><code># Install with npm\nnpm install autonomi\n\n# Or with specific features\nnpm install autonomi@latest quantum-secure compression\n\n# For web applications\nnpm install autonomi@latest web\n</code></pre>"},{"location":"api/nodejs/#client-initialization","title":"Client Initialization","text":"<p>The client provides flexible initialization options to match your application needs:</p> <pre><code>import { Client, ClientConfig } from 'autonomi';\n\n// Initialize a read-only client for browsing\nconst client = await Client.initReadOnly();\n\n// Initialize with write capabilities and custom configuration\nconst config: ClientConfig = {\n    quantumSecurity: true,\n    compression: true,\n    cacheSize: '1GB',\n    webSocket: true\n};\nconst client = await Client.initWithWalletAndConfig(wallet, config);\n\n// Upgrade a read-only client to read-write\nawait client.upgradeToReadWrite(wallet);\n</code></pre>"},{"location":"api/nodejs/#core-data-types","title":"Core Data Types","text":""},{"location":"api/nodejs/#chunk-quantum-secure-storage","title":"Chunk - Quantum-Secure Storage","text":"<p>Store and retrieve immutable, quantum-secure encrypted data with streaming support:</p> <pre><code>import { Chunk, ChunkOptions } from 'autonomi';\n\n// Store raw data as a chunk\nconst data = Buffer.from('Hello, World!');\nconst chunk = await client.storeChunk(data);\n\n// Store large file with streaming\nconst stream = createReadStream('large-file.dat');\nconst chunk = await client.storeChunkStream(stream, {\n    compression: true,\n    chunkSize: '1MB'\n});\n\n// Retrieve chunk data with streaming\nconst retrieved = await client.getChunk(chunk.address);\nassert(Buffer.compare(data, retrieved) === 0);\n\n// Stream large chunks\nconst stream = await client.getChunkStream(chunk.address);\nstream.pipe(createWriteStream('output.dat'));\n\n// Get chunk metadata including storage metrics\nconst metadata = await client.getChunkMetadata(chunk.address);\nconsole.log(`Size: ${metadata.size}, Replicas: ${metadata.replicas}`);\n\n// Store multiple chunks efficiently\nconst chunks = await client.storeChunks(dataList);\n</code></pre>"},{"location":"api/nodejs/#pointer-mutable-references","title":"Pointer - Mutable References","text":"<p>Create and manage version-tracked references with real-time updates:</p> <pre><code>import { Pointer, PointerOptions } from 'autonomi';\n\n// Create a pointer with metadata\nconst metadata = {\n    createdAt: new Date(),\n    description: 'Latest application state'\n};\nconst pointer = await client.createPointerWithMetadata(\n    targetAddress,\n    metadata\n);\n\n// Update pointer with version checking\nawait client.updatePointer(pointer.address, newTargetAddress);\n\n// Subscribe to pointer updates\nclient.subscribeToPointer(pointer.address, (update) =&gt; {\n    console.log(`New target: ${update.target}`);\n});\n\n// Get pointer metadata and version history\nconst metadata = await client.getPointerMetadata(pointer.address);\nconsole.log(`Version: ${metadata.version}, Updates: ${metadata.updateCount}`);\n</code></pre>"},{"location":"api/nodejs/#linkedlist-transaction-chains","title":"LinkedList - Transaction Chains","text":"<p>Build decentralized DAG structures with real-time synchronization:</p> <pre><code>import { LinkedList, LinkedListConfig } from 'autonomi';\n\n// Create a new linked list with configuration\nconst config: LinkedListConfig = {\n    forkDetection: true,\n    historyCompression: true,\n    realtime: true\n};\nconst list = await client.createLinkedListWithConfig(config);\n\n// Efficient batch appends\nawait client.appendToListBatch(list.address, items);\n\n// Subscribe to list updates\nclient.subscribeToList(list.address, (update) =&gt; {\n    console.log(`New item: ${update.data}`);\n});\n\n// Advanced fork detection and resolution\nconst forks = await client.detectForksDetailed(list.address);\nif (!forks) {\n    console.log('No forks detected');\n} else {\n    const resolved = await client.resolveForkAutomatically(forks.branches);\n    console.log(`Fork resolved: ${resolved}`);\n}\n</code></pre>"},{"location":"api/nodejs/#scratchpad-temporary-workspace","title":"ScratchPad - Temporary Workspace","text":"<p>Efficient unstructured data storage with real-time updates:</p> <pre><code>import { ScratchPad, ContentType, ScratchPadConfig } from 'autonomi';\n\n// Create a scratchpad with custom configuration\nconst config: ScratchPadConfig = {\n    compression: true,\n    encryption: true,\n    realtime: true\n};\nconst pad = await client.createScratchpadWithConfig(\n    ContentType.UserSettings,\n    config\n);\n\n// Update with JSON data\nconst settings = { theme: 'dark', fontSize: 14 };\nawait client.updateScratchpadJson(pad.address, settings);\n\n// Subscribe to updates\nclient.subscribeToScratchpad(pad.address, (update) =&gt; {\n    console.log(`New data: ${update.data}`);\n});\n</code></pre>"},{"location":"api/nodejs/#file-system-operations","title":"File System Operations","text":"<p>Modern file and directory operations with streaming support:</p> <pre><code>import { File, Directory, FileOptions } from 'autonomi/fs';\n\n// Store a file with custom options\nconst options: FileOptions = {\n    compression: true,\n    encryption: true,\n    redundancy: 3,\n    chunkSize: '1MB'\n};\nconst file = await client.storeFileWithOptions(\n    'example.txt',\n    content,\n    options\n);\n\n// Stream large files\nconst writeStream = await client.createFileWriteStream('large-file.dat');\nsourceStream.pipe(writeStream);\n\n// Create a directory with metadata\nconst dir = await client.createDirectoryWithMetadata(\n    'docs',\n    metadata\n);\n\n// Subscribe to directory changes\nclient.subscribeToDirectory(dir.address, (update) =&gt; {\n    console.log(`Directory updated: ${update.type}`);\n});\n</code></pre>"},{"location":"api/nodejs/#error-handling","title":"Error Handling","text":"<p>Comprehensive error handling with TypeScript support:</p> <pre><code>import {\n    ChunkError,\n    PointerError,\n    ListError,\n    ScratchPadError\n} from 'autonomi/errors';\n\n// Handle chunk operations with detailed errors\ntry {\n    const data = await client.getChunk(address);\n    processData(data);\n} catch (error) {\n    if (error instanceof ChunkError.NotFound) {\n        console.log(`Chunk not found: ${error.address}`);\n        handleMissing();\n    } else if (error instanceof ChunkError.NetworkError) {\n        console.log(`Network error: ${error.message}`);\n        handleNetworkError(error);\n    } else if (error instanceof ChunkError.ValidationError) {\n        console.log(`Validation failed: expected ${error.expected}, got ${error.actual}`);\n        handleValidationError();\n    } else {\n        handleOtherError(error);\n    }\n}\n\n// Handle pointer updates with version conflicts\ntry {\n    await client.updatePointer(address, newTarget);\n    console.log('Update successful');\n} catch (error) {\n    if (error instanceof PointerError.VersionConflict) {\n        console.log(`Version conflict: current ${error.current}, attempted ${error.attempted}`);\n        handleConflict();\n    } else {\n        handleOtherError(error);\n    }\n}\n</code></pre>"},{"location":"api/nodejs/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/nodejs/#web-integration","title":"Web Integration","text":"<pre><code>import { WebClient, WebClientConfig } from 'autonomi/web';\n\n// Create a web-optimized client\nconst config: WebClientConfig = {\n    webSocket: true,\n    compression: true,\n    cacheSize: '100MB'\n};\nconst client = await WebClient.init(config);\n\n// Subscribe to real-time updates\nclient.subscribe('updates', (update) =&gt; {\n    updateUI(update);\n});\n\n// Handle offline mode\nclient.onOffline(() =&gt; {\n    enableOfflineMode();\n});\n\n// Sync when back online\nclient.onOnline(async () =&gt; {\n    await client.sync();\n});\n</code></pre>"},{"location":"api/nodejs/#custom-types-with-typescript","title":"Custom Types with TypeScript","text":"<p>You can define custom types using TypeScript interfaces:</p> <pre><code>interface UserProfile {\n  name: string;\n  age: number;\n  preferences: {\n    theme: 'light' | 'dark';\n    notifications: boolean;\n  };\n}\n\n// Use the type with Autonomi\nconst profile: UserProfile = {\n  name: \"Alice\",\n  age: 30,\n  preferences: {\n    theme: \"light\",\n    notifications: true\n  }\n};\n\nawait client.store(profile);\n</code></pre>"},{"location":"api/nodejs/#quantum-secure-encryption","title":"Quantum-Secure Encryption","text":"<pre><code>import {\n    encryptQuantumSecure,\n    decryptQuantumSecure,\n    generateKey\n} from 'autonomi/crypto';\n\n// Generate quantum-secure keys\nconst key = await generateQuantumSecureKey();\n\n// Encrypt data with quantum security\nconst encrypted = await encryptQuantumSecure(data, key);\nconst pad = await client.createScratchpad(ContentType.Encrypted);\nawait client.updateScratchpad(pad.address, encrypted);\n\n// Decrypt with quantum security\nconst encrypted = await client.getScratchpad(pad.address);\nconst decrypted = await decryptQuantumSecure(encrypted, key);\n</code></pre>"},{"location":"api/nodejs/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/nodejs/#connection-pooling","title":"Connection Pooling","text":"<pre><code>import { Pool, PoolConfig } from 'autonomi/pool';\n\n// Create a connection pool\nconst pool = new Pool({\n    minConnections: 5,\n    maxConnections: 20,\n    idleTimeout: 30000\n});\n\n// Get a client from the pool\nconst client = await pool.get();\ntry {\n    await processData(client);\n} finally {\n    await pool.release(client);\n}\n</code></pre>"},{"location":"api/nodejs/#batch-operations","title":"Batch Operations","text":"<pre><code>// Batch chunk storage\nconst chunks = await client.storeChunksBatch(dataList);\n\n// Batch pointer updates\nconst updates = [\n    new PointerUpdate(addr1, target1),\n    new PointerUpdate(addr2, target2)\n];\nawait client.updatePointersBatch(updates);\n</code></pre>"},{"location":"api/nodejs/#best-practices","title":"Best Practices","text":"<ol> <li>Web Integration</li> <li>Use WebSocket for real-time updates</li> <li>Implement offline support</li> <li>Handle connection state</li> <li> <p>Cache frequently accessed data</p> </li> <li> <p>Error Handling</p> </li> <li>Use TypeScript for type safety</li> <li>Implement retry logic</li> <li>Handle version conflicts</li> <li> <p>Validate data integrity</p> </li> <li> <p>Security</p> </li> <li>Enable quantum security</li> <li>Use encryption for sensitive data</li> <li>Implement access control</li> <li> <p>Validate all inputs</p> </li> <li> <p>Resource Management</p> </li> <li>Use connection pools</li> <li>Clean up resources</li> <li>Monitor memory usage</li> <li>Handle backpressure</li> </ol>"},{"location":"api/nodejs/#typescript-types","title":"TypeScript Types","text":"<p>The API is fully typed for better IDE support and code quality:</p> <pre><code>import { Address, Data, Metadata } from 'autonomi/types';\n\ninterface Client {\n    storeChunk(data: Buffer): Promise&lt;Address&gt;;\n    getChunk(address: Address): Promise&lt;Buffer&gt;;\n    createPointer(target: Address): Promise&lt;Pointer&gt;;\n    updatePointer(address: Address, target: Address): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/nodejs/#further-reading","title":"Further Reading","text":"<ul> <li>Web Development Guide</li> <li>Quantum Security Guide</li> <li>Error Handling Guide</li> <li>API Reference</li> <li>Examples Repository</li> </ul>"},{"location":"api/python/","title":"Python API Documentation","text":"<p>The Python implementation of Autonomi provides a flexible and intuitive interface for data science and general-purpose development. It's ideal for:</p> <ul> <li>Data analysis and machine learning applications</li> <li>Web applications and APIs</li> <li>Research and prototyping</li> <li>Integration with existing Python ecosystems</li> </ul>"},{"location":"api/python/#installation","title":"Installation","text":"<pre><code># Install with pip\npip install autonomi\n\n# Or with specific features\npip install autonomi[quantum-secure,compression]\n\n# For data science applications\npip install autonomi[data-science]\n</code></pre>"},{"location":"api/python/#client-initialization","title":"Client Initialization","text":"<p>The client provides flexible initialization options to match your security and performance needs:</p> <pre><code>from autonomi import Client\n\n# Initialize a read-only client for browsing\nclient = Client.init_read_only()\n\n# Initialize with write capabilities and custom configuration\nconfig = {\n    'quantum_security': True,\n    'compression': True,\n    'cache_size': '1GB'\n}\nclient = Client.init_with_wallet_and_config(wallet, config)\n\n# Upgrade a read-only client to read-write\nclient.upgrade_to_read_write(wallet)\n</code></pre>"},{"location":"api/python/#core-data-types","title":"Core Data Types","text":""},{"location":"api/python/#chunk-quantum-secure-storage","title":"Chunk - Quantum-Secure Storage","text":"<p>Store and retrieve immutable, quantum-secure encrypted data with maximum efficiency:</p> <pre><code>from autonomi import Chunk\nimport numpy as np\n\n# Store raw data as a chunk with optional compression\ndata = b\"Hello, World!\"\nchunk = client.store_chunk(data)\n\n# Store numpy array as compressed chunk\narray_data = np.random.randn(1000, 1000)\nchunk = client.store_chunk_compressed(array_data.tobytes())\n\n# Retrieve chunk data with automatic decompression\nretrieved = client.get_chunk(chunk.address)\nassert data == retrieved\n\n# Get chunk metadata including storage metrics\nmetadata = client.get_chunk_metadata(chunk.address)\nprint(f\"Size: {metadata.size}, Replicas: {metadata.replicas}\")\n\n# Store multiple chunks efficiently\nchunks = client.store_chunks(data_list)\n</code></pre>"},{"location":"api/python/#pointer-mutable-references","title":"Pointer - Mutable References","text":"<p>Create and manage version-tracked references with atomic updates:</p> <pre><code>from autonomi import Pointer\nfrom datetime import datetime\n\n# Create a pointer with custom metadata\nmetadata = {\n    'created_at': datetime.utcnow(),\n    'description': 'Latest model weights'\n}\npointer = client.create_pointer_with_metadata(\n    target_address,\n    metadata\n)\n\n# Atomic pointer updates with version checking\nclient.update_pointer(pointer.address, new_target_address)\n\n# Resolve pointer with caching\ntarget = client.resolve_pointer_cached(pointer.address)\n\n# Get pointer metadata and version history\nmetadata = client.get_pointer_metadata(pointer.address)\nprint(f\"Version: {metadata.version}, Updates: {metadata.update_count}\")\n</code></pre>"},{"location":"api/python/#linkedlist-transaction-chains","title":"LinkedList - Transaction Chains","text":"<p>Build high-performance decentralized DAG structures:</p> <pre><code>from autonomi import LinkedList\nimport pandas as pd\n\n# Create a new linked list with configuration\nconfig = {\n    'fork_detection': True,\n    'history_compression': True\n}\nlist = client.create_linked_list_with_config(config)\n\n# Efficient batch appends\nclient.append_to_list_batch(list.address, items)\n\n# Stream list contents with generator\nfor item in client.stream_list(list.address):\n    process_item(item)\n\n# Stream as pandas DataFrame for data analysis\nfor chunk in client.stream_list_as_dataframe(list.address):\n    process_dataframe(chunk)\n\n# Advanced fork detection and resolution\nforks = client.detect_forks_detailed(list.address)\nif not forks:\n    print(\"No forks detected\")\nelse:\n    resolved = client.resolve_fork_automatically(forks.branches)\n    print(f\"Fork resolved: {resolved}\")\n</code></pre>"},{"location":"api/python/#scratchpad-temporary-workspace","title":"ScratchPad - Temporary Workspace","text":"<p>Efficient unstructured data storage with CRDT properties:</p> <pre><code>from autonomi import ScratchPad, ContentType\n\n# Create a scratchpad with custom configuration\nconfig = {\n    'compression': True,\n    'encryption': True\n}\npad = client.create_scratchpad_with_config(\n    ContentType.USER_SETTINGS,\n    config\n)\n\n# Batch updates for efficiency\nupdates = [\n    ('key1', value1),\n    ('key2', value2)\n]\nclient.update_scratchpad_batch(pad.address, updates)\n\n# Store pandas DataFrame\ndf = pd.DataFrame({'A': range(1000), 'B': range(1000)})\nclient.update_scratchpad_dataframe(pad.address, df)\n\n# Stream updates with generator\nfor update in client.stream_scratchpad_updates(pad.address):\n    process_update(update)\n</code></pre>"},{"location":"api/python/#file-system-operations","title":"File System Operations","text":"<p>High-performance file and directory operations:</p> <pre><code>from autonomi.fs import File, Directory, FileOptions\nimport pandas as pd\n\n# Store a file with custom options\noptions = FileOptions(\n    compression=True,\n    encryption=True,\n    redundancy=3\n)\nfile = client.store_file_with_options(\n    \"example.txt\",\n    content,\n    options\n)\n\n# Store pandas DataFrame as CSV\ndf = pd.DataFrame({'A': range(1000), 'B': range(1000)})\nfile = client.store_dataframe(df, \"data.csv\")\n\n# Create a directory with custom metadata\ndir = client.create_directory_with_metadata(\n    \"docs\",\n    metadata\n)\n\n# Efficient recursive operations\nclient.add_to_directory_recursive(dir.address, file.address)\n\n# Stream directory entries\nfor entry in client.stream_directory(dir.address):\n    if entry.is_file:\n        print(f\"File: {entry.name}\")\n    else:\n        print(f\"Dir: {entry.name}\")\n</code></pre>"},{"location":"api/python/#error-handling","title":"Error Handling","text":"<p>Comprehensive error handling with detailed exceptions:</p> <pre><code>from autonomi.errors import ChunkError, PointerError, ListError, ScratchPadError\n\n# Handle chunk operations with detailed errors\ntry:\n    data = client.get_chunk(address)\n    process_data(data)\nexcept ChunkError.NotFound as e:\n    print(f\"Chunk not found: {e.address}\")\n    handle_missing()\nexcept ChunkError.NetworkError as e:\n    print(f\"Network error: {e}\")\n    handle_network_error(e)\nexcept ChunkError.ValidationError as e:\n    print(f\"Validation failed: expected {e.expected}, got {e.actual}\")\n    handle_validation_error()\nexcept Exception as e:\n    handle_other_error(e)\n\n# Handle pointer updates with version conflicts\ntry:\n    client.update_pointer(address, new_target)\n    print(\"Update successful\")\nexcept PointerError.VersionConflict as e:\n    print(f\"Version conflict: current {e.current}, attempted {e.attempted}\")\n    handle_conflict()\nexcept Exception as e:\n    handle_other_error(e)\n</code></pre>"},{"location":"api/python/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/python/#data-science-integration","title":"Data Science Integration","text":"<pre><code>import pandas as pd\nimport numpy as np\nfrom autonomi.data import DataFrameStore\n\n# Create a data store for efficient DataFrame operations\nstore = DataFrameStore(client)\n\n# Store DataFrame with automatic optimization\nstore.put(\"dataset\", df, optimize=True)\n\n# Retrieve with lazy loading for large datasets\nretrieved_df = store.get(\"dataset\", lazy=True)\n\n# Perform operations on stored DataFrames\nresult = store.apply(\"dataset\", lambda df: df.groupby('column').mean())\n\n# Stream large datasets in chunks\nfor chunk in store.stream(\"dataset\", chunk_size=10000):\n    process_chunk(chunk)\n</code></pre>"},{"location":"api/python/#custom-types-with-pydantic","title":"Custom Types with Pydantic","text":"<pre><code>from pydantic import BaseModel\nfrom datetime import datetime\n\nclass UserProfile(BaseModel):\n    name: str\n    age: int\n    preferences: dict\n    created_at: datetime = datetime.utcnow()\n\n# Use the model with Autonomi\nprofile = UserProfile(\n    name=\"Alice\",\n    age=30,\n    preferences={\n        \"theme\": \"light\",\n        \"notifications\": True\n    }\n)\n\n# Store with validation\npad = client.create_scratchpad(ContentType.Custom(\"UserProfile\"))\nclient.update_scratchpad_validated(pad.address, profile.dict())\n</code></pre>"},{"location":"api/python/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/python/#connection-pooling","title":"Connection Pooling","text":"<pre><code>from autonomi.pool import Pool\n\n# Create a connection pool\npool = Pool(\n    min_connections=5,\n    max_connections=20,\n    idle_timeout=30\n)\n\n# Get a client from the pool\nwith pool.get() as client:\n    process_data(client)\n</code></pre>"},{"location":"api/python/#batch-operations","title":"Batch Operations","text":"<pre><code># Batch chunk storage\nchunks = client.store_chunks_batch(data_list)\n\n# Batch pointer updates\nupdates = [\n    PointerUpdate(addr1, target1),\n    PointerUpdate(addr2, target2)\n]\nclient.update_pointers_batch(updates)\n</code></pre>"},{"location":"api/python/#best-practices","title":"Best Practices","text":"<ol> <li>Data Science Integration</li> <li>Use pandas integration for DataFrames</li> <li>Leverage numpy array support</li> <li>Stream large datasets</li> <li> <p>Use compression for numerical data</p> </li> <li> <p>Error Handling</p> </li> <li>Use detailed exception types</li> <li>Implement retry logic</li> <li>Handle version conflicts</li> <li> <p>Validate data integrity</p> </li> <li> <p>Security</p> </li> <li>Enable quantum security</li> <li>Use encryption for sensitive data</li> <li>Implement access control</li> <li> <p>Validate all inputs</p> </li> <li> <p>Resource Management</p> </li> <li>Use connection pools</li> <li>Clean up resources</li> <li>Monitor memory usage</li> <li>Handle backpressure</li> </ol>"},{"location":"api/python/#type-hints","title":"Type Hints","text":"<p>The Python API uses type hints throughout for better IDE support and code quality:</p> <pre><code>from typing import List, Optional, Union\nfrom autonomi.types import Address, Data, Metadata\n\ndef store_chunk(self, data: bytes) -&gt; Address: ...\ndef get_chunk(self, address: Address) -&gt; bytes: ...\ndef create_pointer(self, target: Address) -&gt; Pointer: ...\ndef update_pointer(self, address: Address, target: Address) -&gt; None: ...\n</code></pre>"},{"location":"api/python/#further-reading","title":"Further Reading","text":"<ul> <li>Data Science Guide</li> <li>Quantum Security Guide</li> <li>Error Handling Guide</li> <li>API Reference</li> <li>Examples Repository</li> </ul>"},{"location":"api/rust/","title":"Rust API Documentation","text":"<p>The Rust implementation of Autonomi provides maximum performance and systems-level control. It's ideal for:</p> <ul> <li>Building high-performance applications</li> <li>Implementing custom storage solutions</li> <li>Developing network nodes</li> <li>Creating secure, native applications</li> </ul>"},{"location":"api/rust/#installation","title":"Installation","text":"<p>Add Autonomi to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nautonomi = \"0.1.0\"\n</code></pre> <p>Or with specific features:</p> <pre><code>[dependencies]\nautonomi = { version = \"0.1.0\", features = [\"quantum-secure\", \"compression\"] }\n</code></pre>"},{"location":"api/rust/#client-initialization","title":"Client Initialization","text":"<p>The client provides flexible initialization options to match your security and performance needs:</p> <pre><code>use autonomi::Client;\n\n// Initialize a read-only client for browsing\nlet client = Client::init_read_only().await?;\n\n// Initialize with write capabilities and custom configuration\nlet config = ClientConfig::builder()\n    .with_quantum_security(true)\n    .with_compression(true)\n    .build();\nlet client = Client::init_with_wallet_and_config(wallet, config).await?;\n\n// Upgrade a read-only client to read-write\nclient.upgrade_to_read_write(wallet)?;\n</code></pre>"},{"location":"api/rust/#core-data-types","title":"Core Data Types","text":""},{"location":"api/rust/#chunk-quantum-secure-storage","title":"Chunk - Quantum-Secure Storage","text":"<p>Store and retrieve immutable, quantum-secure encrypted data with maximum efficiency:</p> <pre><code>use autonomi::Chunk;\n\n// Store raw data as a chunk with optional compression\nlet data = b\"Hello, World!\";\nlet chunk = client.store_chunk(data).await?;\n\n// Retrieve chunk data with automatic decompression\nlet retrieved = client.get_chunk(chunk.address()).await?;\nassert_eq!(data, &amp;retrieved[..]);\n\n// Get chunk metadata including storage metrics\nlet metadata = client.get_chunk_metadata(chunk.address()).await?;\nprintln!(\"Size: {}, Replicas: {}\", metadata.size, metadata.replicas);\n\n// Store multiple chunks efficiently\nlet chunks = client.store_chunks(data_vec).await?;\n</code></pre>"},{"location":"api/rust/#pointer-mutable-references","title":"Pointer - Mutable References","text":"<p>Create and manage version-tracked references with atomic updates:</p> <pre><code>use autonomi::Pointer;\n\n// Create a pointer with custom metadata\nlet pointer = client.create_pointer_with_metadata(\n    target_address,\n    metadata,\n).await?;\n\n// Atomic pointer updates with version checking\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer with caching\nlet target = client.resolve_pointer_cached(pointer.address()).await?;\n\n// Get pointer metadata and version history\nlet metadata = client.get_pointer_metadata(pointer.address()).await?;\nprintln!(\"Version: {}, Updates: {}\", metadata.version, metadata.update_count);\n</code></pre>"},{"location":"api/rust/#linkedlist-transaction-chains","title":"LinkedList - Transaction Chains","text":"<p>Build high-performance decentralized DAG structures:</p> <pre><code>use autonomi::LinkedList;\n\n// Create a new linked list with configuration\nlet config = LinkedListConfig::new()\n    .with_fork_detection(true)\n    .with_history_compression(true);\nlet list = client.create_linked_list_with_config(config).await?;\n\n// Efficient batch appends\nclient.append_to_list_batch(list.address(), items).await?;\n\n// Stream list contents with async iterator\nlet mut items = client.stream_list(list.address());\nwhile let Some(item) = items.next().await {\n    process_item(item?);\n}\n\n// Advanced fork detection and resolution\nmatch client.detect_forks_detailed(list.address()).await? {\n    Fork::None =&gt; println!(\"No forks detected\"),\n    Fork::Detected(branches) =&gt; {\n        let resolved = client.resolve_fork_automatically(branches).await?;\n        println!(\"Fork resolved: {:?}\", resolved);\n    }\n}\n</code></pre>"},{"location":"api/rust/#scratchpad-temporary-workspace","title":"ScratchPad - Temporary Workspace","text":"<p>Efficient unstructured data storage with CRDT properties:</p> <pre><code>use autonomi::{ScratchPad, ContentType};\n\n// Create a scratchpad with custom configuration\nlet config = ScratchpadConfig::new()\n    .with_compression(true)\n    .with_encryption(true);\nlet pad = client.create_scratchpad_with_config(\n    ContentType::UserSettings,\n    config,\n).await?;\n\n// Batch updates for efficiency\nlet updates = vec![Update::new(key1, value1), Update::new(key2, value2)];\nclient.update_scratchpad_batch(pad.address(), updates).await?;\n\n// Stream updates with async iterator\nlet mut updates = client.stream_scratchpad_updates(pad.address());\nwhile let Some(update) = updates.next().await {\n    process_update(update?);\n}\n</code></pre>"},{"location":"api/rust/#file-system-operations","title":"File System Operations","text":"<p>High-performance file and directory operations:</p> <pre><code>use autonomi::fs::{File, Directory, FileOptions};\n\n// Store a file with custom options\nlet options = FileOptions::new()\n    .with_compression(true)\n    .with_encryption(true)\n    .with_redundancy(3);\nlet file = client.store_file_with_options(\n    \"example.txt\",\n    content,\n    options,\n).await?;\n\n// Create a directory with custom metadata\nlet dir = client.create_directory_with_metadata(\n    \"docs\",\n    metadata,\n).await?;\n\n// Efficient recursive operations\nclient.add_to_directory_recursive(dir.address(), file.address()).await?;\n\n// Stream directory entries\nlet mut entries = client.stream_directory(dir.address());\nwhile let Some(entry) = entries.next().await {\n    match entry? {\n        DirEntry::File(f) =&gt; println!(\"File: {}\", f.name),\n        DirEntry::Directory(d) =&gt; println!(\"Dir: {}\", d.name),\n    }\n}\n</code></pre>"},{"location":"api/rust/#error-handling","title":"Error Handling","text":"<p>Comprehensive error handling with detailed error types:</p> <pre><code>use autonomi::error::{ChunkError, PointerError, ListError, ScratchPadError};\n\n// Handle chunk operations with detailed errors\nmatch client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound { address }) =&gt; {\n        println!(\"Chunk not found: {}\", address);\n        handle_missing()\n    },\n    Err(ChunkError::NetworkError(e)) =&gt; {\n        println!(\"Network error: {}\", e);\n        handle_network_error(e)\n    },\n    Err(ChunkError::ValidationError { expected, actual }) =&gt; {\n        println!(\"Validation failed: expected {}, got {}\", expected, actual);\n        handle_validation_error()\n    },\n    Err(e) =&gt; handle_other_error(e),\n}\n\n// Handle pointer updates with version conflicts\nmatch client.update_pointer(address, new_target).await {\n    Ok(_) =&gt; println!(\"Update successful\"),\n    Err(PointerError::VersionConflict { current, attempted }) =&gt; {\n        println!(\"Version conflict: current {}, attempted {}\", current, attempted);\n        handle_conflict()\n    },\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"api/rust/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/rust/#custom-types-with-serde","title":"Custom Types with Serde","text":"<pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct MyData {\n    field1: String,\n    field2: u64,\n    #[serde(with = \"time::serde::rfc3339\")]\n    timestamp: OffsetDateTime,\n}\n\n// Store custom type with compression\nlet data = MyData {\n    field1: \"test\".into(),\n    field2: 42,\n    timestamp: OffsetDateTime::now_utc(),\n};\nlet pad = client.create_scratchpad(ContentType::Custom(\"MyData\")).await?;\nclient.update_scratchpad_compressed(pad.address(), &amp;data).await?;\n</code></pre>"},{"location":"api/rust/#quantum-secure-encryption","title":"Quantum-Secure Encryption","text":"<pre><code>use autonomi::crypto::{encrypt_quantum_secure, decrypt_quantum_secure};\n\n// Generate quantum-secure keys\nlet key = generate_quantum_secure_key();\n\n// Encrypt data with quantum security\nlet encrypted = encrypt_quantum_secure(data, &amp;key)?;\nlet pad = client.create_scratchpad(ContentType::Encrypted).await?;\nclient.update_scratchpad(pad.address(), &amp;encrypted).await?;\n\n// Decrypt with quantum security\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet decrypted = decrypt_quantum_secure(encrypted, &amp;key)?;\n</code></pre>"},{"location":"api/rust/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/rust/#connection-pooling","title":"Connection Pooling","text":"<pre><code>use autonomi::pool::{Pool, PoolConfig};\n\n// Create a connection pool\nlet pool = Pool::new(PoolConfig {\n    min_connections: 5,\n    max_connections: 20,\n    idle_timeout: Duration::from_secs(30),\n});\n\n// Get a client from the pool\nlet client = pool.get().await?;\n</code></pre>"},{"location":"api/rust/#batch-operations","title":"Batch Operations","text":"<pre><code>// Batch chunk storage\nlet chunks = client.store_chunks_batch(data_vec).await?;\n\n// Batch pointer updates\nlet updates = vec![\n    PointerUpdate::new(addr1, target1),\n    PointerUpdate::new(addr2, target2),\n];\nclient.update_pointers_batch(updates).await?;\n</code></pre>"},{"location":"api/rust/#best-practices","title":"Best Practices","text":"<ol> <li>Performance Optimization</li> <li>Use batch operations for multiple items</li> <li>Enable compression for large data</li> <li>Utilize connection pooling</li> <li> <p>Stream large datasets</p> </li> <li> <p>Error Handling</p> </li> <li>Use detailed error types</li> <li>Implement retry logic</li> <li>Handle version conflicts</li> <li> <p>Validate data integrity</p> </li> <li> <p>Security</p> </li> <li>Enable quantum security</li> <li>Use encryption for sensitive data</li> <li>Implement access control</li> <li> <p>Validate all inputs</p> </li> <li> <p>Resource Management</p> </li> <li>Use connection pools</li> <li>Clean up resources</li> <li>Monitor memory usage</li> <li>Handle backpressure</li> </ol>"},{"location":"api/rust/#further-reading","title":"Further Reading","text":"<ul> <li>Rust Performance Guide</li> <li>Quantum Security Guide</li> <li>Error Handling Guide</li> <li>API Reference</li> <li>Examples Repository</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide will help you install the Autonomi client for your preferred programming language.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 16+ (for Node.js client)</li> <li>Python 3.8+ (for Python client)</li> <li>Rust toolchain (for Rust client)</li> <li>Docker (for local network)</li> </ul>"},{"location":"getting-started/installation/#nodejs-installation","title":"Node.js Installation","text":"<pre><code># Using npm\nnpm install @autonomi/client\n\n# Using yarn\nyarn add @autonomi/client\n\n# Using pnpm\npnpm add @autonomi/client\n</code></pre>"},{"location":"getting-started/installation/#typescript-configuration","title":"TypeScript Configuration","text":"<p>Add these settings to your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n</code></pre>"},{"location":"getting-started/installation/#python-installation","title":"Python Installation","text":"<pre><code># Using pip\npip install autonomi-client\n\n# Using poetry\npoetry add autonomi-client\n</code></pre>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (recommended)","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\nsource venv/bin/activate  # Unix\n.\\venv\\Scripts\\activate   # Windows\n\n# Install package\npip install autonomi-client\n</code></pre>"},{"location":"getting-started/installation/#rust-installation","title":"Rust Installation","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nautonomi = \"0.1.0\"\n</code></pre> <p>Or using cargo-edit:</p> <pre><code>cargo add autonomi\n</code></pre>"},{"location":"getting-started/installation/#docker-setup-for-local-network","title":"Docker Setup (for Local Network)","text":"<ol> <li>Install Docker:</li> <li>Docker Desktop for Mac</li> <li>Docker Desktop for Windows</li> <li> <p>Docker Engine for Linux</p> </li> <li> <p>Pull the Autonomi image:</p> </li> </ol> <pre><code>docker pull autonomi/node:latest\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"getting-started/installation/#nodejs","title":"Node.js","text":"<pre><code>import { Client } from '@autonomi/client';\n\nasync function verify() {\n    const client = new Client();\n    await client.connect();\n    console.log('Connected successfully!');\n}\n\nverify().catch(console.error);\n</code></pre>"},{"location":"getting-started/installation/#python","title":"Python","text":"<pre><code>import asyncio\nfrom autonomi import Client\n\nasync def verify():\n    client = Client()\n    await client.connect()\n    print('Connected successfully!')\n\nasyncio.run(verify())\n</code></pre>"},{"location":"getting-started/installation/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = Client::new()?;\n    println!(\"Connected successfully!\");\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Local Network Setup</li> <li>API Reference</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Autonomi quickly. We'll create a simple application that stores and retrieves data using linked lists.</p>"},{"location":"getting-started/quickstart/#choose-your-language","title":"Choose Your Language","text":"Node.jsPythonRust <pre><code>import { Client, LinkedList } from '@autonomi/client';\n\nasync function main() {\n    // Initialize client\n    const client = new Client();\n    await client.connect();\n\n    // Create a linked list\n    const list = new LinkedList();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    const address = await client.linkedListPut(list);\n    console.log(`List stored at: ${address}`);\n\n    // Retrieve the list\n    const retrieved = await client.linkedListGet(address);\n    console.log(retrieved.toString()); // \"Hello World\"\n}\n\nmain().catch(console.error);\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, LinkedList\n\nasync def main():\n    # Initialize client\n    client = Client()\n    await client.connect()\n\n    # Create a linked list\n    list_obj = LinkedList()\n    list_obj.append(\"Hello\")\n    list_obj.append(\"World\")\n\n    # Store the list\n    address = await client.linked_list_put(list_obj)\n    print(f\"List stored at: {address}\")\n\n    # Retrieve the list\n    retrieved = await client.linked_list_get(address)\n    print(str(retrieved))  # \"Hello World\"\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, LinkedList, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Initialize client\n    let client = Client::new()?;\n\n    // Create a linked list\n    let mut list = LinkedList::new();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    let address = client.linked_list_put(&amp;list)?;\n    println!(\"List stored at: {}\", address);\n\n    // Retrieve the list\n    let retrieved = client.linked_list_get(&amp;address)?;\n    println!(\"{}\", retrieved);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-pointers","title":"Working with Pointers","text":"<p>Pointers allow you to create references to data in the network:</p> Node.jsPythonRust <pre><code>import { Client, Pointer } from '@autonomi/client';\n\nasync function main() {\n    const client = new Client();\n    await client.connect();\n\n    // Create a pointer\n    const pointer = new Pointer();\n    pointer.setTarget(\"example-target\");\n\n    // Store the pointer\n    const address = await client.pointerPut(pointer);\n    console.log(`Pointer stored at: ${address}`);\n\n    // Retrieve the pointer\n    const retrieved = await client.pointerGet(address);\n    console.log(`Target: ${retrieved.getTarget()}`);\n}\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, Pointer\n\nasync def main():\n    client = Client()\n    await client.connect()\n\n    # Create a pointer\n    pointer = Pointer()\n    pointer.set_target(\"example-target\")\n\n    # Store the pointer\n    address = await client.pointer_put(pointer)\n    print(f\"Pointer stored at: {address}\")\n\n    # Retrieve the pointer\n    retrieved = await client.pointer_get(address)\n    print(f\"Target: {retrieved.get_target()}\")\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, Pointer, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Create a pointer\n    let mut pointer = Pointer::new();\n    pointer.set_target(\"example-target\");\n\n    // Store the pointer\n    let address = client.pointer_put(&amp;pointer)?;\n    println!(\"Pointer stored at: {}\", address);\n\n    // Retrieve the pointer\n    let retrieved = client.pointer_get(&amp;address)?;\n    println!(\"Target: {}\", retrieved.target());\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Local Network Setup</li> <li>EVM Integration</li> <li>Testing Guide</li> <li>API Reference</li> </ul>"},{"location":"guides/client_modes/","title":"Client Modes Guide","text":"<p>This guide explains how to use Autonomi's client modes to browse the network (read-only) and optionally upgrade to write capabilities.</p>"},{"location":"guides/client_modes/#overview","title":"Overview","text":"<p>Autonomi clients can operate in two modes:</p> <ol> <li>Read-Only Mode: Browse and read data from the network without requiring a wallet</li> <li>Read-Write Mode: Full access to both read and write operations, requires a wallet</li> </ol>"},{"location":"guides/client_modes/#read-only-client","title":"Read-Only Client","text":"<p>A read-only client allows you to browse and read data from the network without needing a wallet or making payments.</p>"},{"location":"guides/client_modes/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::init_read_only().await?;\n\n// Verify it's read-only\nassert!(!client.can_write());\nassert!(client.wallet().is_none());\n\n// Read operations work normally\nlet data = client.get_bytes(address).await?;\nlet file = client.get_file(file_map, \"output.txt\").await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Initialize a read-only client\nconst client = await Client.connect({\n    readOnly: true,\n    peers: ['/ip4/127.0.0.1/tcp/12000']\n});\n\n// Read operations\nconst data = await client.dataGetPublic(address);\nconst list = await client.linkedListGet(listAddress);\n</code></pre>"},{"location":"guides/client_modes/#python","title":"Python","text":"<pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.new()\n\n# Read operations\ndata = client.get_bytes(\"safe://example_address\")\nfile = client.get_file(file_map, \"output.txt\")\n</code></pre>"},{"location":"guides/client_modes/#upgrading-to-read-write-mode","title":"Upgrading to Read-Write Mode","text":"<p>You can upgrade a read-only client to read-write mode by adding a wallet. This enables write operations like storing data or updating linked lists.</p>"},{"location":"guides/client_modes/#rust_1","title":"Rust","text":"<pre><code>use autonomi::{Client, EvmWallet};\n\n// Start with a read-only client\nlet mut client = Client::init_read_only().await?;\n\n// Get a wallet (e.g., from a private key or create new)\nlet wallet = EvmWallet::from_private_key(private_key)?;\n\n// Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)?;\n\n// Now write operations are available\nlet address = client.store_bytes(data).await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript_1","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Start with a read-only client\nconst client = await Client.connect({\n    readOnly: true\n});\n\n// Upgrade with a wallet\nawait client.upgradeToReadWrite({\n    type: 'wallet',\n    wallet: 'your_wallet_address'\n});\n\n// Now you can perform write operations\nconst address = await client.dataPutPublic(\n    Buffer.from('Hello World'),\n    { type: 'wallet', wallet: client.wallet }\n);\n</code></pre>"},{"location":"guides/client_modes/#python_1","title":"Python","text":"<pre><code>from autonomi import Client, Wallet\n\n# Start with a read-only client\nclient = Client.new()\n\n# Create or import a wallet\nwallet = Wallet.from_private_key(\"your_private_key\")\n\n# Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)\n\n# Now write operations are available\naddress = client.store_bytes(b\"Hello World\")\n</code></pre>"},{"location":"guides/client_modes/#write-operations","title":"Write Operations","text":"<p>The following operations require a wallet (read-write mode):</p> <ul> <li>Storing public data (<code>dataPutPublic</code>)</li> <li>Creating/updating linked lists (<code>linkedListPut</code>)</li> <li>Setting pointers (<code>pointerPut</code>)</li> <li>Writing to vaults (<code>writeBytesToVault</code>)</li> <li>Updating user data (<code>putUserDataToVault</code>)</li> </ul> <p>Attempting these operations in read-only mode will result in an error.</p>"},{"location":"guides/client_modes/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start Read-Only: Begin with a read-only client if you only need to read data. This is simpler and more secure since no wallet is needed.</p> </li> <li> <p>Lazy Wallet Loading: Only upgrade to read-write mode when you actually need to perform write operations.</p> </li> <li> <p>Error Handling: Always handle potential errors when upgrading modes or performing write operations:</p> </li> </ol> <pre><code>try {\n    await client.upgradeToReadWrite(wallet);\n    await client.dataPutPublic(data, payment);\n} catch (error) {\n    if (error.code === 'NO_WALLET') {\n        console.error('Write operation attempted without wallet');\n    } else if (error.code === 'ALREADY_READ_WRITE') {\n        console.error('Client is already in read-write mode');\n    }\n}\n</code></pre> <ol> <li>Check Capabilities: Use the provided methods to check client capabilities:</li> </ol> <pre><code>if client.can_write() {\n    // Perform write operation\n} else {\n    // Handle read-only state\n}\n</code></pre>"},{"location":"guides/client_modes/#common-issues","title":"Common Issues","text":"<ol> <li>Attempting Write Operations in Read-Only Mode</li> <li>Error: <code>NO_WALLET</code> or <code>WriteAccessRequired</code></li> <li> <p>Solution: Upgrade to read-write mode by adding a wallet</p> </li> <li> <p>Multiple Upgrade Attempts</p> </li> <li>Error: <code>ALREADY_READ_WRITE</code></li> <li> <p>Solution: Check client mode before attempting upgrade</p> </li> <li> <p>Invalid Wallet</p> </li> <li>Error: <code>InvalidWallet</code> or <code>WalletError</code></li> <li>Solution: Ensure wallet is properly initialized with valid credentials</li> </ol>"},{"location":"guides/data_science/","title":"Data Science with Autonomi","text":"<p>This guide covers how to use Autonomi for data science applications, including data storage, processing, and analysis.</p>"},{"location":"guides/data_science/#overview","title":"Overview","text":"<p>Autonomi provides a secure and decentralized platform for data science applications. This guide demonstrates how to leverage Autonomi's features for data storage, processing, and analysis while maintaining data security and privacy.</p>"},{"location":"guides/data_science/#getting-started","title":"Getting Started","text":""},{"location":"guides/data_science/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>Autonomi Python client</li> <li>Common data science libraries (numpy, pandas, scikit-learn)</li> </ul>"},{"location":"guides/data_science/#installation","title":"Installation","text":"<pre><code>pip install autonomi-client\npip install numpy pandas scikit-learn\n</code></pre>"},{"location":"guides/data_science/#data-storage","title":"Data Storage","text":""},{"location":"guides/data_science/#storing-datasets","title":"Storing Datasets","text":"<pre><code>from autonomi import Client\nimport pandas as pd\nfrom typing import Optional\n\nasync def store_dataset(\n    df: pd.DataFrame,\n    name: str,\n    description: Optional[str] = None\n) -&gt; str:\n    client = await Client.init()\n\n    # Convert DataFrame to bytes\n    data = df.to_parquet()\n\n    # Store metadata\n    metadata = {\n        'name': name,\n        'description': description,\n        'columns': list(df.columns),\n        'shape': df.shape,\n        'dtypes': {str(k): str(v) for k, v in df.dtypes.items()}\n    }\n\n    # Store data and metadata\n    data_pointer = await client.store_chunk(data)\n    metadata_pointer = await client.store_scratch_pad(metadata)\n\n    # Link data and metadata\n    dataset = {\n        'data': data_pointer,\n        'metadata': metadata_pointer\n    }\n    return await client.store_pointer(dataset)\n</code></pre>"},{"location":"guides/data_science/#retrieving-datasets","title":"Retrieving Datasets","text":"<pre><code>async def load_dataset(dataset_pointer: str) -&gt; pd.DataFrame:\n    client = await Client.init()\n\n    # Retrieve dataset pointers\n    dataset = await client.retrieve_pointer(dataset_pointer)\n\n    # Load data and metadata\n    data = await client.retrieve_chunk(dataset['data'])\n    metadata = await client.retrieve_scratch_pad(dataset['metadata'])\n\n    # Convert bytes to DataFrame\n    return pd.read_parquet(data)\n</code></pre>"},{"location":"guides/data_science/#data-processing","title":"Data Processing","text":""},{"location":"guides/data_science/#parallel-processing","title":"Parallel Processing","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\nimport numpy as np\n\nasync def process_chunks(\n    data_pointer: str,\n    chunk_size: int = 1000\n) -&gt; np.ndarray:\n    client = await Client.init()\n    data = await client.retrieve_chunk(data_pointer)\n    df = pd.read_parquet(data)\n\n    def process_chunk(chunk):\n        # Your processing logic here\n        return chunk.values\n\n    chunks = [df[i:i+chunk_size] for i in range(0, len(df), chunk_size)]\n\n    with ThreadPoolExecutor() as executor:\n        results = list(executor.map(process_chunk, chunks))\n\n    return np.concatenate(results)\n</code></pre>"},{"location":"guides/data_science/#feature-engineering","title":"Feature Engineering","text":"<pre><code>from sklearn.preprocessing import StandardScaler\nfrom typing import Dict, Any\n\nasync def engineer_features(\n    dataset_pointer: str,\n    feature_config: Dict[str, Any]\n) -&gt; str:\n    client = await Client.init()\n    df = await load_dataset(dataset_pointer)\n\n    # Apply transformations\n    for feature, config in feature_config.items():\n        if config['type'] == 'standardize':\n            scaler = StandardScaler()\n            df[feature] = scaler.fit_transform(df[[feature]])\n        elif config['type'] == 'log':\n            df[feature] = np.log1p(df[feature])\n\n    # Store transformed dataset\n    return await store_dataset(\n        df,\n        name=f\"transformed_{dataset_pointer}\",\n        description=\"Feature engineered dataset\"\n    )\n</code></pre>"},{"location":"guides/data_science/#model-training","title":"Model Training","text":""},{"location":"guides/data_science/#training-pipeline","title":"Training Pipeline","text":"<pre><code>from sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nimport pickle\n\nasync def train_model(\n    dataset_pointer: str,\n    model,\n    test_size: float = 0.2\n) -&gt; str:\n    # Load dataset\n    df = await load_dataset(dataset_pointer)\n\n    # Split features and target\n    X = df.drop('target', axis=1)\n    y = df['target']\n\n    # Split data\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=test_size\n    )\n\n    # Train model\n    model.fit(X_train, y_train)\n\n    # Evaluate\n    y_pred = model.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n\n    # Store model\n    model_bytes = pickle.dumps(model)\n    model_pointer = await client.store_chunk(model_bytes)\n\n    # Store metadata\n    metadata = {\n        'accuracy': accuracy,\n        'test_size': test_size,\n        'feature_names': list(X.columns),\n        'model_type': str(type(model).__name__)\n    }\n    metadata_pointer = await client.store_scratch_pad(metadata)\n\n    # Link model and metadata\n    model_info = {\n        'model': model_pointer,\n        'metadata': metadata_pointer\n    }\n    return await client.store_pointer(model_info)\n</code></pre>"},{"location":"guides/data_science/#model-inference","title":"Model Inference","text":"<pre><code>async def predict(\n    model_pointer: str,\n    data: pd.DataFrame\n) -&gt; np.ndarray:\n    client = await Client.init()\n\n    # Load model info\n    model_info = await client.retrieve_pointer(model_pointer)\n\n    # Load model and metadata\n    model_bytes = await client.retrieve_chunk(model_info['model'])\n    metadata = await client.retrieve_scratch_pad(model_info['metadata'])\n\n    # Deserialize model\n    model = pickle.loads(model_bytes)\n\n    # Validate features\n    expected_features = metadata['feature_names']\n    if not all(f in data.columns for f in expected_features):\n        raise ValueError(\"Missing required features\")\n\n    # Make predictions\n    return model.predict(data[expected_features])\n</code></pre>"},{"location":"guides/data_science/#data-visualization","title":"Data Visualization","text":""},{"location":"guides/data_science/#creating-visualizations","title":"Creating Visualizations","text":"<pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom io import BytesIO\n\nasync def create_visualization(\n    dataset_pointer: str,\n    plot_type: str,\n    **kwargs\n) -&gt; str:\n    client = await Client.init()\n    df = await load_dataset(dataset_pointer)\n\n    # Create figure\n    plt.figure(figsize=(10, 6))\n\n    if plot_type == 'histogram':\n        sns.histplot(data=df, **kwargs)\n    elif plot_type == 'scatter':\n        sns.scatterplot(data=df, **kwargs)\n    elif plot_type == 'box':\n        sns.boxplot(data=df, **kwargs)\n\n    # Save plot to bytes\n    buf = BytesIO()\n    plt.savefig(buf, format='png')\n    buf.seek(0)\n\n    # Store visualization\n    return await client.store_chunk(buf.read())\n</code></pre>"},{"location":"guides/data_science/#security-and-privacy","title":"Security and Privacy","text":""},{"location":"guides/data_science/#data-encryption","title":"Data Encryption","text":"<pre><code>from cryptography.fernet import Fernet\nfrom typing import Tuple\n\nasync def store_encrypted_dataset(\n    df: pd.DataFrame,\n    encryption_key: bytes\n) -&gt; Tuple[str, bytes]:\n    # Generate encryption key if not provided\n    if encryption_key is None:\n        encryption_key = Fernet.generate_key()\n\n    fernet = Fernet(encryption_key)\n\n    # Convert DataFrame to bytes and encrypt\n    data = df.to_parquet()\n    encrypted_data = fernet.encrypt(data)\n\n    # Store encrypted data\n    client = await Client.init()\n    pointer = await client.store_chunk(encrypted_data)\n\n    return pointer, encryption_key\n</code></pre>"},{"location":"guides/data_science/#secure-collaboration","title":"Secure Collaboration","text":"<pre><code>async def share_dataset_access(\n    dataset_pointer: str,\n    collaborator_key: str\n) -&gt; str:\n    client = await Client.init()\n\n    # Create access control entry\n    access = {\n        'dataset': dataset_pointer,\n        'granted_to': collaborator_key,\n        'permissions': ['read', 'process']\n    }\n\n    # Store access control\n    return await client.store_scratch_pad(access)\n</code></pre>"},{"location":"guides/data_science/#best-practices","title":"Best Practices","text":"<ol> <li>Data Management</li> <li>Use appropriate data formats (parquet for tabular data)</li> <li>Implement proper versioning</li> <li> <p>Store metadata with datasets</p> </li> <li> <p>Performance</p> </li> <li>Use chunked processing for large datasets</li> <li>Implement caching for frequently accessed data</li> <li> <p>Optimize data formats and compression</p> </li> <li> <p>Security</p> </li> <li>Encrypt sensitive data</li> <li>Implement access controls</li> <li> <p>Monitor data access patterns</p> </li> <li> <p>Collaboration</p> </li> <li>Document datasets and transformations</li> <li>Share access securely</li> <li>Track data lineage</li> </ol>"},{"location":"guides/data_science/#resources","title":"Resources","text":"<ul> <li>API Reference</li> <li>Error Handling Guide</li> <li>Quantum Security Guide</li> </ul>"},{"location":"guides/data_science/#support","title":"Support","text":"<p>For data science support:</p> <ul> <li>Technical support: support@autonomi.com</li> <li>Documentation: https://docs.autonomi.com/data-science</li> <li>Community forum: https://forum.autonomi.com/data-science</li> </ul>"},{"location":"guides/data_storage/","title":"Data Storage Guide","text":"<p>This guide explains how Autonomi handles data storage, including self-encryption and scratchpad features.</p>"},{"location":"guides/data_storage/#self-encryption","title":"Self-Encryption","text":"<p>Self-encryption is a core feature that provides secure data storage by splitting and encrypting data into chunks.</p>"},{"location":"guides/data_storage/#how-it-works","title":"How It Works","text":"<ol> <li>Data is split into chunks</li> <li>Each chunk is encrypted</li> <li>A data map is created to track the chunks</li> <li>Additional encryption layers are added for larger files</li> </ol>"},{"location":"guides/data_storage/#usage-examples","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nasync function storeEncryptedData(data: Uint8Array) {\n    const client = new Client();\n\n    // Data is automatically self-encrypted when stored\n    const address = await client.data_put_public(data);\n    console.log(`Data stored at: ${address}`);\n\n    // Retrieve and decrypt data\n    const retrieved = await client.data_get_public(address);\n    console.log('Data retrieved successfully');\n}\n</code></pre> <pre><code>from autonomi import Client\n\nasync def store_encrypted_data(data: bytes):\n    client = Client()\n\n    # Data is automatically self-encrypted when stored\n    address = await client.data_put_public(data)\n    print(f\"Data stored at: {address}\")\n\n    # Retrieve and decrypt data\n    retrieved = await client.data_get_public(address)\n    print(\"Data retrieved successfully\")\n</code></pre> <pre><code>use autonomi::{Client, Bytes, Result};\n\nasync fn store_encrypted_data(data: Bytes) -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Data is automatically self-encrypted when stored\n    let address = client.data_put_public(data).await?;\n    println!(\"Data stored at: {}\", address);\n\n    // Retrieve and decrypt data\n    let retrieved = client.data_get_public(&amp;address).await?;\n    println!(\"Data retrieved successfully\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#scratchpad","title":"Scratchpad","text":"<p>Scratchpad provides a mutable storage location for encrypted data with versioning support.</p>"},{"location":"guides/data_storage/#features","title":"Features","text":"<ul> <li>Mutable data storage</li> <li>Version tracking with monotonic counter</li> <li>Owner-based access control</li> <li>Data encryption</li> <li>Signature verification</li> </ul>"},{"location":"guides/data_storage/#usage-examples_1","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client, Scratchpad } from '@autonomi/client';\n\nasync function useScratchpad() {\n    const client = new Client();\n    const secretKey = await client.generate_secret_key();\n\n    // Create or get existing scratchpad\n    const [scratchpad, isNew] = await client.get_or_create_scratchpad(\n        secretKey,\n        42 // content type\n    );\n\n    // Update scratchpad data\n    const data = new TextEncoder().encode('Hello World');\n    await client.update_scratchpad(scratchpad, data, secretKey);\n\n    // Read scratchpad data\n    const retrieved = await client.get_scratchpad(scratchpad.address);\n    const decrypted = await client.decrypt_scratchpad(retrieved, secretKey);\n    console.log(new TextDecoder().decode(decrypted));\n}\n</code></pre> <pre><code>from autonomi import Client, Scratchpad\n\nasync def use_scratchpad():\n    client = Client()\n    secret_key = client.generate_secret_key()\n\n    # Create or get existing scratchpad\n    scratchpad, is_new = await client.get_or_create_scratchpad(\n        secret_key,\n        42  # content type\n    )\n\n    # Update scratchpad data\n    data = b\"Hello World\"\n    await client.update_scratchpad(scratchpad, data, secret_key)\n\n    # Read scratchpad data\n    retrieved = await client.get_scratchpad(scratchpad.address)\n    decrypted = await client.decrypt_scratchpad(retrieved, secret_key)\n    print(decrypted.decode())\n</code></pre> <pre><code>use autonomi::{Client, Scratchpad, SecretKey, Bytes, Result};\n\nasync fn use_scratchpad() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n    let secret_key = SecretKey::random();\n\n    // Create or get existing scratchpad\n    let (mut scratchpad, is_new) = client\n        .get_or_create_scratchpad(&amp;secret_key, 42)\n        .await?;\n\n    // Update scratchpad data\n    let data = Bytes::from(\"Hello World\");\n    scratchpad.update_and_sign(data, &amp;secret_key);\n\n    // Store updated scratchpad\n    client.put_scratchpad(&amp;scratchpad).await?;\n\n    // Read scratchpad data\n    let retrieved = client.get_scratchpad(scratchpad.address()).await?;\n    let decrypted = retrieved.decrypt_data(&amp;secret_key)?;\n    println!(\"Data: {}\", String::from_utf8_lossy(&amp;decrypted));\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#best-practices","title":"Best Practices","text":"<ol> <li>Version Management</li> <li>Always check the counter before updates</li> <li>Handle version conflicts appropriately</li> <li> <p>Use monotonic counters for ordering</p> </li> <li> <p>Security</p> </li> <li>Keep secret keys secure</li> <li>Verify signatures before trusting data</li> <li> <p>Always encrypt sensitive data</p> </li> <li> <p>Error Handling</p> </li> <li>Handle decryption failures gracefully</li> <li>Implement proper retry logic for network operations</li> <li> <p>Validate data before storage</p> </li> <li> <p>Performance</p> </li> <li>Cache frequently accessed data</li> <li>Batch updates when possible</li> <li>Monitor storage size</li> </ol>"},{"location":"guides/data_storage/#implementation-details","title":"Implementation Details","text":""},{"location":"guides/data_storage/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data Splitting</li> </ol> <pre><code>// Internal process when storing data\nlet (data_map, chunks) = self_encryption::encrypt(data)?;\nlet (data_map_chunk, additional_chunks) = pack_data_map(data_map)?;\n</code></pre> <ol> <li>Chunk Management</li> <li>Each chunk is stored separately</li> <li>Chunks are encrypted individually</li> <li>Data maps track chunk locations</li> </ol>"},{"location":"guides/data_storage/#scratchpad-structure","title":"Scratchpad Structure","text":"<pre><code>pub struct Scratchpad {\n    // Network address\n    address: ScratchpadAddress,\n    // Data type identifier\n    data_encoding: u64,\n    // Encrypted content\n    encrypted_data: Bytes,\n    // Version counter\n    counter: u64,\n    // Owner's signature\n    signature: Option&lt;Signature&gt;,\n}\n</code></pre>"},{"location":"guides/data_storage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/data_storage/#custom-data-types","title":"Custom Data Types","text":"<p>You can use scratchpads to store any custom data type by implementing proper serialization:</p> <pre><code>#[derive(Serialize, Deserialize)]\nstruct CustomData {\n    field1: String,\n    field2: u64,\n}\n\n// Serialize before storing\nlet custom_data = CustomData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet bytes = serde_json::to_vec(&amp;custom_data)?;\nscratchpad.update_and_sign(Bytes::from(bytes), &amp;secret_key);\n</code></pre>"},{"location":"guides/data_storage/#batch-operations","title":"Batch Operations","text":"<p>For better performance when dealing with multiple data items:</p> <pre><code>async fn batch_store(items: Vec&lt;Bytes&gt;) -&gt; Result&lt;Vec&lt;ChunkAddress&gt;&gt; {\n    let mut addresses = Vec::new();\n    for item in items {\n        let (data_map_chunk, chunks) = encrypt(item)?;\n        // Store chunks in parallel\n        futures::future::join_all(chunks.iter().map(|c| store_chunk(c))).await;\n        addresses.push(data_map_chunk.address());\n    }\n    Ok(addresses)\n}\n</code></pre>"},{"location":"guides/data_types/","title":"Data Types Guide","text":"<p>This guide explains the fundamental data types in Autonomi and how they can be used to build higher-level abstractions like files and directories.</p>"},{"location":"guides/data_types/#fundamental-data-types","title":"Fundamental Data Types","text":"<p>Autonomi provides four fundamental data types that serve as building blocks for all network operations. Each type is designed for specific use cases and together they provide a complete system for decentralized data management.</p>"},{"location":"guides/data_types/#1-chunk","title":"1. Chunk","text":"<p>Chunks are the foundation of secure data storage in Autonomi, primarily used as the output of self-encrypting files. This provides quantum-secure encryption for data at rest.</p> <pre><code>// Store raw bytes as a chunk\nlet data = b\"Hello, World!\";\nlet chunk_address = client.store_chunk(data).await?;\n\n// Retrieve chunk data\nlet retrieved = client.get_chunk(chunk_address).await?;\nassert_eq!(data, retrieved);\n</code></pre> <p>Key characteristics: - Quantum-secure encryption through self-encryption - Immutable content - Content-addressed (address is derived from data) - Size-limited (maximum chunk size) - Efficient for small to medium-sized data</p>"},{"location":"guides/data_types/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data is split into fixed-size sections</li> <li>Each section is encrypted using data from other sections</li> <li>Results in multiple encrypted chunks</li> <li>Original data can only be recovered with all chunks</li> </ol>"},{"location":"guides/data_types/#2-pointer","title":"2. Pointer","text":"<p>Pointers provide a fixed network address that can reference any other data type, including other pointers. They enable mutable data structures while maintaining stable addresses.</p> <pre><code>// Create a pointer to some data\nlet pointer = client.create_pointer(target_address).await?;\n\n// Update pointer target\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer to get current target\nlet target = client.resolve_pointer(pointer.address()).await?;\n\n// Chain pointers for indirection\nlet pointer_to_pointer = client.create_pointer(pointer.address()).await?;\n</code></pre> <p>Key characteristics: - Fixed network address - Mutable reference capability - Single owner (controlled by secret key) - Version tracking with monotonic counter - Atomic updates - Support for pointer chains and indirection</p>"},{"location":"guides/data_types/#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>Mutable Data References <pre><code>// Update data while maintaining same address\nlet pointer = client.create_pointer(initial_data).await?;\nclient.update_pointer(pointer.address(), updated_data).await?;\n</code></pre></p> </li> <li> <p>Latest Version Publishing <pre><code>// Point to latest version while maintaining history\nlet history = client.create_linked_list().await?;\nlet latest = client.create_pointer(history.address()).await?;\n</code></pre></p> </li> <li> <p>Indirection and Redirection <pre><code>// Create chain of pointers for flexible data management\nlet data_pointer = client.create_pointer(data).await?;\nlet redirect_pointer = client.create_pointer(data_pointer.address()).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#3-linkedlist","title":"3. LinkedList","text":"<p>LinkedLists in Autonomi are powerful structures that can form transaction chains or decentralized Directed Acyclic Graphs (DAGs) on the network. They provide both historical tracking and CRDT-like properties.</p> <pre><code>// Create a new linked list\nlet list = client.create_linked_list().await?;\n\n// Append items to create history\nclient.append_to_list(list.address(), item1).await?;\nclient.append_to_list(list.address(), item2).await?;\n\n// Read list contents including history\nlet items = client.get_list(list.address()).await?;\n\n// Check for forks\nlet forks = client.detect_forks(list.address()).await?;\n</code></pre> <p>Key characteristics: - Decentralized DAG structure - Fork detection and handling - Transaction chain support - CRDT-like conflict resolution - Version history tracking - Support for value transfer (cryptocurrency-like)</p>"},{"location":"guides/data_types/#dag-properties","title":"DAG Properties","text":"<ol> <li> <p>Fork Detection <pre><code>// Detect and handle forks in the list\nmatch client.detect_forks(list.address()).await? {\n    Fork::None =&gt; proceed_with_updates(),\n    Fork::Detected(branches) =&gt; resolve_conflict(branches),\n}\n</code></pre></p> </li> <li> <p>Transaction Chains <pre><code>// Create a transaction chain\nlet transaction = Transaction {\n    previous: Some(last_tx_hash),\n    amount: 100,\n    recipient: address,\n};\nclient.append_to_list(chain.address(), transaction).await?;\n</code></pre></p> </li> <li> <p>History Tracking <pre><code>// Get full history of changes\nlet history = client.get_list_history(list.address()).await?;\nfor entry in history {\n    println!(\"Version {}: {:?}\", entry.version, entry.data);\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#4-scratchpad","title":"4. ScratchPad","text":"<p>ScratchPad provides a flexible, unstructured data storage mechanism with CRDT properties through counter-based versioning. It's ideal for user account data, application configurations, and other frequently updated small data packets.</p> <pre><code>// Create a scratchpad for user settings\nlet pad = client.create_scratchpad(ContentType::UserSettings).await?;\n\n// Update with encrypted data\nlet encrypted = encrypt_aes(settings_data, user_key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n\n// Read and decrypt current data\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet settings = decrypt_aes(encrypted, user_key)?;\n</code></pre> <p>Key characteristics: - Unstructured data storage - Counter-based CRDT for conflict resolution - Type-tagged content - Support for user-managed encryption - Efficient for frequent updates - Ideal for small data packets</p>"},{"location":"guides/data_types/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Encryption <pre><code>// Example of AES encryption for scratchpad data\nlet key = generate_aes_key();\nlet encrypted = aes_encrypt(data, key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n</code></pre></p> </li> <li> <p>Access Control <pre><code>// Create encrypted scratchpad with access control\nlet (public_key, private_key) = generate_keypair();\nlet encrypted_key = encrypt_with_public_key(aes_key, public_key);\nlet metadata = ScratchpadMetadata {\n    encrypted_key,\n    allowed_users: vec![public_key],\n};\nclient.create_scratchpad_with_access(metadata).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#common-applications","title":"Common Applications","text":"<ol> <li> <p>User Profiles <pre><code>// Store encrypted user profile\nlet profile = UserProfile { name, settings };\nlet encrypted = encrypt_profile(profile, user_key);\nclient.update_scratchpad(profile_pad, encrypted).await?;\n</code></pre></p> </li> <li> <p>Application State <pre><code>// Maintain application configuration\nlet config = AppConfig { preferences, state };\nlet pad = client.get_or_create_config_pad().await?;\nclient.update_scratchpad(pad, config).await?;\n</code></pre></p> </li> <li> <p>Temporary Storage <pre><code>// Use as temporary workspace\nlet workspace = client.create_scratchpad(ContentType::Workspace).await?;\nclient.update_scratchpad(workspace, working_data).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#higher-level-abstractions","title":"Higher-Level Abstractions","text":"<p>These fundamental types can be combined to create higher-level data structures:</p>"},{"location":"guides/data_types/#file-system","title":"File System","text":"<p>The Autonomi file system is built on top of these primitives:</p> <pre><code>// Create a directory\nlet dir = client.create_directory(\"my_folder\").await?;\n\n// Create a file\nlet file = client.create_file(\"example.txt\", content).await?;\n\n// Add file to directory\nclient.add_to_directory(dir.address(), file.address()).await?;\n\n// List directory contents\nlet entries = client.list_directory(dir.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#files","title":"Files","text":"<p>Files are implemented using a combination of chunks and pointers:</p> <ul> <li>Large files are split into chunks</li> <li>File metadata stored in pointer</li> <li>Content addressing for deduplication</li> </ul> <pre><code>// Store a large file\nlet file_map = client.store_file(\"large_file.dat\").await?;\n\n// Read file contents\nclient.get_file(file_map, \"output.dat\").await?;\n</code></pre>"},{"location":"guides/data_types/#directories","title":"Directories","text":"<p>Directories use linked lists and pointers to maintain a mutable collection of entries:</p> <ul> <li>LinkedList stores directory entries</li> <li>Pointer maintains current directory state</li> <li>Hierarchical structure support</li> </ul> <pre><code>// Create nested directory structure\nlet root = client.create_directory(\"/\").await?;\nlet docs = client.create_directory(\"docs\").await?;\nclient.add_to_directory(root.address(), docs.address()).await?;\n\n// List recursively\nlet tree = client.list_recursive(root.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/data_types/#data-organization","title":"Data Organization","text":"<ol> <li>Static Content</li> <li>Use chunks for immutable data</li> <li>Content addressing enables deduplication</li> <li> <p>Efficient for read-heavy workloads</p> </li> <li> <p>Mutable References</p> </li> <li>Use pointers for updateable references</li> <li>Maintain stable addresses</li> <li> <p>Version tracking built-in</p> </li> <li> <p>Collections</p> </li> <li>Use linked lists for ordered data</li> <li>Efficient for append operations</li> <li> <p>Good for logs and sequences</p> </li> <li> <p>Temporary Storage</p> </li> <li>Use scratchpads for working data</li> <li>Frequent updates supported</li> <li>Type-tagged content</li> </ol>"},{"location":"guides/data_types/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the Right Type</li> <li>Chunks for immutable data</li> <li>Pointers for mutable references</li> <li>LinkedLists for collections</li> <li> <p>ScratchPads for temporary storage</p> </li> <li> <p>Efficient Data Structures</p> </li> </ol> <pre><code>// Bad: Using chunks for frequently changing data\nlet chunk = client.store_chunk(changing_data).await?;\n\n// Good: Using scratchpad for frequently changing data\nlet pad = client.create_scratchpad(content_type).await?;\nclient.update_scratchpad(pad.address(), changing_data).await?;\n</code></pre> <ol> <li>Version Management</li> </ol> <pre><code>// Track versions with pointers\nlet versions = Vec::new();\nversions.push(pointer.version());\nclient.update_pointer(pointer.address(), new_data).await?;\nversions.push(pointer.version());\n</code></pre> <ol> <li>Error Handling</li> </ol> <pre><code>match client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound) =&gt; handle_missing_chunk(),\n    Err(ChunkError::InvalidSize) =&gt; handle_size_error(),\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"guides/data_types/#common-issues","title":"Common Issues","text":"<ol> <li>Size Limitations</li> <li>Chunk size limits</li> <li> <p>Solution: Split large data across multiple chunks</p> </li> <li> <p>Update Conflicts</p> </li> <li>Concurrent pointer updates</li> <li> <p>Solution: Use version checking</p> </li> <li> <p>Performance</p> </li> <li>LinkedList traversal costs</li> <li>Solution: Use appropriate data structures for access patterns</li> </ol>"},{"location":"guides/error_handling/","title":"Error Handling in Autonomi","text":"<p>This guide covers error handling best practices and patterns across all supported languages in Autonomi.</p>"},{"location":"guides/error_handling/#overview","title":"Overview","text":"<p>Proper error handling is crucial for building reliable applications with Autonomi. This guide provides comprehensive coverage of error types, handling strategies, and best practices across Rust, Python, and TypeScript implementations.</p>"},{"location":"guides/error_handling/#error-types","title":"Error Types","text":""},{"location":"guides/error_handling/#common-error-categories","title":"Common Error Categories","text":"<ol> <li>Network Errors</li> <li>Connection failures</li> <li>Timeout errors</li> <li> <p>Peer discovery issues</p> </li> <li> <p>Storage Errors</p> </li> <li>Capacity limits</li> <li>Chunk storage failures</li> <li> <p>Data retrieval errors</p> </li> <li> <p>Cryptographic Errors</p> </li> <li>Encryption failures</li> <li>Signature verification errors</li> <li> <p>Key management issues</p> </li> <li> <p>Client Errors</p> </li> <li>Configuration errors</li> <li>Permission denied</li> <li>Invalid operations</li> </ol>"},{"location":"guides/error_handling/#language-specific-implementation","title":"Language-Specific Implementation","text":""},{"location":"guides/error_handling/#rust-implementation","title":"Rust Implementation","text":"<pre><code>use autonomi::{Client, Error, Result};\n\nasync fn handle_storage_operation(data: Vec&lt;u8&gt;) -&gt; Result&lt;Pointer&gt; {\n    let client = Client::init().await?;\n\n    match client.store(data).await {\n        Ok(pointer) =&gt; Ok(pointer),\n        Err(Error::StorageCapacityExceeded) =&gt; {\n            // Handle capacity error\n            cleanup_old_data().await?;\n            client.store(data).await\n        }\n        Err(Error::NetworkTimeout) =&gt; {\n            // Retry with exponential backoff\n            retry_with_backoff(|| client.store(data)).await\n        }\n        Err(e) =&gt; Err(e),\n    }\n}\n\n// Custom error type\n#[derive(Debug, thiserror::Error)]\npub enum AppError {\n    #[error(\"Autonomi error: {0}\")]\n    Autonomi(#[from] autonomi::Error),\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n</code></pre>"},{"location":"guides/error_handling/#python-implementation","title":"Python Implementation","text":"<pre><code>from autonomi import Client, AutonomiError\nfrom autonomi.errors import StorageError, NetworkError\nimport asyncio\nfrom typing import Any, Optional\n\nasync def handle_storage_operation(data: bytes) -&gt; Optional[str]:\n    try:\n        client = await Client.init()\n        pointer = await client.store(data)\n        return pointer\n    except StorageError as e:\n        # Handle storage-specific errors\n        logger.error(f\"Storage error: {e}\")\n        if isinstance(e, StorageError.CapacityExceeded):\n            await cleanup_old_data()\n            return await client.store(data)\n        raise\n    except NetworkError as e:\n        # Handle network-specific errors\n        logger.error(f\"Network error: {e}\")\n        return await retry_with_backoff(lambda: client.store(data))\n    except AutonomiError as e:\n        # Handle other Autonomi-specific errors\n        logger.error(f\"Autonomi error: {e}\")\n        raise\n</code></pre>"},{"location":"guides/error_handling/#typescript-implementation","title":"TypeScript Implementation","text":"<pre><code>import { Client, AutonomiError, StorageError, NetworkError } from '@autonomi/client';\n\nasync function handleStorageOperation(data: Buffer): Promise&lt;string&gt; {\n  try {\n    const client = await Client.init();\n    return await client.store(data);\n  } catch (error) {\n    if (error instanceof StorageError) {\n      // Handle storage-specific errors\n      console.error('Storage error:', error);\n      if (error.code === 'CAPACITY_EXCEEDED') {\n        await cleanupOldData();\n        return await client.store(data);\n      }\n    } else if (error instanceof NetworkError) {\n      // Handle network-specific errors\n      console.error('Network error:', error);\n      return await retryWithBackoff(() =&gt; client.store(data));\n    } else if (error instanceof AutonomiError) {\n      // Handle other Autonomi-specific errors\n      console.error('Autonomi error:', error);\n    }\n    throw error;\n  }\n}\n</code></pre>"},{"location":"guides/error_handling/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"guides/error_handling/#retry-mechanisms","title":"Retry Mechanisms","text":"<pre><code>async function retryWithBackoff&lt;T&gt;(\n  operation: () =&gt; Promise&lt;T&gt;,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise&lt;T&gt; {\n  let lastError: Error;\n\n  for (let i = 0; i &lt; maxRetries; i++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      if (!isRetryableError(error)) {\n        throw error;\n      }\n      const delay = baseDelay * Math.pow(2, i);\n      await new Promise(resolve =&gt; setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n</code></pre>"},{"location":"guides/error_handling/#circuit-breaker","title":"Circuit Breaker","text":"<pre><code>use std::time::{Duration, Instant};\n\nstruct CircuitBreaker {\n    failure_threshold: u32,\n    reset_timeout: Duration,\n    failure_count: u32,\n    last_failure: Option&lt;Instant&gt;,\n}\n\nimpl CircuitBreaker {\n    async fn execute&lt;F, T, E&gt;(&amp;mut self, operation: F) -&gt; Result&lt;T, E&gt;\n    where\n        F: Future&lt;Output = Result&lt;T, E&gt;&gt;,\n    {\n        if self.is_open() {\n            return Err(Error::CircuitBreakerOpen);\n        }\n\n        match operation.await {\n            Ok(result) =&gt; {\n                self.reset();\n                Ok(result)\n            }\n            Err(e) =&gt; {\n                self.record_failure();\n                Err(e)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error_handling/#error-recovery","title":"Error Recovery","text":"<pre><code>async def recover_from_error(error: AutonomiError) -&gt; None:\n    if isinstance(error, NetworkError):\n        await reconnect_to_network()\n    elif isinstance(error, StorageError):\n        await cleanup_storage()\n    elif isinstance(error, CryptoError):\n        await refresh_keys()\n</code></pre>"},{"location":"guides/error_handling/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"guides/error_handling/#structured-logging","title":"Structured Logging","text":"<pre><code>use tracing::{error, info, warn};\n\nasync fn process_operation() -&gt; Result&lt;()&gt; {\n    info!(\n        operation = \"store\",\n        size = data.len(),\n        \"Starting storage operation\"\n    );\n\n    match client.store(data).await {\n        Ok(pointer) =&gt; {\n            info!(\n                operation = \"store\",\n                pointer = %pointer,\n                \"Storage operation successful\"\n            );\n            Ok(())\n        }\n        Err(e) =&gt; {\n            error!(\n                operation = \"store\",\n                error = %e,\n                \"Storage operation failed\"\n            );\n            Err(e)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error_handling/#metrics-collection","title":"Metrics Collection","text":"<pre><code>import { metrics } from '@autonomi/client';\n\nasync function trackOperation&lt;T&gt;(\n  name: string,\n  operation: () =&gt; Promise&lt;T&gt;\n): Promise&lt;T&gt; {\n  const timer = metrics.startTimer(`operation_${name}`);\n  try {\n    const result = await operation();\n    metrics.incrementCounter(`operation_${name}_success`);\n    return result;\n  } catch (error) {\n    metrics.incrementCounter(`operation_${name}_error`);\n    throw error;\n  } finally {\n    timer.end();\n  }\n}\n</code></pre>"},{"location":"guides/error_handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always use typed errors</li> <li>Implement proper error recovery</li> <li>Use structured logging</li> <li>Implement retry mechanisms</li> <li>Monitor error rates</li> <li>Provide clear error messages</li> </ol>"},{"location":"guides/error_handling/#error-prevention","title":"Error Prevention","text":""},{"location":"guides/error_handling/#input-validation","title":"Input Validation","text":"<pre><code>use validator::Validate;\n\n#[derive(Debug, Validate)]\nstruct StorageRequest {\n    #[validate(length(min = 1, max = 1000000))]\n    data: Vec&lt;u8&gt;,\n    #[validate(range(min = 1, max = 100))]\n    chunk_size: usize,\n}\n</code></pre>"},{"location":"guides/error_handling/#defensive-programming","title":"Defensive Programming","text":"<pre><code>from typing import Optional\n\ndef get_storage_config(config: dict) -&gt; StorageConfig:\n    return StorageConfig(\n        chunk_size=config.get('chunk_size', DEFAULT_CHUNK_SIZE),\n        encryption=config.get('encryption', True),\n        compression=config.get('compression', False)\n    )\n</code></pre>"},{"location":"guides/error_handling/#testing-error-handling","title":"Testing Error Handling","text":""},{"location":"guides/error_handling/#unit-tests","title":"Unit Tests","text":"<pre><code>#[cfg(test)]\nmod tests {\n    #[test]\n    async fn test_storage_error_handling() {\n        let client = MockClient::new()\n            .with_error(StorageError::CapacityExceeded);\n\n        let result = handle_storage_operation(data).await;\n        assert!(matches!(result, Err(Error::StorageCapacityExceeded)));\n    }\n}\n</code></pre>"},{"location":"guides/error_handling/#integration-tests","title":"Integration Tests","text":"<pre><code>describe('Error Handling', () =&gt; {\n  it('should handle network errors', async () =&gt; {\n    const client = new Client();\n    mockNetworkFailure();\n\n    await expect(client.store(data))\n      .rejects\n      .toThrow(NetworkError);\n  });\n});\n</code></pre>"},{"location":"guides/error_handling/#resources","title":"Resources","text":"<ul> <li>API Reference</li> <li>Web Development Guide</li> <li>Quantum Security Guide</li> </ul>"},{"location":"guides/error_handling/#support","title":"Support","text":"<p>For error handling support:</p> <ul> <li>Technical support: support@autonomi.com</li> <li>Documentation: https://docs.autonomi.com/errors</li> <li>Issue tracker: https://github.com/dirvine/autonomi/issues</li> </ul>"},{"location":"guides/evm_integration/","title":"EVM Integration Guide","text":"<p>This guide explains how to integrate Autonomi with EVM-compatible networks for testing and development.</p>"},{"location":"guides/evm_integration/#supported-networks","title":"Supported Networks","text":"<ul> <li>Local Hardhat network</li> <li>Sepolia testnet</li> <li>Goerli testnet</li> <li>Custom EVM networks</li> </ul>"},{"location":"guides/evm_integration/#setting-up-test-networks","title":"Setting Up Test Networks","text":""},{"location":"guides/evm_integration/#local-hardhat-network","title":"Local Hardhat Network","text":"<pre><code>npx hardhat node\n</code></pre>"},{"location":"guides/evm_integration/#connecting-to-test-networks","title":"Connecting to Test Networks","text":"<pre><code>import { EvmNetwork } from '@autonomi/client';\n\nconst network = new EvmNetwork({\n  chainId: 31337, // Local hardhat network\n  rpcUrl: 'http://127.0.0.1:8545'\n});\n</code></pre>"},{"location":"guides/evm_integration/#deploying-test-contracts","title":"Deploying Test Contracts","text":"<ol> <li>Compile contracts</li> <li>Deploy using Hardhat</li> <li>Interact with contracts</li> </ol>"},{"location":"guides/evm_integration/#testing-with-different-networks","title":"Testing with Different Networks","text":"<ul> <li>Network configuration</li> <li>Gas settings</li> <li>Contract deployment</li> <li>Transaction handling</li> </ul>"},{"location":"guides/evm_integration/#best-practices","title":"Best Practices","text":"<ul> <li>Error handling</li> <li>Gas optimization</li> <li>Security considerations</li> <li>Testing strategies</li> </ul>"},{"location":"guides/local_development/","title":"Local Development Environment","text":"<p>This guide will help you set up a local development environment for building applications with Autonomi. We'll use a script that sets up a local network with all the necessary components for development and testing.</p>"},{"location":"guides/local_development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain installed</li> <li>Git repository cloned</li> <li>Basic understanding of terminal/command line</li> </ul>"},{"location":"guides/local_development/#setup-script","title":"Setup Script","text":"<p>Save the following script as <code>start-local-network.sh</code> in your project root:</p> <pre><code>#!/bin/bash\nset -e\n\n# Configuration\nNODE_DATA_DIR=\"$HOME/Library/Application Support/autonomi/node\"\nCLIENT_DATA_DIR=\"$HOME/Library/Application Support/autonomi/client\"\nEVM_PORT=4343\nEVM_RPC_URL=\"http://localhost:8545\"\nWALLET_ADDRESS=\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\nTOKEN_ADDRESS=\"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\nLOG_LEVEL=\"info\"\nNODE_PORT=5000\n\n# ... (rest of the script content) ...\n</code></pre> <p>Make the script executable:</p> <pre><code>chmod +x start-local-network.sh\n</code></pre>"},{"location":"guides/local_development/#using-the-development-environment","title":"Using the Development Environment","text":"<ol> <li>Start the local network:</li> </ol> <pre><code>./start-local-network.sh\n</code></pre> <ol> <li>The script will:</li> <li>Build all necessary components (ant-node, evm-testnet, ant CLI)</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li> <p>Set up the development environment</p> </li> <li> <p>Once running, you'll see information about:</p> </li> <li>Network endpoints</li> <li>Environment variables</li> <li>Example commands</li> </ol>"},{"location":"guides/local_development/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables should be set for your development environment:</p> <pre><code>export ANT_PEERS=/ip4/127.0.0.1/udp/5000/quic-v1\nexport ANT_LOG=info\nexport CLIENT_DATA_PATH=$HOME/Library/Application Support/autonomi/client\n</code></pre>"},{"location":"guides/local_development/#example-usage","title":"Example Usage","text":""},{"location":"guides/local_development/#file-operations","title":"File Operations","text":"<p>Upload a file:</p> <pre><code>./target/debug/ant file upload path/to/file\n</code></pre> <p>Download a file:</p> <pre><code>./target/debug/ant file download &lt;file-address&gt;\n</code></pre>"},{"location":"guides/local_development/#node-operations","title":"Node Operations","text":"<p>Check node status:</p> <pre><code>./target/debug/ant node status\n</code></pre> <p>Get wallet balance:</p> <pre><code>./target/debug/ant wallet balance\n</code></pre>"},{"location":"guides/local_development/#development-tips","title":"Development Tips","text":"<ol> <li> <p>Local Testing: The local network is perfect for testing your applications without affecting the main network.</p> </li> <li> <p>Quick Iterations: Changes to your application can be tested immediately without waiting for network confirmations.</p> </li> <li> <p>Clean State: Each time you start the network, it begins with a clean state, making it ideal for testing different scenarios.</p> </li> <li> <p>Debugging: The local environment provides detailed logs and quick feedback for debugging.</p> </li> </ol>"},{"location":"guides/local_development/#customization","title":"Customization","text":"<p>You can customize the development environment by modifying the configuration variables at the top of the script:</p> <ul> <li><code>NODE_PORT</code>: Change the port the node listens on</li> <li><code>LOG_LEVEL</code>: Adjust logging verbosity (\"trace\", \"debug\", \"info\", \"warn\", \"error\")</li> <li><code>EVM_PORT</code>: Change the EVM testnet port</li> <li>Other settings as needed</li> </ul>"},{"location":"guides/local_development/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Port Conflicts: If you see port-in-use errors, modify the <code>NODE_PORT</code> or <code>EVM_PORT</code> in the script.</p> </li> <li> <p>Process Cleanup: If the script fails to start, ensure no old processes are running:</p> </li> </ol> <pre><code>pkill -f \"antnode\"\npkill -f \"evm-testnet\"\n</code></pre> <ol> <li>Data Cleanup: To start completely fresh, remove the data directories:</li> </ol> <pre><code>rm -rf \"$HOME/Library/Application Support/autonomi/node\"\nrm -rf \"$HOME/Library/Application Support/autonomi/client\"\n</code></pre>"},{"location":"guides/local_network/","title":"Local Network Setup Guide","text":"<p>This guide explains how to set up and run a local Autonomi network for development and testing purposes.</p>"},{"location":"guides/local_network/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (with <code>cargo</code> installed)</li> <li>Git (for cloning the repository)</li> </ul> <p>That's it! Everything else needed will be built from source.</p>"},{"location":"guides/local_network/#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/dirvine/autonomi\ncd autonomi\n</code></pre> <ol> <li>Start the local network:</li> </ol> <pre><code>./test-local.sh\n</code></pre> <p>This script will:</p> <ul> <li>Build all necessary components</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li>Set up the development environment</li> </ul>"},{"location":"guides/local_network/#network-components","title":"Network Components","text":"<p>The local network consists of:</p> <ul> <li>An Autonomi node running in local mode</li> <li>A local EVM test network with pre-funded accounts</li> <li>Test wallets for development</li> </ul>"},{"location":"guides/local_network/#testing-with-evm-networks","title":"Testing with EVM Networks","text":"<p>The local EVM network provides a complete testing environment for blockchain interactions:</p>"},{"location":"guides/local_network/#pre-deployed-contracts","title":"Pre-deployed Contracts","text":"<p>The following contracts are automatically deployed:</p> <ul> <li>Payment Vault Contract (<code>PaymentVaultNoProxy</code>)</li> <li>Handles data storage payments</li> <li>Manages token approvals and transfers</li> <li>Verifies payment proofs</li> <li>Test Token Contract (<code>TestToken</code>)</li> <li>ERC20 token for testing payments</li> <li>Pre-minted supply for test accounts</li> <li>Automatic approval for test wallets</li> </ul>"},{"location":"guides/local_network/#test-accounts","title":"Test Accounts","text":"<p>Several accounts are pre-funded and ready to use:</p> <pre><code>Primary Test Account:\nAddress: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nPrivate Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nBalance: 10000 TEST tokens\n\nSecondary Test Account:\nAddress: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8\nPrivate Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\nBalance: 1000 TEST tokens\n</code></pre>"},{"location":"guides/local_network/#rpc-endpoint","title":"RPC Endpoint","text":"<p>The local EVM network exposes an RPC endpoint at <code>http://localhost:8545</code> with:</p> <ul> <li>Full JSON-RPC API support</li> <li>WebSocket subscriptions</li> <li>Low block time (1 second)</li> <li>Zero gas costs</li> <li>Instant transaction confirmations</li> </ul>"},{"location":"guides/local_network/#interacting-with-the-network","title":"Interacting with the Network","text":""},{"location":"guides/local_network/#javascripttypescript","title":"JavaScript/TypeScript","text":"<pre><code>import { ethers } from 'ethers';\n\n// Connect to local network\nconst provider = new ethers.JsonRpcProvider('http://localhost:8545');\nconst wallet = new ethers.Wallet(PRIVATE_KEY, provider);\n\n// Get contract instances\nconst paymentVault = new ethers.Contract(\n  PAYMENT_VAULT_ADDRESS,\n  PAYMENT_VAULT_ABI,\n  wallet\n);\n\n// Interact with contracts\nawait paymentVault.getQuote([metrics]);\nawait paymentVault.payForQuotes(payments);\n</code></pre>"},{"location":"guides/local_network/#python","title":"Python","text":"<pre><code>from web3 import Web3\nfrom eth_account import Account\n\n# Connect to local network\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\naccount = Account.from_key(PRIVATE_KEY)\n\n# Get contract instances\npayment_vault = w3.eth.contract(\n    address=PAYMENT_VAULT_ADDRESS,\n    abi=PAYMENT_VAULT_ABI\n)\n\n# Interact with contracts\npayment_vault.functions.getQuote([metrics]).call()\npayment_vault.functions.payForQuotes(payments).transact()\n</code></pre>"},{"location":"guides/local_network/#rust","title":"Rust","text":"<pre><code>use ethers::prelude::*;\n\n// Connect to local network\nlet provider = Provider::&lt;Http&gt;::try_from(\"http://localhost:8545\")?;\nlet wallet = LocalWallet::from_bytes(&amp;PRIVATE_KEY)?;\nlet client = SignerMiddleware::new(provider, wallet);\n\n// Get contract instances\nlet payment_vault = PaymentVault::new(\n    PAYMENT_VAULT_ADDRESS,\n    Arc::new(client)\n);\n\n// Interact with contracts\npayment_vault.get_quote(metrics).call().await?;\npayment_vault.pay_for_quotes(payments).send().await?;\n</code></pre>"},{"location":"guides/local_network/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are set up automatically:</p> <ul> <li><code>ANT_PEERS</code> - Local node endpoint</li> <li><code>ANT_LOG</code> - Logging level</li> <li><code>CLIENT_DATA_PATH</code> - Client data directory</li> </ul>"},{"location":"guides/local_network/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"guides/local_network/#logging","title":"Logging","text":""},{"location":"guides/local_network/#node-logs","title":"Node Logs","text":"<p>The Autonomi node generates detailed logs that can be controlled via <code>RUST_LOG</code>:</p> <pre><code># Trace level for maximum detail\nRUST_LOG=trace ./test-local.sh\n\n# Focus on specific modules\nRUST_LOG=autonomi=debug,ant_node=trace ./test-local.sh\n\n# Log locations:\n- Node logs: $NODE_DATA_DIR/node.log\n- EVM logs: $NODE_DATA_DIR/evm.log\n</code></pre>"},{"location":"guides/local_network/#log-levels","title":"Log Levels","text":"<ul> <li><code>error</code>: Critical issues that need immediate attention</li> <li><code>warn</code>: Important events that aren't failures</li> <li><code>info</code>: General operational information</li> <li><code>debug</code>: Detailed information for debugging</li> <li><code>trace</code>: Very detailed protocol-level information</li> </ul>"},{"location":"guides/local_network/#following-logs","title":"Following Logs","text":"<pre><code># Follow node logs\ntail -f \"$NODE_DATA_DIR/node.log\"\n\n# Follow EVM logs\ntail -f \"$NODE_DATA_DIR/evm.log\"\n\n# Filter for specific events\ntail -f \"$NODE_DATA_DIR/node.log\" | grep \"payment\"\n</code></pre>"},{"location":"guides/local_network/#debugging","title":"Debugging","text":""},{"location":"guides/local_network/#node-debugging","title":"Node Debugging","text":"<p>Using <code>rust-lldb</code>:</p> <pre><code># Start node with debugger\nrust-lldb target/debug/antnode -- --features test\n\n# Common commands:\nb autonomi::client::payment::pay  # Set breakpoint\nr                                # Run\nbt                              # Backtrace\np variable                      # Print variable\nc                              # Continue\n</code></pre> <p>Using <code>rust-gdb</code>:</p> <pre><code># Start node with debugger\nrust-gdb target/debug/antnode -- --features test\n\n# Common commands:\nbreak autonomi::client::payment::pay  # Set breakpoint\nrun                                  # Run\nbacktrace                           # Show backtrace\nprint variable                      # Examine variable\ncontinue                            # Continue execution\n</code></pre>"},{"location":"guides/local_network/#network-monitoring","title":"Network Monitoring","text":"<p>Monitor network activity:</p> <pre><code># Watch network connections\nnetstat -an | grep 5000  # Default node port\n\n# Monitor network traffic\nsudo tcpdump -i lo0 port 5000\n\n# Check EVM network\ncurl -X POST -H \"Content-Type: application/json\" \\\n  --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' \\\n  http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#contract-debugging","title":"Contract Debugging","text":"<p>Debug contract interactions:</p> <pre><code># Get payment vault state\ncast call $PAYMENT_VAULT_ADDRESS \\\n  \"payments(bytes32)\" \\\n  $QUOTE_HASH \\\n  --rpc-url http://localhost:8545\n\n# Watch for payment events\ncast events $PAYMENT_VAULT_ADDRESS \\\n  --rpc-url http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"guides/local_network/#port-conflicts","title":"Port Conflicts","text":"<p>If you see port-in-use errors:</p> <ol> <li>Check if another instance is running</li> <li>Use different ports in the script</li> <li>Kill existing processes if needed</li> </ol>"},{"location":"guides/local_network/#build-issues","title":"Build Issues","text":"<ol> <li>Make sure Rust toolchain is up to date</li> <li>Clean and rebuild: <code>cargo clean &amp;&amp; cargo build</code></li> <li>Check for missing dependencies</li> </ol>"},{"location":"guides/local_network/#network-issues","title":"Network Issues","text":"<ol> <li>Verify the node is running</li> <li>Check log output for errors</li> <li>Ensure EVM testnet is accessible</li> </ol>"},{"location":"guides/local_network/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/local_network/#custom-configuration","title":"Custom Configuration","text":"<p>You can modify the test script to:</p> <ul> <li>Change ports</li> <li>Adjust logging levels</li> <li>Configure node parameters</li> </ul>"},{"location":"guides/local_network/#multiple-nodes","title":"Multiple Nodes","text":"<p>To run multiple nodes:</p> <ol> <li>Copy the script</li> <li>Modify ports and directories</li> <li>Run each instance separately</li> </ol>"},{"location":"guides/payments/","title":"Payments Guide","text":"<p>This guide explains how payments work in Autonomi, particularly for put operations that store data on the network.</p>"},{"location":"guides/payments/#overview","title":"Overview","text":"<p>When storing data on the Autonomi network, you need to pay for the storage space. Payments are made using EVM-compatible tokens through a smart contract system. There are two ways to handle payments:</p> <ol> <li>Direct payment using an EVM wallet</li> <li>Pre-paid operations using a receipt</li> </ol>"},{"location":"guides/payments/#payment-options","title":"Payment Options","text":""},{"location":"guides/payments/#using-an-evm-wallet","title":"Using an EVM Wallet","text":"<p>The simplest way to pay for put operations is to use an EVM wallet:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\n\n# Create or load a wallet\nwallet = EvmWallet.create()  # or load from private key\npayment = PaymentOption.from_wallet(wallet)\n\n# Put data with wallet payment\ndata = b\"Hello, World!\"\naddress = client.data_put_public(data, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\n\n// Create or load a wallet\nconst wallet = EvmWallet.create();  // or load from private key\nconst payment = PaymentOption.fromWallet(wallet);\n\n// Put data with wallet payment\nconst data = Buffer.from(\"Hello, World!\");\nconst address = await client.dataPutPublic(data, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\n\n// Create or load a wallet\nlet wallet = EvmWallet::create()?;  // or load from private key\nlet payment = wallet.into();  // Converts to PaymentOption\n\n// Put data with wallet payment\nlet data = b\"Hello, World!\".to_vec();\nlet address = client.data_put_public(data.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#using-pre-paid-receipts","title":"Using Pre-paid Receipts","text":"<p>For better efficiency when doing multiple put operations, you can pre-pay for storage and reuse the receipt:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\nwallet = EvmWallet.create()\n\n# Get receipt for multiple operations\ndata1 = b\"First piece of data\"\ndata2 = b\"Second piece of data\"\n\n# Create payment receipt\nreceipt = client.create_payment_receipt([data1, data2], wallet)\npayment = PaymentOption.from_receipt(receipt)\n\n# Use receipt for puts\naddr1 = client.data_put_public(data1, payment)\naddr2 = client.data_put_public(data2, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\nconst wallet = EvmWallet.create();\n\n// Get receipt for multiple operations\nconst data1 = Buffer.from(\"First piece of data\");\nconst data2 = Buffer.from(\"Second piece of data\");\n\n// Create payment receipt\nconst receipt = await client.createPaymentReceipt([data1, data2], wallet);\nconst payment = PaymentOption.fromReceipt(receipt);\n\n// Use receipt for puts\nconst addr1 = await client.dataPutPublic(data1, payment);\nconst addr2 = await client.dataPutPublic(data2, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\nlet wallet = EvmWallet::create()?;\n\n// Get receipt for multiple operations\nlet data1 = b\"First piece of data\".to_vec();\nlet data2 = b\"Second piece of data\".to_vec();\n\n// Create payment receipt\nlet receipt = client.create_payment_receipt(\n    vec![data1.clone(), data2.clone()].into_iter(), \n    &amp;wallet\n).await?;\nlet payment = receipt.into();  // Converts to PaymentOption\n\n// Use receipt for puts\nlet addr1 = client.data_put_public(data1.into(), payment.clone()).await?;\nlet addr2 = client.data_put_public(data2.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#cost-calculation","title":"Cost Calculation","text":"<p>The cost of storing data depends on several factors:</p> <ul> <li>Size of the data</li> <li>Network density</li> <li>Storage duration</li> <li>Current network conditions</li> </ul> <p>You can calculate the cost before performing a put operation:</p> <pre><code># Python\ncost = client.calculate_storage_cost(data)\nprint(f\"Storage will cost {cost} tokens\")\n</code></pre> <pre><code>// Node.js\nconst cost = await client.calculateStorageCost(data);\nconsole.log(`Storage will cost ${cost} tokens`);\n</code></pre> <pre><code>// Rust\nlet cost = client.calculate_storage_cost(&amp;data).await?;\nprintln!(\"Storage will cost {} tokens\", cost);\n</code></pre>"},{"location":"guides/payments/#token-management","title":"Token Management","text":"<p>Before you can pay for storage, you need to ensure your wallet has sufficient tokens and has approved the payment contract to spend them:</p> <pre><code># Python\n# Check balance\nbalance = wallet.get_balance()\n\n# Approve tokens if needed\nif not wallet.has_approved_tokens():\n    wallet.approve_tokens()\n</code></pre> <pre><code>// Node.js\n// Check balance\nconst balance = await wallet.getBalance();\n\n// Approve tokens if needed\nif (!await wallet.hasApprovedTokens()) {\n    await wallet.approveTokens();\n}\n</code></pre> <pre><code>// Rust\n// Check balance\nlet balance = wallet.get_balance().await?;\n\n// Approve tokens if needed\nif !wallet.has_approved_tokens().await? {\n    wallet.approve_tokens().await?;\n}\n</code></pre>"},{"location":"guides/payments/#error-handling","title":"Error Handling","text":"<p>Common payment-related errors you might encounter:</p> <ol> <li><code>InsufficientBalance</code> - Wallet doesn't have enough tokens</li> <li><code>TokenNotApproved</code> - Token spending not approved for the payment contract</li> <li><code>PaymentExpired</code> - Payment quote has expired (when using receipts)</li> <li><code>PaymentVerificationFailed</code> - Payment verification failed on the network</li> </ol> <p>Example error handling:</p> <pre><code># Python\ntry:\n    address = client.data_put_public(data, payment)\nexcept InsufficientBalance:\n    print(\"Not enough tokens in wallet\")\nexcept TokenNotApproved:\n    print(\"Need to approve token spending\")\nexcept PaymentError as e:\n    print(f\"Payment failed: {e}\")\n</code></pre> <pre><code>// Node.js\ntry {\n    const address = await client.dataPutPublic(data, payment);\n} catch (e) {\n    if (e instanceof InsufficientBalance) {\n        console.log(\"Not enough tokens in wallet\");\n    } else if (e instanceof TokenNotApproved) {\n        console.log(\"Need to approve token spending\");\n    } else {\n        console.log(`Payment failed: ${e}`);\n    }\n}\n</code></pre> <pre><code>// Rust\nmatch client.data_put_public(data.into(), payment).await {\n    Err(PutError::InsufficientBalance) =&gt; {\n        println!(\"Not enough tokens in wallet\");\n    }\n    Err(PutError::TokenNotApproved) =&gt; {\n        println!(\"Need to approve token spending\");\n    }\n    Err(e) =&gt; {\n        println!(\"Payment failed: {}\", e);\n    }\n    Ok(address) =&gt; {\n        println!(\"Data stored at {}\", address);\n    }\n}\n</code></pre>"},{"location":"guides/payments/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-approve Tokens: Approve token spending before starting put operations to avoid extra transactions.</p> </li> <li> <p>Use Receipts: When doing multiple put operations, use receipts to avoid making separate payments for each operation.</p> </li> <li> <p>Check Costs: Always check storage costs before proceeding with large data uploads.</p> </li> <li> <p>Handle Errors: Implement proper error handling for payment-related issues.</p> </li> <li> <p>Monitor Balance: Keep track of your wallet balance to ensure sufficient funds for operations.</p> </li> </ol>"},{"location":"guides/payments/#testing-payments","title":"Testing Payments","text":"<p>When testing your application, you can use the local development environment which provides a test EVM network with pre-funded wallets. See the Local Development Guide for details.</p>"},{"location":"guides/quantum_security/","title":"Quantum Security in Autonomi","text":"<p>This guide explains Autonomi's approach to quantum-resistant security and how to implement secure practices in your applications.</p>"},{"location":"guides/quantum_security/#overview","title":"Overview","text":"<p>Autonomi implements a hybrid security approach, combining information-theoretic security for data storage with traditional cryptographic methods for signatures. This guide covers the security features and best practices for maintaining security in your applications.</p>"},{"location":"guides/quantum_security/#security-features","title":"Security Features","text":""},{"location":"guides/quantum_security/#self-encryption-information-theoretically-secure","title":"Self-Encryption (Information-Theoretically Secure)","text":"<p>Autonomi's self-encryption scheme provides the highest level of security possible:</p> <ul> <li>Information-theoretically secure chunking (quantum-secure by definition)</li> <li>No reliance on computational hardness assumptions</li> <li>Secure against both classical and quantum attacks</li> <li>Splits data into chunks using information-theoretic principles</li> <li>Creates secure data maps for reconstruction</li> <li>Implements content-based addressing</li> </ul>"},{"location":"guides/quantum_security/#bls-threshold-signatures-classical-security","title":"BLS Threshold Signatures (Classical Security)","text":"<p>Our BLS threshold signature implementation provides:</p> <ul> <li>Classical cryptographic security (not quantum-resistant)</li> <li>Distributed key generation</li> <li>Threshold signature creation</li> <li>Secure aggregation</li> </ul> <p>Quantum Computing Consideration</p> <p>The BLS signature scheme is based on elliptic curve cryptography and will require updates when quantum computers reach sufficient capability. However, the core data storage mechanism using self-encryption chunks remains secure against quantum attacks.</p>"},{"location":"guides/quantum_security/#implementation-guide","title":"Implementation Guide","text":""},{"location":"guides/quantum_security/#secure-data-storage","title":"Secure Data Storage","text":"<pre><code>use autonomi::{Client, SecurityOptions};\n\n// Configure quantum-secure options\nlet options = SecurityOptions {\n    quantum_resistant: true,\n    encryption_strength: EncryptionStrength::Maximum,\n};\n\n// Initialize client with security options\nlet client = Client::init_with_options(options).await?;\n\n// Store data with quantum security\nlet pointer = client.store_secure(data).await?;\n</code></pre>"},{"location":"guides/quantum_security/#threshold-signatures","title":"Threshold Signatures","text":"<pre><code>use autonomi::crypto::bls::{KeyPair, ThresholdScheme};\n\n// Generate distributed keys\nlet scheme = ThresholdScheme::new(3, 5)?; // 3-of-5 threshold\nlet keys = scheme.generate_keys()?;\n\n// Create partial signatures\nlet signature = keys.sign_partial(&amp;message)?;\n\n// Combine signatures\nlet combined = scheme.combine_signatures(&amp;[signature1, signature2, signature3])?;\n</code></pre>"},{"location":"guides/quantum_security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"guides/quantum_security/#data-protection","title":"Data Protection","text":"<ol> <li>Always use quantum-resistant encryption for sensitive data</li> <li>Implement proper key management</li> <li>Use secure random number generation</li> <li>Regularly rotate encryption keys</li> </ol>"},{"location":"guides/quantum_security/#network-security","title":"Network Security","text":"<ol> <li>Use quantum-resistant TLS</li> <li>Implement secure peer discovery</li> <li>Validate all network messages</li> <li>Use secure routing protocols</li> </ol>"},{"location":"guides/quantum_security/#key-management","title":"Key Management","text":"<ol> <li>Use hardware security modules when possible</li> <li>Implement secure key storage</li> <li>Use key derivation functions</li> <li>Regular key rotation</li> </ol>"},{"location":"guides/quantum_security/#quantum-threat-model","title":"Quantum Threat Model","text":""},{"location":"guides/quantum_security/#current-threats","title":"Current Threats","text":"<ul> <li>Shor's algorithm impact on BLS signatures (future consideration)</li> <li>Store now, decrypt later attacks (mitigated by information-theoretic security for data)</li> <li>Quantum side-channel attacks</li> </ul>"},{"location":"guides/quantum_security/#mitigation-strategies","title":"Mitigation Strategies","text":"<ol> <li>Core data storage is already quantum-secure through information-theoretic security</li> <li>Future upgrade path planned for signature scheme</li> <li>Regular security audits</li> <li>Continuous monitoring</li> </ol>"},{"location":"guides/quantum_security/#implementation-examples","title":"Implementation Examples","text":""},{"location":"guides/quantum_security/#secure-file-storage","title":"Secure File Storage","text":"<pre><code>from autonomi import Client, SecurityConfig\n\n# Configure quantum-secure storage\nconfig = SecurityConfig(\n    quantum_resistant=True,\n    encryption_algorithm=\"post-quantum-aes\",\n    key_size=256\n)\n\n# Initialize client\nclient = Client(security_config=config)\n\n# Store file securely\npointer = await client.store_file_secure(file_path)\n</code></pre>"},{"location":"guides/quantum_security/#secure-communication","title":"Secure Communication","text":"<pre><code>import { Client, SecureChannel } from '@autonomi/client';\n\n// Create secure channel\nconst channel = await SecureChannel.create({\n  quantumResistant: true,\n  protocol: 'quantum-resistant-tls'\n});\n\n// Send encrypted message\nawait channel.send(message);\n</code></pre>"},{"location":"guides/quantum_security/#security-verification","title":"Security Verification","text":""},{"location":"guides/quantum_security/#audit-tools","title":"Audit Tools","text":"<ul> <li>Quantum security analyzers</li> <li>Cryptographic verification tools</li> <li>Network security scanners</li> <li>Key management auditors</li> </ul>"},{"location":"guides/quantum_security/#testing-procedures","title":"Testing Procedures","text":"<ol> <li>Regular security assessments</li> <li>Penetration testing</li> <li>Cryptographic verification</li> <li>Performance impact analysis</li> </ol>"},{"location":"guides/quantum_security/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/quantum_security/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Parallel encryption/decryption</li> <li>Efficient key management</li> <li>Optimized network protocols</li> <li>Caching strategies</li> </ol>"},{"location":"guides/quantum_security/#trade-offs","title":"Trade-offs","text":"<ul> <li>Security level vs performance</li> <li>Key size vs speed</li> <li>Storage overhead vs security</li> <li>Network latency vs security</li> </ul>"},{"location":"guides/quantum_security/#compliance-and-standards","title":"Compliance and Standards","text":""},{"location":"guides/quantum_security/#supported-standards","title":"Supported Standards","text":"<ul> <li>NIST Post-Quantum Cryptography</li> <li>Common Criteria Protection Profiles</li> <li>FIPS 140-3</li> <li>ISO/IEC 27001</li> </ul>"},{"location":"guides/quantum_security/#certification-process","title":"Certification Process","text":"<ol> <li>Security assessment</li> <li>Algorithm validation</li> <li>Implementation verification</li> <li>Continuous monitoring</li> </ol>"},{"location":"guides/quantum_security/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/quantum_security/#common-issues","title":"Common Issues","text":"<ol> <li>Key management problems</li> <li>Performance degradation</li> <li>Compatibility issues</li> <li>Integration challenges</li> </ol>"},{"location":"guides/quantum_security/#solutions","title":"Solutions","text":"<ul> <li>Regular security updates</li> <li>Performance optimization</li> <li>Compatibility layers</li> <li>Technical support</li> </ul>"},{"location":"guides/quantum_security/#future-developments","title":"Future Developments","text":""},{"location":"guides/quantum_security/#roadmap","title":"Roadmap","text":"<ol> <li>Enhanced quantum resistance</li> <li>Improved performance</li> <li>Additional security features</li> <li>Better integration options</li> </ol>"},{"location":"guides/quantum_security/#research-areas","title":"Research Areas","text":"<ul> <li>New quantum-resistant algorithms</li> <li>Improved key management</li> <li>Enhanced network security</li> <li>Better performance optimization</li> </ul>"},{"location":"guides/quantum_security/#resources","title":"Resources","text":"<ul> <li>API Reference</li> <li>Error Handling Guide</li> <li>Implementation Examples</li> </ul>"},{"location":"guides/quantum_security/#support","title":"Support","text":"<p>For security-related support:</p> <ul> <li>Security advisories: security@autonomi.com</li> <li>Bug bounty program: https://hackerone.com/autonomi</li> <li>Security documentation: https://docs.autonomi.com/security</li> </ul>"},{"location":"guides/rust_performance/","title":"Rust Performance Optimization in Autonomi","text":"<p>This guide covers performance optimization techniques for Rust applications using Autonomi, including best practices for data handling, async operations, and resource management.</p>"},{"location":"guides/rust_performance/#overview","title":"Overview","text":"<p>Performance is a critical aspect of decentralized applications. This guide provides comprehensive coverage of performance optimization techniques when using Autonomi with Rust, focusing on efficient data handling, async operations, and resource management.</p>"},{"location":"guides/rust_performance/#core-concepts","title":"Core Concepts","text":""},{"location":"guides/rust_performance/#async-runtime-configuration","title":"Async Runtime Configuration","text":"<pre><code>use autonomi::{Client, ClientConfig};\nuse tokio::runtime::Runtime;\n\nfn configure_runtime() -&gt; Runtime {\n    tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(num_cpus::get())\n        .enable_all()\n        .build()\n        .expect(\"Failed to create runtime\")\n}\n\nasync fn init_optimized_client() -&gt; Result&lt;Client&gt; {\n    let config = ClientConfig::builder()\n        .max_concurrent_requests(100)\n        .connection_pool_size(20)\n        .build()?;\n\n    Client::init_with_config(config).await\n}\n</code></pre>"},{"location":"guides/rust_performance/#data-handling-optimization","title":"Data Handling Optimization","text":""},{"location":"guides/rust_performance/#efficient-chunk-processing","title":"Efficient Chunk Processing","text":"<pre><code>use futures::stream::{self, StreamExt};\nuse bytes::Bytes;\n\nasync fn process_chunks_parallel(\n    data: Vec&lt;u8&gt;,\n    chunk_size: usize\n) -&gt; Result&lt;Vec&lt;String&gt;&gt; {\n    // Split data into chunks\n    let chunks: Vec&lt;Bytes&gt; = data\n        .chunks(chunk_size)\n        .map(Bytes::copy_from_slice)\n        .collect();\n\n    // Process chunks in parallel\n    let results = stream::iter(chunks)\n        .map(|chunk| async move {\n            let client = Client::init().await?;\n            client.store_chunk(chunk).await\n        })\n        .buffer_unordered(10) // Concurrent processing\n        .collect::&lt;Vec&lt;_&gt;&gt;()\n        .await;\n\n    // Collect results\n    results.into_iter().collect()\n}\n</code></pre>"},{"location":"guides/rust_performance/#memory-efficient-processing","title":"Memory-Efficient Processing","text":"<pre><code>use std::io::Read;\n\nstruct ChunkIterator&lt;R: Read&gt; {\n    reader: R,\n    chunk_size: usize,\n    buffer: Vec&lt;u8&gt;,\n}\n\nimpl&lt;R: Read&gt; ChunkIterator&lt;R&gt; {\n    fn new(reader: R, chunk_size: usize) -&gt; Self {\n        Self {\n            reader,\n            chunk_size,\n            buffer: vec![0; chunk_size],\n        }\n    }\n}\n\nimpl&lt;R: Read&gt; Iterator for ChunkIterator&lt;R&gt; {\n    type Item = Vec&lt;u8&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        match self.reader.read(&amp;mut self.buffer) {\n            Ok(0) =&gt; None,\n            Ok(n) =&gt; Some(self.buffer[..n].to_vec()),\n            Err(_) =&gt; None,\n        }\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#network-optimization","title":"Network Optimization","text":""},{"location":"guides/rust_performance/#connection-pooling","title":"Connection Pooling","text":"<pre><code>use autonomi::network::{Pool, PoolConfig};\n\nasync fn create_connection_pool() -&gt; Result&lt;Pool&gt; {\n    let config = PoolConfig::builder()\n        .max_size(20)\n        .min_idle(5)\n        .max_lifetime(Duration::from_secs(3600))\n        .idle_timeout(Duration::from_secs(300))\n        .build()?;\n\n    Pool::new(config).await\n}\n</code></pre>"},{"location":"guides/rust_performance/#request-batching","title":"Request Batching","text":"<pre><code>use autonomi::batch::{BatchProcessor, BatchConfig};\n\nstruct StorageBatch {\n    items: Vec&lt;Vec&lt;u8&gt;&gt;,\n    results: Vec&lt;Result&lt;String&gt;&gt;,\n}\n\nimpl BatchProcessor for StorageBatch {\n    async fn process(&amp;mut self) -&gt; Result&lt;()&gt; {\n        let client = Client::init().await?;\n\n        let futures = self.items\n            .iter()\n            .map(|item| client.store_chunk(item));\n\n        self.results = futures::future::join_all(futures).await;\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#resource-management","title":"Resource Management","text":""},{"location":"guides/rust_performance/#smart-pointer-usage","title":"Smart Pointer Usage","text":"<pre><code>use std::sync::Arc;\nuse parking_lot::RwLock;\n\nstruct CacheEntry {\n    data: Vec&lt;u8&gt;,\n    timestamp: SystemTime,\n}\n\nstruct Cache {\n    entries: Arc&lt;RwLock&lt;HashMap&lt;String, CacheEntry&gt;&gt;&gt;,\n    max_size: usize,\n}\n\nimpl Cache {\n    fn get(&amp;self, key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n        let entries = self.entries.read();\n        entries.get(key).map(|entry| entry.data.clone())\n    }\n\n    fn insert(&amp;self, key: String, data: Vec&lt;u8&gt;) {\n        let mut entries = self.entries.write();\n\n        if entries.len() &gt;= self.max_size {\n            // Evict oldest entry\n            if let Some((oldest_key, _)) = entries\n                .iter()\n                .min_by_key(|(_, entry)| entry.timestamp)\n            {\n                entries.remove(&amp;oldest_key.clone());\n            }\n        }\n\n        entries.insert(key, CacheEntry {\n            data,\n            timestamp: SystemTime::now(),\n        });\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#memory-management","title":"Memory Management","text":"<pre><code>use std::mem;\n\nstruct ChunkBuffer {\n    data: Vec&lt;u8&gt;,\n    position: usize,\n}\n\nimpl ChunkBuffer {\n    fn new(capacity: usize) -&gt; Self {\n        Self {\n            data: Vec::with_capacity(capacity),\n            position: 0,\n        }\n    }\n\n    fn push(&amp;mut self, chunk: Vec&lt;u8&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n        if self.position + chunk.len() &gt; self.data.capacity() {\n            let result = mem::replace(&amp;mut self.data, Vec::with_capacity(self.data.capacity()));\n            self.position = chunk.len();\n            self.data.extend_from_slice(&amp;chunk);\n            Some(result)\n        } else {\n            self.data.extend_from_slice(&amp;chunk);\n            self.position += chunk.len();\n            None\n        }\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#async-optimization","title":"Async Optimization","text":""},{"location":"guides/rust_performance/#task-management","title":"Task Management","text":"<pre><code>use tokio::task::{self, JoinHandle};\n\nasync fn process_with_timeout&lt;F, T&gt;(\n    operation: F,\n    timeout: Duration\n) -&gt; Result&lt;T&gt;\nwhere\n    F: Future&lt;Output = Result&lt;T&gt;&gt; + Send + 'static,\n    T: Send + 'static,\n{\n    let handle: JoinHandle&lt;Result&lt;T&gt;&gt; = task::spawn(operation);\n\n    tokio::select! {\n        result = handle =&gt; result??,\n        _ = tokio::time::sleep(timeout) =&gt; {\n            handle.abort();\n            Err(Error::Timeout)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#stream-processing","title":"Stream Processing","text":"<pre><code>use futures::stream::{self, StreamExt};\n\nasync fn process_stream&lt;T, F, Fut&gt;(\n    items: impl Stream&lt;Item = T&gt;,\n    operation: F,\n    concurrency: usize\n) -&gt; Result&lt;Vec&lt;T&gt;&gt;\nwhere\n    F: Fn(T) -&gt; Fut,\n    Fut: Future&lt;Output = Result&lt;T&gt;&gt;,\n{\n    items\n        .map(|item| operation(item))\n        .buffer_unordered(concurrency)\n        .collect::&lt;Vec&lt;_&gt;&gt;()\n        .await\n}\n</code></pre>"},{"location":"guides/rust_performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"guides/rust_performance/#metrics-collection","title":"Metrics Collection","text":"<pre><code>use metrics::{counter, gauge, histogram};\n\nasync fn track_operation&lt;F, T&gt;(\n    name: &amp;str,\n    operation: F\n) -&gt; Result&lt;T&gt;\nwhere\n    F: Future&lt;Output = Result&lt;T&gt;&gt;,\n{\n    let start = Instant::now();\n    counter!(\"operation.start\", 1, \"name\" =&gt; name.to_string());\n\n    match operation.await {\n        Ok(result) =&gt; {\n            counter!(\"operation.success\", 1, \"name\" =&gt; name.to_string());\n            histogram!(\"operation.duration\", start.elapsed(), \"name\" =&gt; name.to_string());\n            Ok(result)\n        }\n        Err(e) =&gt; {\n            counter!(\"operation.error\", 1, \"name\" =&gt; name.to_string());\n            Err(e)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#tracing","title":"Tracing","text":"<pre><code>use tracing::{info, error, span, Level};\n\nasync fn traced_operation&lt;F, T&gt;(\n    name: &amp;str,\n    operation: F\n) -&gt; Result&lt;T&gt;\nwhere\n    F: Future&lt;Output = Result&lt;T&gt;&gt;,\n{\n    let span = span!(Level::INFO, \"operation\", name = name);\n    let _enter = span.enter();\n\n    info!(\"Starting operation\");\n    match operation.await {\n        Ok(result) =&gt; {\n            info!(\"Operation completed successfully\");\n            Ok(result)\n        }\n        Err(e) =&gt; {\n            error!(error = ?e, \"Operation failed\");\n            Err(e)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/rust_performance/#best-practices","title":"Best Practices","text":"<ol> <li>Memory Management</li> <li>Use appropriate buffer sizes</li> <li>Implement proper cleanup</li> <li> <p>Monitor memory usage</p> </li> <li> <p>Async Operations</p> </li> <li>Configure thread pools appropriately</li> <li>Use connection pooling</li> <li> <p>Implement timeouts</p> </li> <li> <p>Resource Management</p> </li> <li>Use connection pools</li> <li>Implement caching</li> <li> <p>Monitor resource usage</p> </li> <li> <p>Error Handling</p> </li> <li>Implement proper recovery</li> <li>Use appropriate timeouts</li> <li>Monitor error rates</li> </ol>"},{"location":"guides/rust_performance/#performance-testing","title":"Performance Testing","text":""},{"location":"guides/rust_performance/#benchmarking","title":"Benchmarking","text":"<pre><code>use criterion::{criterion_group, criterion_main, Criterion};\n\nfn benchmark_storage(c: &amp;mut Criterion) {\n    c.bench_function(\"store_1mb\", |b| {\n        b.iter(|| {\n            let runtime = Runtime::new().unwrap();\n            runtime.block_on(async {\n                let data = vec![0u8; 1024 * 1024];\n                let client = Client::init().await?;\n                client.store_chunk(data).await\n            })\n        })\n    });\n}\n\ncriterion_group!(benches, benchmark_storage);\ncriterion_main!(benches);\n</code></pre>"},{"location":"guides/rust_performance/#load-testing","title":"Load Testing","text":"<pre><code>use tokio::time::{sleep, Duration};\n\nasync fn load_test(\n    concurrent_users: usize,\n    duration: Duration\n) -&gt; Result&lt;Stats&gt; {\n    let start = Instant::now();\n    let stats = Arc::new(RwLock::new(Stats::default()));\n\n    let handles: Vec&lt;_&gt; = (0..concurrent_users)\n        .map(|_| {\n            let stats = Arc::clone(&amp;stats);\n            tokio::spawn(async move {\n                while start.elapsed() &lt; duration {\n                    // Perform operations\n                    let result = perform_operation().await;\n                    stats.write().record_result(result);\n                    sleep(Duration::from_millis(100)).await;\n                }\n            })\n        })\n        .collect();\n\n    futures::future::join_all(handles).await;\n    Ok(Arc::try_unwrap(stats).unwrap().into_inner())\n}\n</code></pre>"},{"location":"guides/rust_performance/#resources","title":"Resources","text":"<ul> <li>API Reference</li> <li>Error Handling Guide</li> <li>Implementation Examples</li> </ul>"},{"location":"guides/rust_performance/#support","title":"Support","text":"<p>For performance optimization support:</p> <ul> <li>Technical support: support@autonomi.com</li> <li>Documentation: https://docs.autonomi.com/performance</li> <li>Performance monitoring: https://status.autonomi.com</li> </ul>"},{"location":"guides/testing_guide/","title":"Testing Guide","text":"<p>This guide covers testing strategies for Autonomi applications across different languages and environments.</p>"},{"location":"guides/testing_guide/#test-environment-setup","title":"Test Environment Setup","text":""},{"location":"guides/testing_guide/#nodejs","title":"Node.js","text":"<pre><code>npm install --save-dev jest @types/jest ts-jest\n</code></pre>"},{"location":"guides/testing_guide/#python","title":"Python","text":"<pre><code>pip install pytest pytest-asyncio\n</code></pre>"},{"location":"guides/testing_guide/#rust","title":"Rust","text":"<pre><code>cargo install cargo-test\n</code></pre>"},{"location":"guides/testing_guide/#writing-tests","title":"Writing Tests","text":""},{"location":"guides/testing_guide/#nodejs-example","title":"Node.js Example","text":"<pre><code>import { Client, LinkedList } from '@autonomi/client';\n\ndescribe('LinkedList Operations', () =&gt; {\n  let client: Client;\n\n  beforeEach(() =&gt; {\n    client = new Client();\n  });\n\n  test('should store and retrieve linked list', async () =&gt; {\n    const list = new LinkedList();\n    list.append(\"test data\");\n\n    const address = await client.linkedListPut(list);\n    const retrieved = await client.linkedListGet(address);\n\n    expect(retrieved.toString()).toBe(\"test data\");\n  });\n});\n</code></pre>"},{"location":"guides/testing_guide/#python-example","title":"Python Example","text":"<pre><code>import pytest\nfrom autonomi import Client, LinkedList\n\n@pytest.mark.asyncio\nasync def test_linked_list_operations():\n    client = Client()\n\n    # Create and store list\n    list_obj = LinkedList()\n    list_obj.append(\"test data\")\n\n    address = await client.linked_list_put(list_obj)\n    retrieved = await client.linked_list_get(address)\n\n    assert str(retrieved) == \"test data\"\n</code></pre>"},{"location":"guides/testing_guide/#rust-example","title":"Rust Example","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_linked_list_operations() {\n        let client = Client::new();\n\n        let mut list = LinkedList::new();\n        list.append(\"test data\");\n\n        let address = client.linked_list_put(&amp;list).unwrap();\n        let retrieved = client.linked_list_get(&amp;address).unwrap();\n\n        assert_eq!(retrieved.to_string(), \"test data\");\n    }\n}\n</code></pre>"},{"location":"guides/testing_guide/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests</li> <li>Integration Tests</li> <li>Network Tests</li> <li>EVM Integration Tests</li> </ol>"},{"location":"guides/testing_guide/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>GitHub Actions configuration</li> <li>Test automation</li> <li>Coverage reporting</li> </ul>"},{"location":"guides/testing_guide/#best-practices","title":"Best Practices","text":"<ul> <li>Test isolation</li> <li>Mock network calls</li> <li>Error scenarios</li> <li>Performance testing</li> </ul>"},{"location":"guides/web_development/","title":"Web Development with Autonomi","text":"<p>This guide covers best practices and patterns for building web applications using Autonomi's decentralized storage and networking capabilities.</p>"},{"location":"guides/web_development/#overview","title":"Overview","text":"<p>Autonomi provides a robust platform for building decentralized web applications. This guide will help you understand how to effectively use Autonomi's features in your web applications.</p>"},{"location":"guides/web_development/#getting-started","title":"Getting Started","text":""},{"location":"guides/web_development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 16.x or later</li> <li>TypeScript 4.x or later</li> <li>Basic understanding of web development concepts</li> </ul>"},{"location":"guides/web_development/#installation","title":"Installation","text":"<pre><code>npm install @autonomi/client\n</code></pre>"},{"location":"guides/web_development/#core-concepts","title":"Core Concepts","text":""},{"location":"guides/web_development/#client-setup","title":"Client Setup","text":"<pre><code>import { Client } from '@autonomi/client';\n\nconst client = await Client.init();\n</code></pre>"},{"location":"guides/web_development/#data-storage","title":"Data Storage","text":"<pre><code>// Store data\nconst pointer = await client.store(data);\n\n// Retrieve data\nconst data = await client.retrieve(pointer);\n</code></pre>"},{"location":"guides/web_development/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/web_development/#file-storage","title":"File Storage","text":"<pre><code>// Store a file\nconst filePointer = await client.storeFile(file);\n\n// Retrieve a file\nconst file = await client.retrieveFile(filePointer);\n</code></pre>"},{"location":"guides/web_development/#user-data-management","title":"User Data Management","text":"<pre><code>// Store user preferences\nconst prefsPointer = await client.storeScratchPad({\n  theme: 'dark',\n  language: 'en'\n});\n\n// Update preferences\nawait client.updateScratchPad(prefsPointer, {\n  theme: 'light'\n});\n</code></pre>"},{"location":"guides/web_development/#content-addressing","title":"Content Addressing","text":"<pre><code>// Create a content-addressed pointer\nconst pointer = await client.createPointer(content);\n\n// Link multiple pieces of content\nconst list = await client.createLinkedList([pointer1, pointer2]);\n</code></pre>"},{"location":"guides/web_development/#security-considerations","title":"Security Considerations","text":""},{"location":"guides/web_development/#data-encryption","title":"Data Encryption","text":"<ul> <li>Always encrypt sensitive data before storage</li> <li>Use Autonomi's built-in encryption methods</li> <li>Implement proper key management</li> </ul>"},{"location":"guides/web_development/#access-control","title":"Access Control","text":"<ul> <li>Use appropriate client modes (read-only vs read-write)</li> <li>Implement proper authentication</li> <li>Use pointer permissions effectively</li> </ul>"},{"location":"guides/web_development/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guides/web_development/#caching-strategies","title":"Caching Strategies","text":"<ul> <li>Implement local caching for frequently accessed data</li> <li>Use the browser's IndexedDB for offline capabilities</li> <li>Implement proper cache invalidation</li> </ul>"},{"location":"guides/web_development/#chunking-large-data","title":"Chunking Large Data","text":"<ul> <li>Break large files into appropriate chunks</li> <li>Use parallel uploads for better performance</li> <li>Implement proper progress tracking</li> </ul>"},{"location":"guides/web_development/#error-handling","title":"Error Handling","text":""},{"location":"guides/web_development/#common-errors","title":"Common Errors","text":"<ul> <li>Network connectivity issues</li> <li>Storage capacity limits</li> <li>Permission denied errors</li> </ul>"},{"location":"guides/web_development/#error-recovery","title":"Error Recovery","text":"<ul> <li>Implement proper retry mechanisms</li> <li>Provide clear error messages to users</li> <li>Handle offline scenarios gracefully</li> </ul>"},{"location":"guides/web_development/#testing","title":"Testing","text":""},{"location":"guides/web_development/#unit-testing","title":"Unit Testing","text":"<pre><code>import { MockClient } from '@autonomi/client/testing';\n\ndescribe('Data Storage', () =&gt; {\n  it('should store and retrieve data', async () =&gt; {\n    const client = new MockClient();\n    const data = { test: 'data' };\n    const pointer = await client.store(data);\n    const retrieved = await client.retrieve(pointer);\n    expect(retrieved).toEqual(data);\n  });\n});\n</code></pre>"},{"location":"guides/web_development/#integration-testing","title":"Integration Testing","text":"<ul> <li>Test with actual network conditions</li> <li>Verify data persistence</li> <li>Test error scenarios</li> </ul>"},{"location":"guides/web_development/#deployment","title":"Deployment","text":""},{"location":"guides/web_development/#production-considerations","title":"Production Considerations","text":"<ul> <li>Configure proper network endpoints</li> <li>Set up monitoring and logging</li> <li>Implement proper error tracking</li> </ul>"},{"location":"guides/web_development/#performance-monitoring","title":"Performance Monitoring","text":"<ul> <li>Track network latency</li> <li>Monitor storage usage</li> <li>Implement proper analytics</li> </ul>"},{"location":"guides/web_development/#best-practices","title":"Best Practices","text":"<ol> <li>Always use TypeScript for better type safety</li> <li>Implement proper error handling</li> <li>Use appropriate client modes</li> <li>Follow security best practices</li> <li>Implement proper testing</li> <li>Monitor performance and usage</li> </ol>"},{"location":"guides/web_development/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/web_development/#decentralized-content-management","title":"Decentralized Content Management","text":"<ul> <li>Store and manage content</li> <li>Implement versioning</li> <li>Handle media files</li> </ul>"},{"location":"guides/web_development/#user-data-storage","title":"User Data Storage","text":"<ul> <li>Store user preferences</li> <li>Manage user content</li> <li>Handle profile data</li> </ul>"},{"location":"guides/web_development/#file-sharing","title":"File Sharing","text":"<ul> <li>Implement secure file sharing</li> <li>Handle large files</li> <li>Track sharing status</li> </ul>"},{"location":"guides/web_development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/web_development/#common-issues","title":"Common Issues","text":"<ul> <li>Network connectivity problems</li> <li>Storage capacity issues</li> <li>Performance bottlenecks</li> </ul>"},{"location":"guides/web_development/#solutions","title":"Solutions","text":"<ul> <li>Implement proper error handling</li> <li>Use appropriate retry mechanisms</li> <li>Monitor and optimize performance</li> </ul>"},{"location":"guides/web_development/#resources","title":"Resources","text":"<ul> <li>API Reference</li> <li>Error Handling Guide</li> <li>Quantum Security Guide</li> </ul>"},{"location":"guides/web_development/#support","title":"Support","text":"<p>For additional support:</p> <ul> <li>Join our Discord community</li> <li>Check our GitHub repository</li> <li>Follow us on Twitter</li> </ul>"},{"location":"libraries/antnode/","title":"Antnode Library","text":"<p>The antnode library provides the core node implementation for participating in the Autonomi network. It handles network participation, storage management, reward collection, and data validation.</p>"},{"location":"libraries/antnode/#overview","title":"Overview","text":"<p>Antnode enables:</p> <ul> <li>Full network participation</li> <li>Secure data storage and retrieval</li> <li>Reward collection for network contribution</li> <li>Peer discovery and management</li> <li>Data validation and verification</li> <li>Network health monitoring</li> </ul>"},{"location":"libraries/antnode/#installation","title":"Installation","text":""},{"location":"libraries/antnode/#rust","title":"Rust","text":"<pre><code>[dependencies]\nantnode = \"0.3.2\"\n\n# Optional features\nantnode = { version = \"0.3.2\", features = [\"metrics\", \"tracing\"] }\n</code></pre>"},{"location":"libraries/antnode/#python","title":"Python","text":"<pre><code>pip install antnode\n\n# With optional features\npip install antnode[metrics,tracing]\n</code></pre>"},{"location":"libraries/antnode/#basic-usage","title":"Basic Usage","text":""},{"location":"libraries/antnode/#starting-a-node","title":"Starting a Node","text":"<pre><code>// Rust\nuse antnode::{Node, NodeConfig};\n\n// Create basic configuration\nlet config = NodeConfig::builder()\n    .rewards_address(\"0x1234...\")\n    .evm_network(\"arbitrum_sepolia\")\n    .build()?;\n\n// Create and run node\nlet node = Node::new(config)?;\nnode.run().await?;\n</code></pre> <pre><code># Python\nfrom antnode import AntNode\n\n# Create and run node\nnode = AntNode()\nnode.run(\n    rewards_address=\"0x1234...\",\n    evm_network=\"arbitrum_sepolia\"\n)\n</code></pre>"},{"location":"libraries/antnode/#advanced-usage","title":"Advanced Usage","text":""},{"location":"libraries/antnode/#custom-configuration","title":"Custom Configuration","text":"<pre><code>// Rust\nuse antnode::{\n    NodeConfig, StorageConfig,\n    NetworkConfig, RewardsConfig,\n};\n\n// Configure node\nlet config = NodeConfig::builder()\n    .rewards_address(\"0x1234...\")\n    .evm_network(\"arbitrum_sepolia\")\n    .storage(StorageConfig {\n        max_capacity: 1024 * 1024 * 1024,  // 1GB\n        min_free_space: 1024 * 1024 * 100,  // 100MB\n        path: \"/data/autonomi\".into(),\n    })\n    .network(NetworkConfig {\n        ip: \"0.0.0.0\".parse()?,\n        port: 12000,\n        initial_peers: vec![\n            \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\".parse()?,\n        ],\n        max_connections: 50,\n        bootstrap_interval: Duration::from_secs(300),\n    })\n    .rewards(RewardsConfig {\n        min_payout: 1_000_000,  // 1 USDC\n        auto_compound: true,\n        claim_interval: Duration::from_days(7),\n    })\n    .build()?;\n\n// Create node with config\nlet node = Node::new(config)?;\n</code></pre> <pre><code># Python\nfrom antnode import (\n    AntNode, StorageConfig,\n    NetworkConfig, RewardsConfig\n)\n\n# Configure node\nnode = AntNode()\nnode.run(\n    rewards_address=\"0x1234...\",\n    evm_network=\"arbitrum_sepolia\",\n    storage=StorageConfig(\n        max_capacity=1024 * 1024 * 1024,  # 1GB\n        min_free_space=1024 * 1024 * 100,  # 100MB\n        path=\"/data/autonomi\"\n    ),\n    network=NetworkConfig(\n        ip=\"0.0.0.0\",\n        port=12000,\n        initial_peers=[\n            \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\"\n        ],\n        max_connections=50,\n        bootstrap_interval=300  # seconds\n    ),\n    rewards=RewardsConfig(\n        min_payout=1_000_000,  # 1 USDC\n        auto_compound=True,\n        claim_interval=7 * 24 * 60 * 60  # 7 days\n    )\n)\n</code></pre>"},{"location":"libraries/antnode/#storage-operations","title":"Storage Operations","text":"<pre><code>// Rust\nuse antnode::storage::{Record, RecordType};\n\n// Store data\nlet key = node.store_record(\n    data,\n    RecordType::Chunk,\n    Some(Duration::from_days(30))\n)?;\n\n// Retrieve data\nlet record = node.get_record(&amp;key)?;\n\n// List records\nlet records = node.list_records()?;\nfor record in records {\n    println!(\"Key: {}, Size: {}\", record.key, record.size);\n}\n\n// Get storage stats\nlet stats = node.storage_stats()?;\nprintln!(\"Used: {}, Available: {}\", stats.used, stats.available);\n</code></pre> <pre><code># Python\nfrom antnode.storage import Record, RecordType\n\n# Store data\nkey = node.store_record(\n    data,\n    record_type=RecordType.CHUNK,\n    ttl=30 * 24 * 60 * 60  # 30 days\n)\n\n# Retrieve data\nrecord = node.get_record(key)\n\n# List records\nfor record in node.list_records():\n    print(f\"Key: {record.key}, Size: {record.size}\")\n\n# Get storage stats\nstats = node.storage_stats()\nprint(f\"Used: {stats.used}, Available: {stats.available}\")\n</code></pre>"},{"location":"libraries/antnode/#network-management","title":"Network Management","text":"<pre><code>// Rust\nuse antnode::network::{PeerInfo, ConnectionStats};\n\n// Get peer information\nlet peers = node.list_peers()?;\nfor peer in peers {\n    println!(\"ID: {}, Address: {}\", peer.id, peer.address);\n}\n\n// Get connection stats\nlet stats = node.connection_stats()?;\nprintln!(\n    \"Connected: {}, Incoming: {}, Outgoing: {}\",\n    stats.connected, stats.incoming, stats.outgoing\n);\n\n// Add peer manually\nnode.add_peer(\"/ip4/1.2.3.4/udp/12000/quic-v1/p2p/...\".parse()?)?;\n\n// Remove peer\nnode.remove_peer(peer_id)?;\n</code></pre> <pre><code># Python\nfrom antnode.network import PeerInfo, ConnectionStats\n\n# Get peer information\nfor peer in node.list_peers():\n    print(f\"ID: {peer.id}, Address: {peer.address}\")\n\n# Get connection stats\nstats = node.connection_stats()\nprint(\n    f\"Connected: {stats.connected}, \"\n    f\"Incoming: {stats.incoming}, \"\n    f\"Outgoing: {stats.outgoing}\"\n)\n\n# Add peer manually\nnode.add_peer(\"/ip4/1.2.3.4/udp/12000/quic-v1/p2p/...\")\n\n# Remove peer\nnode.remove_peer(peer_id)\n</code></pre>"},{"location":"libraries/antnode/#rewards-management","title":"Rewards Management","text":"<pre><code>// Rust\nuse antnode::rewards::{RewardStats, ClaimInfo};\n\n// Get reward statistics\nlet stats = node.reward_stats()?;\nprintln!(\n    \"Earned: {}, Claimed: {}, Available: {}\",\n    stats.earned, stats.claimed, stats.available\n);\n\n// Claim rewards\nlet claim = node.claim_rewards()?;\nprintln!(\"Claimed {} tokens\", claim.amount);\n\n// Get claim history\nlet claims = node.list_claims()?;\nfor claim in claims {\n    println!(\n        \"Amount: {}, Time: {}, TX: {}\",\n        claim.amount, claim.timestamp, claim.tx_hash\n    );\n}\n</code></pre> <pre><code># Python\nfrom antnode.rewards import RewardStats, ClaimInfo\n\n# Get reward statistics\nstats = node.reward_stats()\nprint(\n    f\"Earned: {stats.earned}, \"\n    f\"Claimed: {stats.claimed}, \"\n    f\"Available: {stats.available}\"\n)\n\n# Claim rewards\nclaim = node.claim_rewards()\nprint(f\"Claimed {claim.amount} tokens\")\n\n# Get claim history\nfor claim in node.list_claims():\n    print(\n        f\"Amount: {claim.amount}, \"\n        f\"Time: {claim.timestamp}, \"\n        f\"TX: {claim.tx_hash}\"\n    )\n</code></pre>"},{"location":"libraries/antnode/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"libraries/antnode/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>// Rust\nuse antnode::metrics::{MetricsConfig, PrometheusExporter};\n\n// Configure metrics\nlet config = NodeConfig::builder()\n    .metrics(MetricsConfig {\n        enabled: true,\n        port: 9100,\n        path: \"/metrics\".into(),\n    })\n    .build()?;\n\n// Access metrics programmatically\nlet metrics = node.get_metrics()?;\nprintln!(\"Storage Used: {}\", metrics.storage.used);\nprintln!(\"Peers Connected: {}\", metrics.network.peers);\n</code></pre> <pre><code># Python\nfrom antnode.metrics import MetricsConfig, PrometheusExporter\n\n# Configure metrics\nnode.run(\n    metrics=MetricsConfig(\n        enabled=True,\n        port=9100,\n        path=\"/metrics\"\n    )\n)\n\n# Access metrics programmatically\nmetrics = node.get_metrics()\nprint(f\"Storage Used: {metrics.storage.used}\")\nprint(f\"Peers Connected: {metrics.network.peers}\")\n</code></pre>"},{"location":"libraries/antnode/#logging-and-tracing","title":"Logging and Tracing","text":"<pre><code>// Rust\nuse antnode::tracing::{TracingConfig, LogLevel};\n\n// Configure logging\nlet config = NodeConfig::builder()\n    .tracing(TracingConfig {\n        level: LogLevel::Debug,\n        file: Some(\"/var/log/antnode.log\".into()),\n        json: true,\n    })\n    .build()?;\n\n// Access logs programmatically\nlet logs = node.get_logs()?;\nfor log in logs {\n    println!(\"{}: {}\", log.timestamp, log.message);\n}\n</code></pre> <pre><code># Python\nfrom antnode.tracing import TracingConfig, LogLevel\n\n# Configure logging\nnode.run(\n    tracing=TracingConfig(\n        level=LogLevel.DEBUG,\n        file=\"/var/log/antnode.log\",\n        json=True\n    )\n)\n\n# Access logs programmatically\nfor log in node.get_logs():\n    print(f\"{log.timestamp}: {log.message}\")\n</code></pre>"},{"location":"libraries/antnode/#error-handling","title":"Error Handling","text":"<pre><code>// Rust\nuse antnode::error::{Error, Result};\n\nmatch node.run().await {\n    Ok(_) =&gt; {\n        // Node running successfully\n    }\n    Err(Error::Storage(e)) =&gt; {\n        // Handle storage errors\n    }\n    Err(Error::Network(e)) =&gt; {\n        // Handle network errors\n    }\n    Err(Error::Rewards(e)) =&gt; {\n        // Handle rewards errors\n    }\n    Err(e) =&gt; {\n        // Handle other errors\n    }\n}\n</code></pre> <pre><code># Python\nfrom antnode.error import (\n    Error, StorageError,\n    NetworkError, RewardsError\n)\n\ntry:\n    node.run()\nexcept StorageError as e:\n    # Handle storage errors\nexcept NetworkError as e:\n    # Handle network errors\nexcept RewardsError as e:\n    # Handle rewards errors\nexcept Error as e:\n    # Handle other errors\n</code></pre>"},{"location":"libraries/antnode/#best-practices","title":"Best Practices","text":"<ol> <li>Node Configuration</li> <li>Set appropriate storage limits</li> <li>Configure reliable initial peers</li> <li>Use secure rewards address</li> <li> <p>Enable metrics and logging</p> </li> <li> <p>Storage Management</p> </li> <li>Monitor storage usage</li> <li>Clean up expired records</li> <li>Validate data integrity</li> <li> <p>Backup important data</p> </li> <li> <p>Network Optimization</p> </li> <li>Maintain good peer connections</li> <li>Monitor network health</li> <li>Handle network errors</li> <li> <p>Use appropriate timeouts</p> </li> <li> <p>Rewards Management</p> </li> <li>Set up automatic claiming</li> <li>Monitor reward accumulation</li> <li>Keep private keys secure</li> <li>Track claim history</li> </ol>"},{"location":"libraries/antnode/#api-reference","title":"API Reference","text":"<p>See the complete API Reference for detailed documentation of all types and functions.</p>"},{"location":"libraries/blsttc/","title":"BLS Threshold Cryptography Library","text":"<p>The blsttc library provides a high-performance implementation of BLS (Boneh-Lynn-Shacham) threshold signatures using the BLS12-381 curve. It enables secure distributed key generation, threshold signatures, and key aggregation.</p>"},{"location":"libraries/blsttc/#overview","title":"Overview","text":"<p>The library provides:</p> <ul> <li>BLS12-381 curve operations</li> <li>Threshold signature schemes</li> <li>Distributed key generation</li> <li>Key and signature aggregation</li> <li>Secure serialization</li> <li>Batch verification</li> </ul>"},{"location":"libraries/blsttc/#installation","title":"Installation","text":""},{"location":"libraries/blsttc/#rust","title":"Rust","text":"<pre><code>[dependencies]\nblsttc = \"0.1.0\"\n\n# Optional features\nblsttc = { version = \"0.1.0\", features = [\"serde\", \"rayon\"] }\n</code></pre>"},{"location":"libraries/blsttc/#python","title":"Python","text":"<pre><code>pip install blsttc\n\n# With optional features\npip install blsttc[serde,rayon]\n</code></pre>"},{"location":"libraries/blsttc/#basic-usage","title":"Basic Usage","text":""},{"location":"libraries/blsttc/#simple-signing","title":"Simple Signing","text":"<pre><code>// Rust\nuse blsttc::{SecretKey, PublicKey, Signature};\n\n// Generate keys\nlet sk = SecretKey::random();\nlet pk = sk.public_key();\n\n// Sign and verify\nlet msg = b\"Hello, World!\";\nlet sig = sk.sign(msg);\nassert!(pk.verify(&amp;sig, msg));\n</code></pre> <pre><code># Python\nfrom blsttc import SecretKey, PublicKey, Signature\n\n# Generate keys\nsk = SecretKey.random()\npk = sk.public_key()\n\n# Sign and verify\nmsg = b\"Hello, World!\"\nsig = sk.sign(msg)\nassert pk.verify(sig, msg)\n</code></pre>"},{"location":"libraries/blsttc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"libraries/blsttc/#threshold-signatures","title":"Threshold Signatures","text":"<pre><code>// Rust\nuse blsttc::{SecretKeySet, PublicKeySet};\n\n// Generate threshold key set\nlet threshold = 2;  // t-of-n, where t = threshold + 1\nlet sk_set = SecretKeySet::random(threshold, &amp;mut rng);\nlet pk_set = sk_set.public_keys();\n\n// Generate key shares\nlet sk_shares: Vec&lt;_&gt; = (0..=threshold + 1)\n    .map(|i| sk_set.secret_key_share(i))\n    .collect();\nlet pk_shares: Vec&lt;_&gt; = (0..=threshold + 1)\n    .map(|i| pk_set.public_key_share(i))\n    .collect();\n\n// Sign with shares\nlet msg = b\"Hello, World!\";\nlet sig_shares: Vec&lt;_&gt; = sk_shares.iter()\n    .map(|sk| sk.sign(msg))\n    .collect();\n\n// Combine signatures\nlet sig = pk_set.combine_signatures(&amp;sig_shares[..threshold + 1])?;\nassert!(pk_set.public_key().verify(&amp;sig, msg));\n</code></pre> <pre><code># Python\nfrom blsttc import SecretKeySet, PublicKeySet\n\n# Generate threshold key set\nthreshold = 2  # t-of-n, where t = threshold + 1\nsk_set = SecretKeySet.random(threshold)\npk_set = sk_set.public_keys()\n\n# Generate key shares\nsk_shares = [\n    sk_set.secret_key_share(i)\n    for i in range(threshold + 2)\n]\npk_shares = [\n    pk_set.public_key_share(i)\n    for i in range(threshold + 2)\n]\n\n# Sign with shares\nmsg = b\"Hello, World!\"\nsig_shares = [sk.sign(msg) for sk in sk_shares]\n\n# Combine signatures\nsig = pk_set.combine_signatures(sig_shares[:threshold + 1])\nassert pk_set.public_key().verify(sig, msg)\n</code></pre>"},{"location":"libraries/blsttc/#distributed-key-generation","title":"Distributed Key Generation","text":"<pre><code>// Rust\nuse blsttc::dkg::{DKGParticipant, Contribution};\n\n// Initialize participants\nlet n_participants = 5;\nlet threshold = 2;\nlet mut participants: Vec&lt;_&gt; = (0..n_participants)\n    .map(|i| DKGParticipant::new(i, threshold, n_participants))\n    .collect();\n\n// Round 1: Generate and share contributions\nlet contributions: Vec&lt;_&gt; = participants.iter_mut()\n    .map(|p| p.generate_contribution())\n    .collect();\n\n// Share contributions with all participants\nfor p in &amp;mut participants {\n    for c in &amp;contributions {\n        p.handle_contribution(c)?;\n    }\n}\n\n// Round 2: Generate complaints/justifications\nlet complaints: Vec&lt;_&gt; = participants.iter_mut()\n    .map(|p| p.generate_complaints())\n    .collect();\n\n// Handle complaints\nfor p in &amp;mut participants {\n    for c in &amp;complaints {\n        p.handle_complaint(c)?;\n    }\n}\n\n// Finalize keys\nlet key_sets: Vec&lt;_&gt; = participants.iter_mut()\n    .map(|p| p.finalize())\n    .collect::&lt;Result&lt;_, _&gt;&gt;()?;\n</code></pre> <pre><code># Python\nfrom blsttc.dkg import DKGParticipant, Contribution\n\n# Initialize participants\nn_participants = 5\nthreshold = 2\nparticipants = [\n    DKGParticipant(i, threshold, n_participants)\n    for i in range(n_participants)\n]\n\n# Round 1: Generate and share contributions\ncontributions = [\n    p.generate_contribution()\n    for p in participants\n]\n\n# Share contributions with all participants\nfor p in participants:\n    for c in contributions:\n        p.handle_contribution(c)\n\n# Round 2: Generate complaints/justifications\ncomplaints = [\n    p.generate_complaints()\n    for p in participants\n]\n\n# Handle complaints\nfor p in participants:\n    for c in complaints:\n        p.handle_complaint(c)\n\n# Finalize keys\nkey_sets = [p.finalize() for p in participants]\n</code></pre>"},{"location":"libraries/blsttc/#batch-verification","title":"Batch Verification","text":"<pre><code>// Rust\nuse blsttc::batch::{BatchVerifier, VerificationStrategy};\n\n// Create batch verifier\nlet mut verifier = BatchVerifier::new(VerificationStrategy::Strict);\n\n// Add signatures to batch\nfor (sig, msg, pk) in signatures {\n    verifier.queue((sig, msg, pk));\n}\n\n// Verify all signatures\nassert!(verifier.verify()?);\n</code></pre> <pre><code># Python\nfrom blsttc.batch import BatchVerifier, VerificationStrategy\n\n# Create batch verifier\nverifier = BatchVerifier(VerificationStrategy.STRICT)\n\n# Add signatures to batch\nfor sig, msg, pk in signatures:\n    verifier.queue((sig, msg, pk))\n\n# Verify all signatures\nassert verifier.verify()\n</code></pre>"},{"location":"libraries/blsttc/#serialization","title":"Serialization","text":"<pre><code>// Rust\nuse blsttc::serde::{serialize, deserialize};\n\n// Serialize keys and signatures\nlet sk_bytes = serialize(&amp;sk)?;\nlet pk_bytes = serialize(&amp;pk)?;\nlet sig_bytes = serialize(&amp;sig)?;\n\n// Deserialize\nlet sk: SecretKey = deserialize(&amp;sk_bytes)?;\nlet pk: PublicKey = deserialize(&amp;pk_bytes)?;\nlet sig: Signature = deserialize(&amp;sig_bytes)?;\n</code></pre> <pre><code># Python\nfrom blsttc.serde import serialize, deserialize\n\n# Serialize keys and signatures\nsk_bytes = serialize(sk)\npk_bytes = serialize(pk)\nsig_bytes = serialize(sig)\n\n# Deserialize\nsk = deserialize(SecretKey, sk_bytes)\npk = deserialize(PublicKey, pk_bytes)\nsig = deserialize(Signature, sig_bytes)\n</code></pre>"},{"location":"libraries/blsttc/#performance-optimization","title":"Performance Optimization","text":""},{"location":"libraries/blsttc/#parallel-processing","title":"Parallel Processing","text":"<pre><code>// Rust\nuse blsttc::parallel::{ParallelVerifier, ThreadPool};\n\n// Create thread pool\nlet pool = ThreadPool::new(4);  // 4 threads\n\n// Verify signatures in parallel\nlet results = pool.verify_batch(&amp;signatures)?;\n</code></pre> <pre><code># Python\nfrom blsttc.parallel import ParallelVerifier, ThreadPool\n\n# Create thread pool\npool = ThreadPool(4)  # 4 threads\n\n# Verify signatures in parallel\nresults = pool.verify_batch(signatures)\n</code></pre>"},{"location":"libraries/blsttc/#memory-management","title":"Memory Management","text":"<pre><code>// Rust\nuse blsttc::memory::{MemoryConfig, CacheConfig};\n\n// Configure memory usage\nlet config = MemoryConfig {\n    max_batch_size: 1000,\n    max_cache_size: 100 * 1024 * 1024,  // 100MB\n};\n\n// Use configuration\nlet verifier = BatchVerifier::with_config(config);\n</code></pre> <pre><code># Python\nfrom blsttc.memory import MemoryConfig, CacheConfig\n\n# Configure memory usage\nconfig = MemoryConfig(\n    max_batch_size=1000,\n    max_cache_size=100 * 1024 * 1024  # 100MB\n)\n\n# Use configuration\nverifier = BatchVerifier(config=config)\n</code></pre>"},{"location":"libraries/blsttc/#security-considerations","title":"Security Considerations","text":""},{"location":"libraries/blsttc/#key-generation","title":"Key Generation","text":"<ul> <li>Use cryptographically secure random number generation</li> <li>Protect secret keys and shares</li> <li>Validate all inputs</li> <li>Use appropriate thresholds</li> </ul>"},{"location":"libraries/blsttc/#signature-verification","title":"Signature Verification","text":"<ul> <li>Validate public keys</li> <li>Check signature validity</li> <li>Use batch verification carefully</li> <li>Handle errors appropriately</li> </ul>"},{"location":"libraries/blsttc/#error-handling","title":"Error Handling","text":"<pre><code>// Rust\nuse blsttc::error::{Error, Result};\n\nmatch sk_set.combine_signatures(&amp;signatures) {\n    Ok(sig) =&gt; {\n        // Combined signature\n    }\n    Err(Error::InvalidShare(e)) =&gt; {\n        // Handle invalid share\n    }\n    Err(Error::NotEnoughShares(e)) =&gt; {\n        // Handle insufficient shares\n    }\n    Err(e) =&gt; {\n        // Handle other errors\n    }\n}\n</code></pre> <pre><code># Python\nfrom blsttc.error import (\n    Error, InvalidShareError,\n    NotEnoughSharesError\n)\n\ntry:\n    sig = sk_set.combine_signatures(signatures)\nexcept InvalidShareError as e:\n    # Handle invalid share\nexcept NotEnoughSharesError as e:\n    # Handle insufficient shares\nexcept Error as e:\n    # Handle other errors\n</code></pre>"},{"location":"libraries/blsttc/#best-practices","title":"Best Practices","text":"<ol> <li>Key Management</li> <li>Secure key generation</li> <li>Safe key storage</li> <li>Regular key rotation</li> <li> <p>Proper share distribution</p> </li> <li> <p>Performance</p> </li> <li>Use batch verification</li> <li>Enable parallel processing</li> <li>Configure appropriate batch sizes</li> <li> <p>Monitor memory usage</p> </li> <li> <p>Security</p> </li> <li>Validate all inputs</li> <li>Use secure random numbers</li> <li>Handle errors appropriately</li> <li> <p>Follow cryptographic best practices</p> </li> <li> <p>Integration</p> </li> <li>Use appropriate thresholds</li> <li>Implement proper error handling</li> <li>Monitor system performance</li> <li>Regular security audits</li> </ol>"},{"location":"libraries/blsttc/#api-reference","title":"API Reference","text":"<p>See the complete API Reference for detailed documentation of all types and functions.</p>"},{"location":"libraries/self_encryption/","title":"Self-Encryption Library","text":"<p>The self-encryption library provides quantum-secure data encryption with content-based chunking and deduplication. It's a core component of Autonomi's security infrastructure.</p>"},{"location":"libraries/self_encryption/#overview","title":"Overview","text":"<p>Self-encryption is a unique approach to data security that: - Encrypts data using its own content as the key - Splits data into chunks for efficient storage and retrieval - Provides automatic deduplication - Enables parallel processing and streaming - Ensures quantum security through advanced cryptographic techniques</p>"},{"location":"libraries/self_encryption/#installation","title":"Installation","text":""},{"location":"libraries/self_encryption/#rust","title":"Rust","text":"<pre><code>[dependencies]\nself-encryption = \"0.1.0\"\n\n# Optional features\nself-encryption = { version = \"0.1.0\", features = [\"compression\", \"parallel\"] }\n</code></pre>"},{"location":"libraries/self_encryption/#python","title":"Python","text":"<pre><code>pip install self-encryption\n\n# With optional features\npip install self-encryption[compression,parallel]\n</code></pre>"},{"location":"libraries/self_encryption/#basic-usage","title":"Basic Usage","text":""},{"location":"libraries/self_encryption/#simple-encryptiondecryption","title":"Simple Encryption/Decryption","text":"<pre><code>// Rust\nuse self_encryption::{DataMap, SelfEncryptor};\n\n// Create an encryptor\nlet encryptor = SelfEncryptor::new(data)?;\n\n// Encrypt data\nlet (data_map, chunks) = encryptor.encrypt()?;\n\n// Decrypt data\nlet decryptor = SelfEncryptor::from_data_map(data_map, chunks)?;\nlet decrypted = decryptor.decrypt()?;\n</code></pre> <pre><code># Python\nfrom self_encryption import SelfEncryptor\n\n# Create an encryptor\nencryptor = SelfEncryptor(data)\n\n# Encrypt data\ndata_map, chunks = encryptor.encrypt()\n\n# Decrypt data\ndecryptor = SelfEncryptor.from_data_map(data_map, chunks)\ndecrypted = decryptor.decrypt()\n</code></pre>"},{"location":"libraries/self_encryption/#advanced-usage","title":"Advanced Usage","text":""},{"location":"libraries/self_encryption/#custom-configuration","title":"Custom Configuration","text":"<pre><code>// Rust\nuse self_encryption::{\n    EncryptionConfig, ChunkConfig,\n    CompressionConfig, ParallelConfig,\n};\n\n// Configure encryption parameters\nlet config = EncryptionConfig::new()\n    .with_chunk_size(1024 * 1024)  // 1MB chunks\n    .with_min_chunks(3)\n    .with_compression(CompressionConfig {\n        algorithm: \"zstd\",\n        level: 3,\n    })\n    .with_parallel(ParallelConfig {\n        max_threads: 4,\n        chunk_size: 1024 * 1024,\n    });\n\n// Create encryptor with config\nlet encryptor = SelfEncryptor::with_config(data, config)?;\n</code></pre> <pre><code># Python\nfrom self_encryption import (\n    EncryptionConfig, ChunkConfig,\n    CompressionConfig, ParallelConfig\n)\n\n# Configure encryption parameters\nconfig = EncryptionConfig(\n    chunk_size=1024 * 1024,  # 1MB chunks\n    min_chunks=3,\n    compression=CompressionConfig(\n        algorithm=\"zstd\",\n        level=3\n    ),\n    parallel=ParallelConfig(\n        max_threads=4,\n        chunk_size=1024 * 1024\n    )\n)\n\n# Create encryptor with config\nencryptor = SelfEncryptor(data, config=config)\n</code></pre>"},{"location":"libraries/self_encryption/#custom-chunk-store","title":"Custom Chunk Store","text":"<pre><code>// Rust\nuse self_encryption::{ChunkStore, ChunkInfo};\n\nstruct MyChunkStore {\n    // Your storage implementation\n}\n\nimpl ChunkStore for MyChunkStore {\n    fn store(&amp;mut self, chunk: &amp;[u8]) -&gt; Result&lt;ChunkInfo&gt; {\n        // Store chunk and return info\n    }\n\n    fn retrieve(&amp;self, info: &amp;ChunkInfo) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {\n        // Retrieve chunk using info\n    }\n}\n\n// Use custom store\nlet store = MyChunkStore::new();\nlet encryptor = SelfEncryptor::with_store(data, store)?;\n</code></pre> <pre><code># Python\nfrom self_encryption import ChunkStore, ChunkInfo\n\nclass MyChunkStore(ChunkStore):\n    def store(self, chunk: bytes) -&gt; ChunkInfo:\n        # Store chunk and return info\n        pass\n\n    def retrieve(self, info: ChunkInfo) -&gt; bytes:\n        # Retrieve chunk using info\n        pass\n\n# Use custom store\nstore = MyChunkStore()\nencryptor = SelfEncryptor(data, chunk_store=store)\n</code></pre>"},{"location":"libraries/self_encryption/#streaming-interface","title":"Streaming Interface","text":"<pre><code>// Rust\nuse self_encryption::streaming::{StreamEncryptor, StreamDecryptor};\n\n// Create streaming encryptor\nlet mut encryptor = StreamEncryptor::new(config)?;\n\n// Process data in chunks\nwhile let Some(chunk) = stream.next().await {\n    encryptor.write(&amp;chunk).await?;\n}\n\n// Finalize encryption\nlet (data_map, chunks) = encryptor.finalize().await?;\n\n// Streaming decryption\nlet mut decryptor = StreamDecryptor::from_data_map(data_map)?;\nwhile let Some(chunk) = decryptor.next().await {\n    process_chunk(chunk?).await;\n}\n</code></pre> <pre><code># Python\nfrom self_encryption.streaming import StreamEncryptor, StreamDecryptor\n\n# Create streaming encryptor\nencryptor = StreamEncryptor(config)\n\n# Process data in chunks\nasync for chunk in stream:\n    await encryptor.write(chunk)\n\n# Finalize encryption\ndata_map, chunks = await encryptor.finalize()\n\n# Streaming decryption\ndecryptor = StreamDecryptor.from_data_map(data_map)\nasync for chunk in decryptor:\n    await process_chunk(chunk)\n</code></pre>"},{"location":"libraries/self_encryption/#performance-optimization","title":"Performance Optimization","text":""},{"location":"libraries/self_encryption/#parallel-processing","title":"Parallel Processing","text":"<pre><code>// Rust\nuse self_encryption::parallel::{ParallelEncryptor, WorkerPool};\n\n// Create worker pool\nlet pool = WorkerPool::new(4);  // 4 worker threads\n\n// Create parallel encryptor\nlet encryptor = ParallelEncryptor::with_pool(data, pool)?;\n\n// Encrypt with parallel processing\nlet (data_map, chunks) = encryptor.encrypt()?;\n</code></pre> <pre><code># Python\nfrom self_encryption.parallel import ParallelEncryptor, WorkerPool\n\n# Create worker pool\npool = WorkerPool(4)  # 4 worker threads\n\n# Create parallel encryptor\nencryptor = ParallelEncryptor(data, worker_pool=pool)\n\n# Encrypt with parallel processing\ndata_map, chunks = encryptor.encrypt()\n</code></pre>"},{"location":"libraries/self_encryption/#memory-management","title":"Memory Management","text":"<pre><code>// Rust\nuse self_encryption::memory::{MemoryConfig, CacheConfig};\n\n// Configure memory usage\nlet config = EncryptionConfig::new()\n    .with_memory(MemoryConfig {\n        max_chunk_cache: 100 * 1024 * 1024,  // 100MB\n        max_total_memory: 1024 * 1024 * 1024,  // 1GB\n    })\n    .with_cache(CacheConfig {\n        capacity: 1000,\n        ttl: Duration::from_secs(300),\n    });\n</code></pre> <pre><code># Python\nfrom self_encryption.memory import MemoryConfig, CacheConfig\n\n# Configure memory usage\nconfig = EncryptionConfig(\n    memory=MemoryConfig(\n        max_chunk_cache=100 * 1024 * 1024,  # 100MB\n        max_total_memory=1024 * 1024 * 1024,  # 1GB\n    ),\n    cache=CacheConfig(\n        capacity=1000,\n        ttl=300  # seconds\n    )\n)\n</code></pre>"},{"location":"libraries/self_encryption/#security-considerations","title":"Security Considerations","text":""},{"location":"libraries/self_encryption/#quantum-security","title":"Quantum Security","text":"<p>The self-encryption library uses quantum-secure algorithms: - Post-quantum cryptographic primitives - Information-theoretic security properties - Forward secrecy guarantees - Quantum-resistant key derivation</p>"},{"location":"libraries/self_encryption/#key-management","title":"Key Management","text":"<pre><code>// Rust\nuse self_encryption::keys::{KeyConfig, KeyStore};\n\n// Configure key management\nlet config = EncryptionConfig::new()\n    .with_keys(KeyConfig {\n        rotation_interval: Duration::from_days(30),\n        min_entropy: 256,\n        quantum_safe: true,\n    });\n\n// Use custom key store\nlet store = KeyStore::new(config)?;\nlet encryptor = SelfEncryptor::with_key_store(data, store)?;\n</code></pre> <pre><code># Python\nfrom self_encryption.keys import KeyConfig, KeyStore\n\n# Configure key management\nconfig = EncryptionConfig(\n    keys=KeyConfig(\n        rotation_interval=30 * 24 * 60 * 60,  # 30 days\n        min_entropy=256,\n        quantum_safe=True\n    )\n)\n\n# Use custom key store\nstore = KeyStore(config)\nencryptor = SelfEncryptor(data, key_store=store)\n</code></pre>"},{"location":"libraries/self_encryption/#error-handling","title":"Error Handling","text":"<pre><code>// Rust\nuse self_encryption::error::{Error, Result};\n\nmatch encryptor.encrypt() {\n    Ok((data_map, chunks)) =&gt; {\n        // Success\n    }\n    Err(Error::InvalidData(e)) =&gt; {\n        // Handle invalid data\n    }\n    Err(Error::ChunkStore(e)) =&gt; {\n        // Handle storage errors\n    }\n    Err(Error::Encryption(e)) =&gt; {\n        // Handle encryption errors\n    }\n    Err(e) =&gt; {\n        // Handle other errors\n    }\n}\n</code></pre> <pre><code># Python\nfrom self_encryption.error import (\n    Error, InvalidDataError,\n    ChunkStoreError, EncryptionError\n)\n\ntry:\n    data_map, chunks = encryptor.encrypt()\nexcept InvalidDataError as e:\n    # Handle invalid data\nexcept ChunkStoreError as e:\n    # Handle storage errors\nexcept EncryptionError as e:\n    # Handle encryption errors\nexcept Error as e:\n    # Handle other errors\n</code></pre>"},{"location":"libraries/self_encryption/#best-practices","title":"Best Practices","text":"<ol> <li>Data Preparation</li> <li>Pre-process large files into appropriate chunks</li> <li>Validate data integrity before encryption</li> <li>Use appropriate compression for different data types</li> <li> <p>Consider data locality for chunk storage</p> </li> <li> <p>Performance</p> </li> <li>Use parallel processing for large files</li> <li>Enable compression for suitable data</li> <li>Configure appropriate chunk sizes</li> <li> <p>Implement efficient chunk storage</p> </li> <li> <p>Security</p> </li> <li>Use quantum-safe configuration</li> <li>Implement proper key management</li> <li>Validate all inputs</li> <li> <p>Handle errors appropriately</p> </li> <li> <p>Resource Management</p> </li> <li>Configure appropriate memory limits</li> <li>Use streaming for large files</li> <li>Implement proper cleanup</li> <li>Monitor resource usage</li> </ol>"},{"location":"libraries/self_encryption/#api-reference","title":"API Reference","text":"<p>See the complete API Reference for detailed documentation of all types and functions. </p>"}]}