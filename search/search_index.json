{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autonomi Documentation","text":"<p>Welcome to the Autonomi documentation! This guide will help you get started with using the Autonomi network client.</p>"},{"location":"#what-is-autonomi","title":"What is Autonomi?","text":"<p>Autonomi is a decentralized network client that provides:</p> <ul> <li>Distributed data storage and retrieval</li> <li>EVM network integration</li> <li>Secure pointer management</li> <li>Linked list data structures</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Local Network Setup</li> </ul>"},{"location":"#language-support","title":"Language Support","text":"<p>Autonomi provides client libraries for multiple languages:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\nconst client = new Client();\nawait client.connect();\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client()\nawait client.connect()\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new()?;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol> <p>For more details, see our Contributing Guide.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues</li> <li>API Reference</li> <li>Testing Guide</li> </ul>"},{"location":"api/","title":"Autonomi API Documentation","text":""},{"location":"api/#installation","title":"Installation","text":"<p>Choose your preferred language:</p> Node.jsPythonRust <pre><code># Note: Package not yet published to npm\n# Clone the repository and build from source\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\nnpm install\n</code></pre> <pre><code>pip install autonomi\n</code></pre> <pre><code># Add to Cargo.toml:\n[dependencies]\nautonomi = \"0.3.1\"\n</code></pre>"},{"location":"api/#client-initialization","title":"Client Initialization","text":"<p>Initialize a client in read-only mode for browsing data, or with write capabilities for full access:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\n// Initialize a read-only client\nconst client = await Client.initReadOnly();\n\n// Or initialize with write capabilities and configuration\nconst config = {\n    // Add your configuration here\n};\nconst client = await Client.initWithConfig(config);\n</code></pre> <pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.init_read_only()\n\n# Or initialize with write capabilities and configuration\nconfig = {\n    # Add your configuration here\n}\nclient = Client.init_with_config(config)\n</code></pre> <pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::new_local().await?;\n\n// Or initialize with configuration\nlet config = ClientConfig::default();\nlet client = Client::new(config).await?;\n</code></pre>"},{"location":"api/#core-data-types","title":"Core Data Types","text":"<p>Autonomi provides four fundamental data types that serve as building blocks for all network operations. For detailed information about each type, see the Data Types Guide.</p>"},{"location":"api/#1-chunk","title":"1. Chunk","text":"<p>Immutable, quantum-secure encrypted data blocks:</p> Node.jsPythonRust <pre><code>import { Chunk } from 'autonomi';\n\n// Store raw data as a chunk\nconst data = Buffer.from('Hello, World!');\nconst chunk = await client.storeChunk(data);\n\n// Retrieve chunk data\nconst retrieved = await client.getChunk(chunk.address);\nassert(Buffer.compare(data, retrieved) === 0);\n\n// Get chunk metadata\nconst metadata = await client.getChunkMetadata(chunk.address);\nconsole.log(`Size: ${metadata.size}`);\n</code></pre> <pre><code>from autonomi import Chunk\n\n# Store raw data as a chunk\ndata = b\"Hello, World!\"\nchunk = client.store_chunk(data)\n\n# Retrieve chunk data\nretrieved = client.get_chunk(chunk.address)\nassert data == retrieved\n\n# Get chunk metadata\nmetadata = client.get_chunk_metadata(chunk.address)\nprint(f\"Size: {metadata.size}\")\n</code></pre> <pre><code>use autonomi::Chunk;\n\n// Store raw data as a chunk\nlet data = b\"Hello, World!\";\nlet chunk = client.store_chunk(data).await?;\n\n// Retrieve chunk data\nlet retrieved = client.get_chunk(chunk.address()).await?;\nassert_eq!(data, &amp;retrieved[..]);\n\n// Get chunk metadata\nlet metadata = client.get_chunk_metadata(chunk.address()).await?;\nprintln!(\"Size: {}\", metadata.size);\n</code></pre>"},{"location":"api/#2-pointer","title":"2. Pointer","text":"<p>Mutable references with version tracking:</p> Node.jsPythonRust <pre><code>import { Pointer } from 'autonomi';\n\n// Create a pointer to some data\nconst pointer = await client.createPointer(targetAddress);\n\n// Update pointer target\nawait client.updatePointer(pointer.address, newTargetAddress);\n\n// Resolve pointer to get current target\nconst target = await client.resolvePointer(pointer.address);\n\n// Get pointer metadata and version\nconst metadata = await client.getPointerMetadata(pointer.address);\nconsole.log(`Version: ${metadata.version}`);\n</code></pre> <pre><code>from autonomi import Pointer\n\n# Create a pointer to some data\npointer = client.create_pointer(target_address)\n\n# Update pointer target\nclient.update_pointer(pointer.address, new_target_address)\n\n# Resolve pointer to get current target\ntarget = client.resolve_pointer(pointer.address)\n\n# Get pointer metadata and version\nmetadata = client.get_pointer_metadata(pointer.address)\nprint(f\"Version: {metadata.version}\")\n</code></pre> <pre><code>use autonomi::Pointer;\n\n// Create a pointer to some data\nlet pointer = client.create_pointer(target_address).await?;\n\n// Update pointer target\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer to get current target\nlet target = client.resolve_pointer(pointer.address()).await?;\n\n// Get pointer metadata and version\nlet metadata = client.get_pointer_metadata(pointer.address()).await?;\nprintln!(\"Version: {}\", metadata.version);\n</code></pre>"},{"location":"api/#3-linkedlist","title":"3. LinkedList","text":"<p>Decentralized DAG structures for transaction chains:</p> Node.jsPythonRust <pre><code>import { LinkedList } from 'autonomi';\n\n// Create a new linked list\nconst list = await client.createLinkedList();\n\n// Append items\nawait client.appendToList(list.address, item1);\nawait client.appendToList(list.address, item2);\n\n// Read list contents\nconst items = await client.getList(list.address);\n\n// Get list history\nconst history = await client.getListHistory(list.address);\nfor (const entry of history) {\n    console.log(`Version ${entry.version}: ${entry.data}`);\n}\n\n// Check for forks\nconst forks = await client.detectForks(list.address);\nif (!forks) {\n    console.log('No forks detected');\n} else {\n    handleForks(forks.branches);\n}\n</code></pre> <pre><code>from autonomi import LinkedList\n\n# Create a new linked list\nlist = client.create_linked_list()\n\n# Append items\nclient.append_to_list(list.address, item1)\nclient.append_to_list(list.address, item2)\n\n# Read list contents\nitems = client.get_list(list.address)\n\n# Get list history\nhistory = client.get_list_history(list.address)\nfor entry in history:\n    print(f\"Version {entry.version}: {entry.data}\")\n\n# Check for forks\nforks = client.detect_forks(list.address)\nif not forks:\n    print(\"No forks detected\")\nelse:\n    handle_forks(forks.branches)\n</code></pre> <pre><code>use autonomi::LinkedList;\n\n// Create a new linked list\nlet list = client.create_linked_list().await?;\n\n// Append items\nclient.append_to_list(list.address(), item1).await?;\nclient.append_to_list(list.address(), item2).await?;\n\n// Read list contents\nlet items = client.get_list(list.address()).await?;\n\n// Get list history\nlet history = client.get_list_history(list.address()).await?;\nfor entry in history {\n    println!(\"Version {}: {:?}\", entry.version, entry.data);\n}\n\n// Check for forks\nlet forks = client.detect_forks(list.address()).await?;\nmatch forks {\n    Fork::None =&gt; println!(\"No forks detected\"),\n    Fork::Detected(branches) =&gt; handle_forks(branches),\n}\n</code></pre>"},{"location":"api/#4-scratchpad","title":"4. ScratchPad","text":"<p>Unstructured data with CRDT properties:</p> Node.jsPythonRust <pre><code>import { ScratchPad, ContentType } from 'autonomi';\n\n// Create a scratchpad\nconst pad = await client.createScratchpad(ContentType.UserSettings);\n\n// Update with data\nawait client.updateScratchpad(pad.address, settingsData);\n\n// Read current data\nconst current = await client.getScratchpad(pad.address);\n\n// Get metadata\nconst metadata = await client.getScratchpadMetadata(pad.address);\nconsole.log(`Updates: ${metadata.updateCounter}`);\n</code></pre> <pre><code>from autonomi import ScratchPad, ContentType\n\n# Create a scratchpad\npad = client.create_scratchpad(ContentType.USER_SETTINGS)\n\n# Update with data\nclient.update_scratchpad(pad.address, settings_data)\n\n# Read current data\ncurrent = client.get_scratchpad(pad.address)\n\n# Get metadata\nmetadata = client.get_scratchpad_metadata(pad.address)\nprint(f\"Updates: {metadata.update_counter}\")\n</code></pre> <pre><code>use autonomi::{ScratchPad, ContentType};\n\n// Create a scratchpad\nlet pad = client.create_scratchpad(ContentType::UserSettings).await?;\n\n// Update with data\nclient.update_scratchpad(pad.address(), settings_data).await?;\n\n// Read current data\nlet current = client.get_scratchpad(pad.address()).await?;\n\n// Get metadata\nlet metadata = client.get_scratchpad_metadata(pad.address()).await?;\nprintln!(\"Updates: {}\", metadata.update_counter);\n</code></pre>"},{"location":"api/#file-system-operations","title":"File System Operations","text":"<p>Create and manage files and directories:</p> Node.jsPythonRust <pre><code>import { File, Directory } from 'autonomi/fs';\n\n// Store a file\nconst file = await client.storeFile('example.txt', content);\n\n// Create a directory\nconst dir = await client.createDirectory('docs');\n\n// Add file to directory\nawait client.addToDirectory(dir.address, file.address);\n\n// List directory contents\nconst entries = await client.listDirectory(dir.address);\nfor (const entry of entries) {\n    if (entry.isFile) {\n        console.log(`File: ${entry.name}`);\n    } else {\n        console.log(`Dir: ${entry.name}`);\n    }\n}\n</code></pre> <pre><code>from autonomi.fs import File, Directory\n\n# Store a file\nfile = client.store_file(\"example.txt\", content)\n\n# Create a directory\ndir = client.create_directory(\"docs\")\n\n# Add file to directory\nclient.add_to_directory(dir.address, file.address)\n\n# List directory contents\nentries = client.list_directory(dir.address)\nfor entry in entries:\n    if entry.is_file:\n        print(f\"File: {entry.name}\")\n    else:\n        print(f\"Dir: {entry.name}\")\n</code></pre> <pre><code>use autonomi::fs::{File, Directory};\n\n// Store a file\nlet file = client.store_file(\"example.txt\", content).await?;\n\n// Create a directory\nlet dir = client.create_directory(\"docs\").await?;\n\n// Add file to directory\nclient.add_to_directory(dir.address(), file.address()).await?;\n\n// List directory contents\nlet entries = client.list_directory(dir.address()).await?;\nfor entry in entries {\n    match entry {\n        DirEntry::File(f) =&gt; println!(\"File: {}\", f.name),\n        DirEntry::Directory(d) =&gt; println!(\"Dir: {}\", d.name),\n    }\n}\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>Each language provides appropriate error handling mechanisms:</p> Node.jsPythonRust <pre><code>import { ChunkError, PointerError } from 'autonomi/errors';\n\n// Handle chunk operations\ntry {\n    const data = await client.getChunk(address);\n    processData(data);\n} catch (error) {\n    if (error instanceof ChunkError.NotFound) {\n        handleMissing();\n    } else if (error instanceof ChunkError.NetworkError) {\n        handleNetworkError(error);\n    } else {\n        handleOtherError(error);\n    }\n}\n\n// Handle pointer updates\ntry {\n    await client.updatePointer(address, newTarget);\n    console.log('Update successful');\n} catch (error) {\n    if (error instanceof PointerError.VersionConflict) {\n        handleConflict();\n    } else {\n        handleOtherError(error);\n    }\n}\n</code></pre> <pre><code>from autonomi.errors import ChunkError, PointerError\n\n# Handle chunk operations\ntry:\n    data = client.get_chunk(address)\n    process_data(data)\nexcept ChunkError.NotFound:\n    handle_missing()\nexcept ChunkError.NetworkError as e:\n    handle_network_error(e)\nexcept Exception as e:\n    handle_other_error(e)\n\n# Handle pointer updates\ntry:\n    client.update_pointer(address, new_target)\n    print(\"Update successful\")\nexcept PointerError.VersionConflict:\n    handle_conflict()\nexcept Exception as e:\n    handle_other_error(e)\n</code></pre> <pre><code>use autonomi::error::{ChunkError, PointerError, ListError, ScratchPadError};\n\n// Handle chunk operations\nmatch client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound) =&gt; handle_missing(),\n    Err(ChunkError::NetworkError(e)) =&gt; handle_network_error(e),\n    Err(e) =&gt; handle_other_error(e),\n}\n\n// Handle pointer updates\nmatch client.update_pointer(address, new_target).await {\n    Ok(_) =&gt; println!(\"Update successful\"),\n    Err(PointerError::VersionConflict) =&gt; handle_conflict(),\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"api/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/#custom-types","title":"Custom Types","text":"Node.jsPythonRust <pre><code>interface MyData {\n    field1: string;\n    field2: number;\n}\n\n// Store custom type in a scratchpad\nconst data: MyData = {\n    field1: 'test',\n    field2: 42\n};\nconst pad = await client.createScratchpad(ContentType.Custom('MyData'));\nawait client.updateScratchpad(pad.address, data);\n</code></pre> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass MyData:\n    field1: str\n    field2: int\n\n# Store custom type in a scratchpad\ndata = MyData(field1=\"test\", field2=42)\npad = client.create_scratchpad(ContentType.CUSTOM(\"MyData\"))\nclient.update_scratchpad(pad.address, data)\n</code></pre> <pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct MyData {\n    field1: String,\n    field2: u64,\n}\n\n// Store custom type in a scratchpad\nlet data = MyData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet pad = client.create_scratchpad(ContentType::Custom(\"MyData\")).await?;\nclient.update_scratchpad(pad.address(), &amp;data).await?;\n</code></pre>"},{"location":"api/#encryption","title":"Encryption","text":"Node.jsPythonRust <pre><code>import { encrypt, decrypt, generateKey } from 'autonomi/crypto';\n\n// Encrypt data before storage\nconst key = await generateAesKey();\nconst encrypted = await encryptAes(data, key);\nconst pad = await client.createScratchpad(ContentType.Encrypted);\nawait client.updateScratchpad(pad.address, encrypted);\n\n// Decrypt retrieved data\nconst encrypted = await client.getScratchpad(pad.address);\nconst decrypted = await decryptAes(encrypted, key);\n</code></pre> <pre><code>from autonomi.crypto import encrypt_aes, decrypt_aes\n\n# Encrypt data before storage\nkey = generate_aes_key()\nencrypted = encrypt_aes(data, key)\npad = client.create_scratchpad(ContentType.ENCRYPTED)\nclient.update_scratchpad(pad.address, encrypted)\n\n# Decrypt retrieved data\nencrypted = client.get_scratchpad(pad.address)\ndecrypted = decrypt_aes(encrypted, key)\n</code></pre> <pre><code>use autonomi::crypto::{encrypt_aes, decrypt_aes};\n\n// Encrypt data before storage\nlet key = generate_aes_key();\nlet encrypted = encrypt_aes(data, &amp;key)?;\nlet pad = client.create_scratchpad(ContentType::Encrypted).await?;\nclient.update_scratchpad(pad.address(), &amp;encrypted).await?;\n\n// Decrypt retrieved data\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet decrypted = decrypt_aes(encrypted, &amp;key)?;\n</code></pre>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ol> <li>Data Type Selection</li> <li>Use Chunks for immutable data</li> <li>Use Pointers for mutable references</li> <li>Use LinkedLists for ordered collections</li> <li> <p>Use ScratchPads for temporary data</p> </li> <li> <p>Error Handling</p> </li> <li>Always handle network errors appropriately</li> <li>Use type-specific error handling</li> <li> <p>Implement retry logic for transient failures</p> </li> <li> <p>Performance</p> </li> <li>Use batch operations for multiple items</li> <li>Consider chunking large data sets</li> <li> <p>Cache frequently accessed data locally</p> </li> <li> <p>Security</p> </li> <li>Encrypt sensitive data before storage</li> <li>Use secure key management</li> <li>Validate data integrity</li> </ol>"},{"location":"api/#type-system","title":"Type System","text":"Node.jsPythonRust <pre><code>import { Address, Data, Metadata } from 'autonomi/types';\n\ninterface Client {\n    storeChunk(data: Buffer): Promise&lt;Address&gt;;\n    getChunk(address: Address): Promise&lt;Buffer&gt;;\n    createPointer(target: Address): Promise&lt;Pointer&gt;;\n    updatePointer(address: Address, target: Address): Promise&lt;void&gt;;\n}\n</code></pre> <pre><code>from typing import List, Optional, Union\nfrom autonomi.types import Address, Data, Metadata\n\nclass Client:\n    def store_chunk(self, data: bytes) -&gt; Address: ...\n    def get_chunk(self, address: Address) -&gt; bytes: ...\n    def create_pointer(self, target: Address) -&gt; Pointer: ...\n    def update_pointer(self, address: Address, target: Address) -&gt; None: ...\n</code></pre> <pre><code>use autonomi::types::{Address, Data, Metadata};\n\npub trait Client {\n    async fn store_chunk(&amp;self, data: &amp;[u8]) -&gt; Result&lt;Address&gt;;\n    async fn get_chunk(&amp;self, address: &amp;Address) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n    async fn create_pointer(&amp;self, target: Address) -&gt; Result&lt;Pointer&gt;;\n    async fn update_pointer(&amp;self, address: Address, target: Address) -&gt; Result&lt;()&gt;;\n}\n</code></pre>"},{"location":"api/#further-reading","title":"Further Reading","text":"<ul> <li>Data Types Guide</li> <li>Client Modes Guide</li> <li>Local Network Setup</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust (latest stable)</li> <li>Python 3.8 or higher</li> <li>Node.js 16 or higher</li> </ul>"},{"location":"getting-started/installation/#language-specific-installation","title":"Language-specific Installation","text":"Node.jsPythonRust <pre><code># Note: Package not yet published to npm\n# Clone the repository and build from source\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\nnpm install\n</code></pre> <pre><code>pip install autonomi\n</code></pre> <pre><code># Add to Cargo.toml:\n[dependencies]\nautonomi = \"0.3.1\"\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Test your installation by running a simple client initialization:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\nconst client = await Client.initReadOnly();\nconsole.log('Client initialized successfully');\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client.init_read_only()\nprint('Client initialized successfully')\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new_local().await?;\nprintln!(\"Client initialized successfully\");\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>API Reference</li> <li>Local Network Setup</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Autonomi quickly. We'll create a simple application that stores and retrieves data using linked lists.</p>"},{"location":"getting-started/quickstart/#choose-your-language","title":"Choose Your Language","text":"Node.jsPythonRust <pre><code>import { Client, LinkedList } from '@autonomi/client';\n\nasync function main() {\n    // Initialize client\n    const client = new Client();\n    await client.connect();\n\n    // Create a linked list\n    const list = new LinkedList();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    const address = await client.linkedListPut(list);\n    console.log(`List stored at: ${address}`);\n\n    // Retrieve the list\n    const retrieved = await client.linkedListGet(address);\n    console.log(retrieved.toString()); // \"Hello World\"\n}\n\nmain().catch(console.error);\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, LinkedList\n\nasync def main():\n    # Initialize client\n    client = Client()\n    await client.connect()\n\n    # Create a linked list\n    list_obj = LinkedList()\n    list_obj.append(\"Hello\")\n    list_obj.append(\"World\")\n\n    # Store the list\n    address = await client.linked_list_put(list_obj)\n    print(f\"List stored at: {address}\")\n\n    # Retrieve the list\n    retrieved = await client.linked_list_get(address)\n    print(str(retrieved))  # \"Hello World\"\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, LinkedList, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Initialize client\n    let client = Client::new()?;\n\n    // Create a linked list\n    let mut list = LinkedList::new();\n    list.append(\"Hello\");\n    list.append(\"World\");\n\n    // Store the list\n    let address = client.linked_list_put(&amp;list)?;\n    println!(\"List stored at: {}\", address);\n\n    // Retrieve the list\n    let retrieved = client.linked_list_get(&amp;address)?;\n    println!(\"{}\", retrieved);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-pointers","title":"Working with Pointers","text":"<p>Pointers allow you to create references to data in the network:</p> Node.jsPythonRust <pre><code>import { Client, Pointer } from '@autonomi/client';\n\nasync function main() {\n    const client = new Client();\n    await client.connect();\n\n    // Create a pointer\n    const pointer = new Pointer();\n    pointer.setTarget(\"example-target\");\n\n    // Store the pointer\n    const address = await client.pointerPut(pointer);\n    console.log(`Pointer stored at: ${address}`);\n\n    // Retrieve the pointer\n    const retrieved = await client.pointerGet(address);\n    console.log(`Target: ${retrieved.getTarget()}`);\n}\n</code></pre> <pre><code>import asyncio\nfrom autonomi import Client, Pointer\n\nasync def main():\n    client = Client()\n    await client.connect()\n\n    # Create a pointer\n    pointer = Pointer()\n    pointer.set_target(\"example-target\")\n\n    # Store the pointer\n    address = await client.pointer_put(pointer)\n    print(f\"Pointer stored at: {address}\")\n\n    # Retrieve the pointer\n    retrieved = await client.pointer_get(address)\n    print(f\"Target: {retrieved.get_target()}\")\n\nasyncio.run(main())\n</code></pre> <pre><code>use autonomi::{Client, Pointer, Result};\n\nfn main() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Create a pointer\n    let mut pointer = Pointer::new();\n    pointer.set_target(\"example-target\");\n\n    // Store the pointer\n    let address = client.pointer_put(&amp;pointer)?;\n    println!(\"Pointer stored at: {}\", address);\n\n    // Retrieve the pointer\n    let retrieved = client.pointer_get(&amp;address)?;\n    println!(\"Target: {}\", retrieved.target());\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Local Network Setup</li> <li>EVM Integration</li> <li>Testing Guide</li> <li>API Reference</li> </ul>"},{"location":"guides/client_modes/","title":"Client Modes Guide","text":"<p>This guide explains how to use Autonomi's client modes to browse the network (read-only) and optionally upgrade to write capabilities.</p>"},{"location":"guides/client_modes/#overview","title":"Overview","text":"<p>Autonomi clients can operate in two modes:</p> <ol> <li>Read-Only Mode: Browse and read data from the network without requiring a wallet</li> <li>Read-Write Mode: Full access to both read and write operations, requires a wallet</li> </ol>"},{"location":"guides/client_modes/#read-only-client","title":"Read-Only Client","text":"<p>A read-only client allows you to browse and read data from the network without needing a wallet or making payments.</p>"},{"location":"guides/client_modes/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::init_read_only().await?;\n\n// Verify it's read-only\nassert!(!client.can_write());\nassert!(client.wallet().is_none());\n\n// Read operations work normally\nlet data = client.get_bytes(address).await?;\nlet file = client.get_file(file_map, \"output.txt\").await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Initialize a read-only client\nconst client = await Client.connect({\n    readOnly: true,\n    peers: ['/ip4/127.0.0.1/tcp/12000']\n});\n\n// Read operations\nconst data = await client.dataGetPublic(address);\nconst list = await client.linkedListGet(listAddress);\n</code></pre>"},{"location":"guides/client_modes/#python","title":"Python","text":"<pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.new()\n\n# Read operations\ndata = client.get_bytes(\"safe://example_address\")\nfile = client.get_file(file_map, \"output.txt\")\n</code></pre>"},{"location":"guides/client_modes/#upgrading-to-read-write-mode","title":"Upgrading to Read-Write Mode","text":"<p>You can upgrade a read-only client to read-write mode by adding a wallet. This enables write operations like storing data or updating linked lists.</p>"},{"location":"guides/client_modes/#rust_1","title":"Rust","text":"<pre><code>use autonomi::{Client, EvmWallet};\n\n// Start with a read-only client\nlet mut client = Client::init_read_only().await?;\n\n// Get a wallet (e.g., from a private key or create new)\nlet wallet = EvmWallet::from_private_key(private_key)?;\n\n// Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)?;\n\n// Now write operations are available\nlet address = client.store_bytes(data).await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript_1","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Start with a read-only client\nconst client = await Client.connect({\n    readOnly: true\n});\n\n// Upgrade with a wallet\nawait client.upgradeToReadWrite({\n    type: 'wallet',\n    wallet: 'your_wallet_address'\n});\n\n// Now you can perform write operations\nconst address = await client.dataPutPublic(\n    Buffer.from('Hello World'),\n    { type: 'wallet', wallet: client.wallet }\n);\n</code></pre>"},{"location":"guides/client_modes/#python_1","title":"Python","text":"<pre><code>from autonomi import Client, Wallet\n\n# Start with a read-only client\nclient = Client.new()\n\n# Create or import a wallet\nwallet = Wallet.from_private_key(\"your_private_key\")\n\n# Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)\n\n# Now write operations are available\naddress = client.store_bytes(b\"Hello World\")\n</code></pre>"},{"location":"guides/client_modes/#write-operations","title":"Write Operations","text":"<p>The following operations require a wallet (read-write mode):</p> <ul> <li>Storing public data (<code>dataPutPublic</code>)</li> <li>Creating/updating linked lists (<code>linkedListPut</code>)</li> <li>Setting pointers (<code>pointerPut</code>)</li> <li>Writing to vaults (<code>writeBytesToVault</code>)</li> <li>Updating user data (<code>putUserDataToVault</code>)</li> </ul> <p>Attempting these operations in read-only mode will result in an error.</p>"},{"location":"guides/client_modes/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start Read-Only: Begin with a read-only client if you only need to read data. This is simpler and more secure since no wallet is needed.</p> </li> <li> <p>Lazy Wallet Loading: Only upgrade to read-write mode when you actually need to perform write operations.</p> </li> <li> <p>Error Handling: Always handle potential errors when upgrading modes or performing write operations:</p> </li> </ol> <pre><code>try {\n    await client.upgradeToReadWrite(wallet);\n    await client.dataPutPublic(data, payment);\n} catch (error) {\n    if (error.code === 'NO_WALLET') {\n        console.error('Write operation attempted without wallet');\n    } else if (error.code === 'ALREADY_READ_WRITE') {\n        console.error('Client is already in read-write mode');\n    }\n}\n</code></pre> <ol> <li>Check Capabilities: Use the provided methods to check client capabilities:</li> </ol> <pre><code>if client.can_write() {\n    // Perform write operation\n} else {\n    // Handle read-only state\n}\n</code></pre>"},{"location":"guides/client_modes/#common-issues","title":"Common Issues","text":"<ol> <li>Attempting Write Operations in Read-Only Mode</li> <li>Error: <code>NO_WALLET</code> or <code>WriteAccessRequired</code></li> <li> <p>Solution: Upgrade to read-write mode by adding a wallet</p> </li> <li> <p>Multiple Upgrade Attempts</p> </li> <li>Error: <code>ALREADY_READ_WRITE</code></li> <li> <p>Solution: Check client mode before attempting upgrade</p> </li> <li> <p>Invalid Wallet</p> </li> <li>Error: <code>InvalidWallet</code> or <code>WalletError</code></li> <li>Solution: Ensure wallet is properly initialized with valid credentials</li> </ol>"},{"location":"guides/data_storage/","title":"Data Storage Guide","text":"<p>This guide explains how Autonomi handles data storage, including self-encryption and scratchpad features.</p>"},{"location":"guides/data_storage/#self-encryption","title":"Self-Encryption","text":"<p>Self-encryption is a core feature that provides secure data storage by splitting and encrypting data into chunks.</p>"},{"location":"guides/data_storage/#how-it-works","title":"How It Works","text":"<ol> <li>Data is split into chunks</li> <li>Each chunk is encrypted</li> <li>A data map is created to track the chunks</li> <li>Additional encryption layers are added for larger files</li> </ol>"},{"location":"guides/data_storage/#usage-examples","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nasync function storeEncryptedData(data: Uint8Array) {\n    const client = new Client();\n\n    // Data is automatically self-encrypted when stored\n    const address = await client.data_put_public(data);\n    console.log(`Data stored at: ${address}`);\n\n    // Retrieve and decrypt data\n    const retrieved = await client.data_get_public(address);\n    console.log('Data retrieved successfully');\n}\n</code></pre> <pre><code>from autonomi import Client\n\nasync def store_encrypted_data(data: bytes):\n    client = Client()\n\n    # Data is automatically self-encrypted when stored\n    address = await client.data_put_public(data)\n    print(f\"Data stored at: {address}\")\n\n    # Retrieve and decrypt data\n    retrieved = await client.data_get_public(address)\n    print(\"Data retrieved successfully\")\n</code></pre> <pre><code>use autonomi::{Client, Bytes, Result};\n\nasync fn store_encrypted_data(data: Bytes) -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Data is automatically self-encrypted when stored\n    let address = client.data_put_public(data).await?;\n    println!(\"Data stored at: {}\", address);\n\n    // Retrieve and decrypt data\n    let retrieved = client.data_get_public(&amp;address).await?;\n    println!(\"Data retrieved successfully\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#scratchpad","title":"Scratchpad","text":"<p>Scratchpad provides a mutable storage location for encrypted data with versioning support.</p>"},{"location":"guides/data_storage/#features","title":"Features","text":"<ul> <li>Mutable data storage</li> <li>Version tracking with monotonic counter</li> <li>Owner-based access control</li> <li>Data encryption</li> <li>Signature verification</li> </ul>"},{"location":"guides/data_storage/#usage-examples_1","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client, Scratchpad } from '@autonomi/client';\n\nasync function useScratchpad() {\n    const client = new Client();\n    const secretKey = await client.generate_secret_key();\n\n    // Create or get existing scratchpad\n    const [scratchpad, isNew] = await client.get_or_create_scratchpad(\n        secretKey,\n        42 // content type\n    );\n\n    // Update scratchpad data\n    const data = new TextEncoder().encode('Hello World');\n    await client.update_scratchpad(scratchpad, data, secretKey);\n\n    // Read scratchpad data\n    const retrieved = await client.get_scratchpad(scratchpad.address);\n    const decrypted = await client.decrypt_scratchpad(retrieved, secretKey);\n    console.log(new TextDecoder().decode(decrypted));\n}\n</code></pre> <pre><code>from autonomi import Client, Scratchpad\n\nasync def use_scratchpad():\n    client = Client()\n    secret_key = client.generate_secret_key()\n\n    # Create or get existing scratchpad\n    scratchpad, is_new = await client.get_or_create_scratchpad(\n        secret_key,\n        42  # content type\n    )\n\n    # Update scratchpad data\n    data = b\"Hello World\"\n    await client.update_scratchpad(scratchpad, data, secret_key)\n\n    # Read scratchpad data\n    retrieved = await client.get_scratchpad(scratchpad.address)\n    decrypted = await client.decrypt_scratchpad(retrieved, secret_key)\n    print(decrypted.decode())\n</code></pre> <pre><code>use autonomi::{Client, Scratchpad, SecretKey, Bytes, Result};\n\nasync fn use_scratchpad() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n    let secret_key = SecretKey::random();\n\n    // Create or get existing scratchpad\n    let (mut scratchpad, is_new) = client\n        .get_or_create_scratchpad(&amp;secret_key, 42)\n        .await?;\n\n    // Update scratchpad data\n    let data = Bytes::from(\"Hello World\");\n    scratchpad.update_and_sign(data, &amp;secret_key);\n\n    // Store updated scratchpad\n    client.put_scratchpad(&amp;scratchpad).await?;\n\n    // Read scratchpad data\n    let retrieved = client.get_scratchpad(scratchpad.address()).await?;\n    let decrypted = retrieved.decrypt_data(&amp;secret_key)?;\n    println!(\"Data: {}\", String::from_utf8_lossy(&amp;decrypted));\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#best-practices","title":"Best Practices","text":"<ol> <li>Version Management</li> <li>Always check the counter before updates</li> <li>Handle version conflicts appropriately</li> <li> <p>Use monotonic counters for ordering</p> </li> <li> <p>Security</p> </li> <li>Keep secret keys secure</li> <li>Verify signatures before trusting data</li> <li> <p>Always encrypt sensitive data</p> </li> <li> <p>Error Handling</p> </li> <li>Handle decryption failures gracefully</li> <li>Implement proper retry logic for network operations</li> <li> <p>Validate data before storage</p> </li> <li> <p>Performance</p> </li> <li>Cache frequently accessed data</li> <li>Batch updates when possible</li> <li>Monitor storage size</li> </ol>"},{"location":"guides/data_storage/#implementation-details","title":"Implementation Details","text":""},{"location":"guides/data_storage/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data Splitting</li> </ol> <pre><code>// Internal process when storing data\nlet (data_map, chunks) = self_encryption::encrypt(data)?;\nlet (data_map_chunk, additional_chunks) = pack_data_map(data_map)?;\n</code></pre> <ol> <li>Chunk Management</li> <li>Each chunk is stored separately</li> <li>Chunks are encrypted individually</li> <li>Data maps track chunk locations</li> </ol>"},{"location":"guides/data_storage/#scratchpad-structure","title":"Scratchpad Structure","text":"<pre><code>pub struct Scratchpad {\n    // Network address\n    address: ScratchpadAddress,\n    // Data type identifier\n    data_encoding: u64,\n    // Encrypted content\n    encrypted_data: Bytes,\n    // Version counter\n    counter: u64,\n    // Owner's signature\n    signature: Option&lt;Signature&gt;,\n}\n</code></pre>"},{"location":"guides/data_storage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/data_storage/#custom-data-types","title":"Custom Data Types","text":"<p>You can use scratchpads to store any custom data type by implementing proper serialization:</p> <pre><code>#[derive(Serialize, Deserialize)]\nstruct CustomData {\n    field1: String,\n    field2: u64,\n}\n\n// Serialize before storing\nlet custom_data = CustomData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet bytes = serde_json::to_vec(&amp;custom_data)?;\nscratchpad.update_and_sign(Bytes::from(bytes), &amp;secret_key);\n</code></pre>"},{"location":"guides/data_storage/#batch-operations","title":"Batch Operations","text":"<p>For better performance when dealing with multiple data items:</p> <pre><code>async fn batch_store(items: Vec&lt;Bytes&gt;) -&gt; Result&lt;Vec&lt;ChunkAddress&gt;&gt; {\n    let mut addresses = Vec::new();\n    for item in items {\n        let (data_map_chunk, chunks) = encrypt(item)?;\n        // Store chunks in parallel\n        futures::future::join_all(chunks.iter().map(|c| store_chunk(c))).await;\n        addresses.push(data_map_chunk.address());\n    }\n    Ok(addresses)\n}\n</code></pre>"},{"location":"guides/data_types/","title":"Data Types Guide","text":"<p>This guide explains the fundamental data types in Autonomi and how they can be used to build higher-level abstractions like files and directories.</p>"},{"location":"guides/data_types/#fundamental-data-types","title":"Fundamental Data Types","text":"<p>Autonomi provides four fundamental data types that serve as building blocks for all network operations. Each type is designed for specific use cases and together they provide a complete system for decentralized data management.</p>"},{"location":"guides/data_types/#1-chunk","title":"1. Chunk","text":"<p>Chunks are the foundation of secure data storage in Autonomi, primarily used as the output of self-encrypting files. This provides quantum-secure encryption for data at rest.</p> <pre><code>// Store raw bytes as a chunk\nlet data = b\"Hello, World!\";\nlet chunk_address = client.store_chunk(data).await?;\n\n// Retrieve chunk data\nlet retrieved = client.get_chunk(chunk_address).await?;\nassert_eq!(data, retrieved);\n</code></pre> <p>Key characteristics: - Quantum-secure encryption through self-encryption - Immutable content - Content-addressed (address is derived from data) - Size-limited (maximum chunk size) - Efficient for small to medium-sized data</p>"},{"location":"guides/data_types/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data is split into fixed-size sections</li> <li>Each section is encrypted using data from other sections</li> <li>Results in multiple encrypted chunks</li> <li>Original data can only be recovered with all chunks</li> </ol>"},{"location":"guides/data_types/#2-pointer","title":"2. Pointer","text":"<p>Pointers provide a fixed network address that can reference any other data type, including other pointers. They enable mutable data structures while maintaining stable addresses.</p> <pre><code>// Create a pointer to some data\nlet pointer = client.create_pointer(target_address).await?;\n\n// Update pointer target\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer to get current target\nlet target = client.resolve_pointer(pointer.address()).await?;\n\n// Chain pointers for indirection\nlet pointer_to_pointer = client.create_pointer(pointer.address()).await?;\n</code></pre> <p>Key characteristics: - Fixed network address - Mutable reference capability - Single owner (controlled by secret key) - Version tracking with monotonic counter - Atomic updates - Support for pointer chains and indirection</p>"},{"location":"guides/data_types/#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>Mutable Data References <pre><code>// Update data while maintaining same address\nlet pointer = client.create_pointer(initial_data).await?;\nclient.update_pointer(pointer.address(), updated_data).await?;\n</code></pre></p> </li> <li> <p>Latest Version Publishing <pre><code>// Point to latest version while maintaining history\nlet history = client.create_linked_list().await?;\nlet latest = client.create_pointer(history.address()).await?;\n</code></pre></p> </li> <li> <p>Indirection and Redirection <pre><code>// Create chain of pointers for flexible data management\nlet data_pointer = client.create_pointer(data).await?;\nlet redirect_pointer = client.create_pointer(data_pointer.address()).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#3-linkedlist","title":"3. LinkedList","text":"<p>LinkedLists in Autonomi are powerful structures that can form transaction chains or decentralized Directed Acyclic Graphs (DAGs) on the network. They provide both historical tracking and CRDT-like properties.</p> <pre><code>// Create a new linked list\nlet list = client.create_linked_list().await?;\n\n// Append items to create history\nclient.append_to_list(list.address(), item1).await?;\nclient.append_to_list(list.address(), item2).await?;\n\n// Read list contents including history\nlet items = client.get_list(list.address()).await?;\n\n// Check for forks\nlet forks = client.detect_forks(list.address()).await?;\n</code></pre> <p>Key characteristics: - Decentralized DAG structure - Fork detection and handling - Transaction chain support - CRDT-like conflict resolution - Version history tracking - Support for value transfer (cryptocurrency-like)</p>"},{"location":"guides/data_types/#dag-properties","title":"DAG Properties","text":"<ol> <li> <p>Fork Detection <pre><code>// Detect and handle forks in the list\nmatch client.detect_forks(list.address()).await? {\n    Fork::None =&gt; proceed_with_updates(),\n    Fork::Detected(branches) =&gt; resolve_conflict(branches),\n}\n</code></pre></p> </li> <li> <p>Transaction Chains <pre><code>// Create a transaction chain\nlet transaction = Transaction {\n    previous: Some(last_tx_hash),\n    amount: 100,\n    recipient: address,\n};\nclient.append_to_list(chain.address(), transaction).await?;\n</code></pre></p> </li> <li> <p>History Tracking <pre><code>// Get full history of changes\nlet history = client.get_list_history(list.address()).await?;\nfor entry in history {\n    println!(\"Version {}: {:?}\", entry.version, entry.data);\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#4-scratchpad","title":"4. ScratchPad","text":"<p>ScratchPad provides a flexible, unstructured data storage mechanism with CRDT properties through counter-based versioning. It's ideal for user account data, application configurations, and other frequently updated small data packets.</p> <pre><code>// Create a scratchpad for user settings\nlet pad = client.create_scratchpad(ContentType::UserSettings).await?;\n\n// Update with encrypted data\nlet encrypted = encrypt_aes(settings_data, user_key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n\n// Read and decrypt current data\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet settings = decrypt_aes(encrypted, user_key)?;\n</code></pre> <p>Key characteristics: - Unstructured data storage - Counter-based CRDT for conflict resolution - Type-tagged content - Support for user-managed encryption - Efficient for frequent updates - Ideal for small data packets</p>"},{"location":"guides/data_types/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Encryption <pre><code>// Example of AES encryption for scratchpad data\nlet key = generate_aes_key();\nlet encrypted = aes_encrypt(data, key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n</code></pre></p> </li> <li> <p>Access Control <pre><code>// Create encrypted scratchpad with access control\nlet (public_key, private_key) = generate_keypair();\nlet encrypted_key = encrypt_with_public_key(aes_key, public_key);\nlet metadata = ScratchpadMetadata {\n    encrypted_key,\n    allowed_users: vec![public_key],\n};\nclient.create_scratchpad_with_access(metadata).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#common-applications","title":"Common Applications","text":"<ol> <li> <p>User Profiles <pre><code>// Store encrypted user profile\nlet profile = UserProfile { name, settings };\nlet encrypted = encrypt_profile(profile, user_key);\nclient.update_scratchpad(profile_pad, encrypted).await?;\n</code></pre></p> </li> <li> <p>Application State <pre><code>// Maintain application configuration\nlet config = AppConfig { preferences, state };\nlet pad = client.get_or_create_config_pad().await?;\nclient.update_scratchpad(pad, config).await?;\n</code></pre></p> </li> <li> <p>Temporary Storage <pre><code>// Use as temporary workspace\nlet workspace = client.create_scratchpad(ContentType::Workspace).await?;\nclient.update_scratchpad(workspace, working_data).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#higher-level-abstractions","title":"Higher-Level Abstractions","text":"<p>These fundamental types can be combined to create higher-level data structures:</p>"},{"location":"guides/data_types/#file-system","title":"File System","text":"<p>The Autonomi file system is built on top of these primitives:</p> <pre><code>// Create a directory\nlet dir = client.create_directory(\"my_folder\").await?;\n\n// Create a file\nlet file = client.create_file(\"example.txt\", content).await?;\n\n// Add file to directory\nclient.add_to_directory(dir.address(), file.address()).await?;\n\n// List directory contents\nlet entries = client.list_directory(dir.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#files","title":"Files","text":"<p>Files are implemented using a combination of chunks and pointers:</p> <ul> <li>Large files are split into chunks</li> <li>File metadata stored in pointer</li> <li>Content addressing for deduplication</li> </ul> <pre><code>// Store a large file\nlet file_map = client.store_file(\"large_file.dat\").await?;\n\n// Read file contents\nclient.get_file(file_map, \"output.dat\").await?;\n</code></pre>"},{"location":"guides/data_types/#directories","title":"Directories","text":"<p>Directories use linked lists and pointers to maintain a mutable collection of entries:</p> <ul> <li>LinkedList stores directory entries</li> <li>Pointer maintains current directory state</li> <li>Hierarchical structure support</li> </ul> <pre><code>// Create nested directory structure\nlet root = client.create_directory(\"/\").await?;\nlet docs = client.create_directory(\"docs\").await?;\nclient.add_to_directory(root.address(), docs.address()).await?;\n\n// List recursively\nlet tree = client.list_recursive(root.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/data_types/#data-organization","title":"Data Organization","text":"<ol> <li>Static Content</li> <li>Use chunks for immutable data</li> <li>Content addressing enables deduplication</li> <li> <p>Efficient for read-heavy workloads</p> </li> <li> <p>Mutable References</p> </li> <li>Use pointers for updateable references</li> <li>Maintain stable addresses</li> <li> <p>Version tracking built-in</p> </li> <li> <p>Collections</p> </li> <li>Use linked lists for ordered data</li> <li>Efficient for append operations</li> <li> <p>Good for logs and sequences</p> </li> <li> <p>Temporary Storage</p> </li> <li>Use scratchpads for working data</li> <li>Frequent updates supported</li> <li>Type-tagged content</li> </ol>"},{"location":"guides/data_types/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the Right Type</li> <li>Chunks for immutable data</li> <li>Pointers for mutable references</li> <li>LinkedLists for collections</li> <li> <p>ScratchPads for temporary storage</p> </li> <li> <p>Efficient Data Structures</p> </li> </ol> <pre><code>// Bad: Using chunks for frequently changing data\nlet chunk = client.store_chunk(changing_data).await?;\n\n// Good: Using scratchpad for frequently changing data\nlet pad = client.create_scratchpad(content_type).await?;\nclient.update_scratchpad(pad.address(), changing_data).await?;\n</code></pre> <ol> <li>Version Management</li> </ol> <pre><code>// Track versions with pointers\nlet versions = Vec::new();\nversions.push(pointer.version());\nclient.update_pointer(pointer.address(), new_data).await?;\nversions.push(pointer.version());\n</code></pre> <ol> <li>Error Handling</li> </ol> <pre><code>match client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound) =&gt; handle_missing_chunk(),\n    Err(ChunkError::InvalidSize) =&gt; handle_size_error(),\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"guides/data_types/#common-issues","title":"Common Issues","text":"<ol> <li>Size Limitations</li> <li>Chunk size limits</li> <li> <p>Solution: Split large data across multiple chunks</p> </li> <li> <p>Update Conflicts</p> </li> <li>Concurrent pointer updates</li> <li> <p>Solution: Use version checking</p> </li> <li> <p>Performance</p> </li> <li>LinkedList traversal costs</li> <li>Solution: Use appropriate data structures for access patterns</li> </ol>"},{"location":"guides/evm_integration/","title":"EVM Integration Guide","text":"<p>This guide explains how to integrate Autonomi with EVM-compatible networks for testing and development.</p>"},{"location":"guides/evm_integration/#supported-networks","title":"Supported Networks","text":"<ul> <li>Local Hardhat network</li> <li>Sepolia testnet</li> <li>Goerli testnet</li> <li>Custom EVM networks</li> </ul>"},{"location":"guides/evm_integration/#setting-up-test-networks","title":"Setting Up Test Networks","text":""},{"location":"guides/evm_integration/#local-hardhat-network","title":"Local Hardhat Network","text":"<pre><code>npx hardhat node\n</code></pre>"},{"location":"guides/evm_integration/#connecting-to-test-networks","title":"Connecting to Test Networks","text":"<pre><code>import { EvmNetwork } from '@autonomi/client';\n\nconst network = new EvmNetwork({\n  chainId: 31337, // Local hardhat network\n  rpcUrl: 'http://127.0.0.1:8545'\n});\n</code></pre>"},{"location":"guides/evm_integration/#deploying-test-contracts","title":"Deploying Test Contracts","text":"<ol> <li>Compile contracts</li> <li>Deploy using Hardhat</li> <li>Interact with contracts</li> </ol>"},{"location":"guides/evm_integration/#testing-with-different-networks","title":"Testing with Different Networks","text":"<ul> <li>Network configuration</li> <li>Gas settings</li> <li>Contract deployment</li> <li>Transaction handling</li> </ul>"},{"location":"guides/evm_integration/#best-practices","title":"Best Practices","text":"<ul> <li>Error handling</li> <li>Gas optimization</li> <li>Security considerations</li> <li>Testing strategies</li> </ul>"},{"location":"guides/local_development/","title":"Local Development Environment","text":"<p>This guide will help you set up a local development environment for building applications with Autonomi. We'll use a script that sets up a local network with all the necessary components for development and testing.</p>"},{"location":"guides/local_development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain installed</li> <li>Git repository cloned</li> <li>Basic understanding of terminal/command line</li> </ul>"},{"location":"guides/local_development/#setup-script","title":"Setup Script","text":"<p>Save the following script as <code>start-local-network.sh</code> in your project root:</p> <pre><code>#!/bin/bash\nset -e\n\n# Configuration\nNODE_DATA_DIR=\"$HOME/Library/Application Support/autonomi/node\"\nCLIENT_DATA_DIR=\"$HOME/Library/Application Support/autonomi/client\"\nEVM_PORT=4343\nEVM_RPC_URL=\"http://localhost:8545\"\nWALLET_ADDRESS=\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\nTOKEN_ADDRESS=\"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\nLOG_LEVEL=\"info\"\nNODE_PORT=5000\n\n# ... (rest of the script content) ...\n</code></pre> <p>Make the script executable:</p> <pre><code>chmod +x start-local-network.sh\n</code></pre>"},{"location":"guides/local_development/#using-the-development-environment","title":"Using the Development Environment","text":"<ol> <li>Start the local network:</li> </ol> <pre><code>./start-local-network.sh\n</code></pre> <ol> <li>The script will:</li> <li>Build all necessary components (ant-node, evm-testnet, ant CLI)</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li> <p>Set up the development environment</p> </li> <li> <p>Once running, you'll see information about:</p> </li> <li>Network endpoints</li> <li>Environment variables</li> <li>Example commands</li> </ol>"},{"location":"guides/local_development/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables should be set for your development environment:</p> <pre><code>export ANT_PEERS=/ip4/127.0.0.1/udp/5000/quic-v1\nexport ANT_LOG=info\nexport CLIENT_DATA_PATH=$HOME/Library/Application Support/autonomi/client\n</code></pre>"},{"location":"guides/local_development/#example-usage","title":"Example Usage","text":""},{"location":"guides/local_development/#file-operations","title":"File Operations","text":"<p>Upload a file:</p> <pre><code>./target/debug/ant file upload path/to/file\n</code></pre> <p>Download a file:</p> <pre><code>./target/debug/ant file download &lt;file-address&gt;\n</code></pre>"},{"location":"guides/local_development/#node-operations","title":"Node Operations","text":"<p>Check node status:</p> <pre><code>./target/debug/ant node status\n</code></pre> <p>Get wallet balance:</p> <pre><code>./target/debug/ant wallet balance\n</code></pre>"},{"location":"guides/local_development/#development-tips","title":"Development Tips","text":"<ol> <li> <p>Local Testing: The local network is perfect for testing your applications without affecting the main network.</p> </li> <li> <p>Quick Iterations: Changes to your application can be tested immediately without waiting for network confirmations.</p> </li> <li> <p>Clean State: Each time you start the network, it begins with a clean state, making it ideal for testing different scenarios.</p> </li> <li> <p>Debugging: The local environment provides detailed logs and quick feedback for debugging.</p> </li> </ol>"},{"location":"guides/local_development/#customization","title":"Customization","text":"<p>You can customize the development environment by modifying the configuration variables at the top of the script:</p> <ul> <li><code>NODE_PORT</code>: Change the port the node listens on</li> <li><code>LOG_LEVEL</code>: Adjust logging verbosity (\"trace\", \"debug\", \"info\", \"warn\", \"error\")</li> <li><code>EVM_PORT</code>: Change the EVM testnet port</li> <li>Other settings as needed</li> </ul>"},{"location":"guides/local_development/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Port Conflicts: If you see port-in-use errors, modify the <code>NODE_PORT</code> or <code>EVM_PORT</code> in the script.</p> </li> <li> <p>Process Cleanup: If the script fails to start, ensure no old processes are running:</p> </li> </ol> <pre><code>pkill -f \"antnode\"\npkill -f \"evm-testnet\"\n</code></pre> <ol> <li>Data Cleanup: To start completely fresh, remove the data directories:</li> </ol> <pre><code>rm -rf \"$HOME/Library/Application Support/autonomi/node\"\nrm -rf \"$HOME/Library/Application Support/autonomi/client\"\n</code></pre>"},{"location":"guides/local_network/","title":"Local Network Setup Guide","text":"<p>This guide explains how to set up and run a local Autonomi network for development and testing purposes.</p>"},{"location":"guides/local_network/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (with <code>cargo</code> installed)</li> <li>Git (for cloning the repository)</li> </ul> <p>That's it! Everything else needed will be built from source.</p>"},{"location":"guides/local_network/#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/dirvine/autonomi\ncd autonomi\n</code></pre> <ol> <li>Start the local network:</li> </ol> <pre><code>./test-local.sh\n</code></pre> <p>This script will:</p> <ul> <li>Build all necessary components</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li>Set up the development environment</li> </ul>"},{"location":"guides/local_network/#network-components","title":"Network Components","text":"<p>The local network consists of:</p> <ul> <li>An Autonomi node running in local mode</li> <li>A local EVM test network with pre-funded accounts</li> <li>Test wallets for development</li> </ul>"},{"location":"guides/local_network/#testing-with-evm-networks","title":"Testing with EVM Networks","text":"<p>The local EVM network provides a complete testing environment for blockchain interactions:</p>"},{"location":"guides/local_network/#pre-deployed-contracts","title":"Pre-deployed Contracts","text":"<p>The following contracts are automatically deployed:</p> <ul> <li>Payment Vault Contract (<code>PaymentVaultNoProxy</code>)</li> <li>Handles data storage payments</li> <li>Manages token approvals and transfers</li> <li>Verifies payment proofs</li> <li>Test Token Contract (<code>TestToken</code>)</li> <li>ERC20 token for testing payments</li> <li>Pre-minted supply for test accounts</li> <li>Automatic approval for test wallets</li> </ul>"},{"location":"guides/local_network/#test-accounts","title":"Test Accounts","text":"<p>Several accounts are pre-funded and ready to use:</p> <pre><code>Primary Test Account:\nAddress: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nPrivate Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nBalance: 10000 TEST tokens\n\nSecondary Test Account:\nAddress: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8\nPrivate Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\nBalance: 1000 TEST tokens\n</code></pre>"},{"location":"guides/local_network/#rpc-endpoint","title":"RPC Endpoint","text":"<p>The local EVM network exposes an RPC endpoint at <code>http://localhost:8545</code> with:</p> <ul> <li>Full JSON-RPC API support</li> <li>WebSocket subscriptions</li> <li>Low block time (1 second)</li> <li>Zero gas costs</li> <li>Instant transaction confirmations</li> </ul>"},{"location":"guides/local_network/#interacting-with-the-network","title":"Interacting with the Network","text":""},{"location":"guides/local_network/#javascripttypescript","title":"JavaScript/TypeScript","text":"<pre><code>import { ethers } from 'ethers';\n\n// Connect to local network\nconst provider = new ethers.JsonRpcProvider('http://localhost:8545');\nconst wallet = new ethers.Wallet(PRIVATE_KEY, provider);\n\n// Get contract instances\nconst paymentVault = new ethers.Contract(\n  PAYMENT_VAULT_ADDRESS,\n  PAYMENT_VAULT_ABI,\n  wallet\n);\n\n// Interact with contracts\nawait paymentVault.getQuote([metrics]);\nawait paymentVault.payForQuotes(payments);\n</code></pre>"},{"location":"guides/local_network/#python","title":"Python","text":"<pre><code>from web3 import Web3\nfrom eth_account import Account\n\n# Connect to local network\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\naccount = Account.from_key(PRIVATE_KEY)\n\n# Get contract instances\npayment_vault = w3.eth.contract(\n    address=PAYMENT_VAULT_ADDRESS,\n    abi=PAYMENT_VAULT_ABI\n)\n\n# Interact with contracts\npayment_vault.functions.getQuote([metrics]).call()\npayment_vault.functions.payForQuotes(payments).transact()\n</code></pre>"},{"location":"guides/local_network/#rust","title":"Rust","text":"<pre><code>use ethers::prelude::*;\n\n// Connect to local network\nlet provider = Provider::&lt;Http&gt;::try_from(\"http://localhost:8545\")?;\nlet wallet = LocalWallet::from_bytes(&amp;PRIVATE_KEY)?;\nlet client = SignerMiddleware::new(provider, wallet);\n\n// Get contract instances\nlet payment_vault = PaymentVault::new(\n    PAYMENT_VAULT_ADDRESS,\n    Arc::new(client)\n);\n\n// Interact with contracts\npayment_vault.get_quote(metrics).call().await?;\npayment_vault.pay_for_quotes(payments).send().await?;\n</code></pre>"},{"location":"guides/local_network/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are set up automatically:</p> <ul> <li><code>ANT_PEERS</code> - Local node endpoint</li> <li><code>ANT_LOG</code> - Logging level</li> <li><code>CLIENT_DATA_PATH</code> - Client data directory</li> </ul>"},{"location":"guides/local_network/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"guides/local_network/#logging","title":"Logging","text":""},{"location":"guides/local_network/#node-logs","title":"Node Logs","text":"<p>The Autonomi node generates detailed logs that can be controlled via <code>RUST_LOG</code>:</p> <pre><code># Trace level for maximum detail\nRUST_LOG=trace ./test-local.sh\n\n# Focus on specific modules\nRUST_LOG=autonomi=debug,ant_node=trace ./test-local.sh\n\n# Log locations:\n- Node logs: $NODE_DATA_DIR/node.log\n- EVM logs: $NODE_DATA_DIR/evm.log\n</code></pre>"},{"location":"guides/local_network/#log-levels","title":"Log Levels","text":"<ul> <li><code>error</code>: Critical issues that need immediate attention</li> <li><code>warn</code>: Important events that aren't failures</li> <li><code>info</code>: General operational information</li> <li><code>debug</code>: Detailed information for debugging</li> <li><code>trace</code>: Very detailed protocol-level information</li> </ul>"},{"location":"guides/local_network/#following-logs","title":"Following Logs","text":"<pre><code># Follow node logs\ntail -f \"$NODE_DATA_DIR/node.log\"\n\n# Follow EVM logs\ntail -f \"$NODE_DATA_DIR/evm.log\"\n\n# Filter for specific events\ntail -f \"$NODE_DATA_DIR/node.log\" | grep \"payment\"\n</code></pre>"},{"location":"guides/local_network/#debugging","title":"Debugging","text":""},{"location":"guides/local_network/#node-debugging","title":"Node Debugging","text":"<p>Using <code>rust-lldb</code>:</p> <pre><code># Start node with debugger\nrust-lldb target/debug/antnode -- --features test\n\n# Common commands:\nb autonomi::client::payment::pay  # Set breakpoint\nr                                # Run\nbt                              # Backtrace\np variable                      # Print variable\nc                              # Continue\n</code></pre> <p>Using <code>rust-gdb</code>:</p> <pre><code># Start node with debugger\nrust-gdb target/debug/antnode -- --features test\n\n# Common commands:\nbreak autonomi::client::payment::pay  # Set breakpoint\nrun                                  # Run\nbacktrace                           # Show backtrace\nprint variable                      # Examine variable\ncontinue                            # Continue execution\n</code></pre>"},{"location":"guides/local_network/#network-monitoring","title":"Network Monitoring","text":"<p>Monitor network activity:</p> <pre><code># Watch network connections\nnetstat -an | grep 5000  # Default node port\n\n# Monitor network traffic\nsudo tcpdump -i lo0 port 5000\n\n# Check EVM network\ncurl -X POST -H \"Content-Type: application/json\" \\\n  --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' \\\n  http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#contract-debugging","title":"Contract Debugging","text":"<p>Debug contract interactions:</p> <pre><code># Get payment vault state\ncast call $PAYMENT_VAULT_ADDRESS \\\n  \"payments(bytes32)\" \\\n  $QUOTE_HASH \\\n  --rpc-url http://localhost:8545\n\n# Watch for payment events\ncast events $PAYMENT_VAULT_ADDRESS \\\n  --rpc-url http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"guides/local_network/#port-conflicts","title":"Port Conflicts","text":"<p>If you see port-in-use errors:</p> <ol> <li>Check if another instance is running</li> <li>Use different ports in the script</li> <li>Kill existing processes if needed</li> </ol>"},{"location":"guides/local_network/#build-issues","title":"Build Issues","text":"<ol> <li>Make sure Rust toolchain is up to date</li> <li>Clean and rebuild: <code>cargo clean &amp;&amp; cargo build</code></li> <li>Check for missing dependencies</li> </ol>"},{"location":"guides/local_network/#network-issues","title":"Network Issues","text":"<ol> <li>Verify the node is running</li> <li>Check log output for errors</li> <li>Ensure EVM testnet is accessible</li> </ol>"},{"location":"guides/local_network/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/local_network/#custom-configuration","title":"Custom Configuration","text":"<p>You can modify the test script to:</p> <ul> <li>Change ports</li> <li>Adjust logging levels</li> <li>Configure node parameters</li> </ul>"},{"location":"guides/local_network/#multiple-nodes","title":"Multiple Nodes","text":"<p>To run multiple nodes:</p> <ol> <li>Copy the script</li> <li>Modify ports and directories</li> <li>Run each instance separately</li> </ol>"},{"location":"guides/payments/","title":"Payments Guide","text":"<p>This guide explains how payments work in Autonomi, particularly for put operations that store data on the network.</p>"},{"location":"guides/payments/#overview","title":"Overview","text":"<p>When storing data on the Autonomi network, you need to pay for the storage space. Payments are made using EVM-compatible tokens through a smart contract system. There are two ways to handle payments:</p> <ol> <li>Direct payment using an EVM wallet</li> <li>Pre-paid operations using a receipt</li> </ol>"},{"location":"guides/payments/#payment-options","title":"Payment Options","text":""},{"location":"guides/payments/#using-an-evm-wallet","title":"Using an EVM Wallet","text":"<p>The simplest way to pay for put operations is to use an EVM wallet:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\n\n# Create or load a wallet\nwallet = EvmWallet.create()  # or load from private key\npayment = PaymentOption.from_wallet(wallet)\n\n# Put data with wallet payment\ndata = b\"Hello, World!\"\naddress = client.data_put_public(data, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\n\n// Create or load a wallet\nconst wallet = EvmWallet.create();  // or load from private key\nconst payment = PaymentOption.fromWallet(wallet);\n\n// Put data with wallet payment\nconst data = Buffer.from(\"Hello, World!\");\nconst address = await client.dataPutPublic(data, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\n\n// Create or load a wallet\nlet wallet = EvmWallet::create()?;  // or load from private key\nlet payment = wallet.into();  // Converts to PaymentOption\n\n// Put data with wallet payment\nlet data = b\"Hello, World!\".to_vec();\nlet address = client.data_put_public(data.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#using-pre-paid-receipts","title":"Using Pre-paid Receipts","text":"<p>For better efficiency when doing multiple put operations, you can pre-pay for storage and reuse the receipt:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\nwallet = EvmWallet.create()\n\n# Get receipt for multiple operations\ndata1 = b\"First piece of data\"\ndata2 = b\"Second piece of data\"\n\n# Create payment receipt\nreceipt = client.create_payment_receipt([data1, data2], wallet)\npayment = PaymentOption.from_receipt(receipt)\n\n# Use receipt for puts\naddr1 = client.data_put_public(data1, payment)\naddr2 = client.data_put_public(data2, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\nconst wallet = EvmWallet.create();\n\n// Get receipt for multiple operations\nconst data1 = Buffer.from(\"First piece of data\");\nconst data2 = Buffer.from(\"Second piece of data\");\n\n// Create payment receipt\nconst receipt = await client.createPaymentReceipt([data1, data2], wallet);\nconst payment = PaymentOption.fromReceipt(receipt);\n\n// Use receipt for puts\nconst addr1 = await client.dataPutPublic(data1, payment);\nconst addr2 = await client.dataPutPublic(data2, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\nlet wallet = EvmWallet::create()?;\n\n// Get receipt for multiple operations\nlet data1 = b\"First piece of data\".to_vec();\nlet data2 = b\"Second piece of data\".to_vec();\n\n// Create payment receipt\nlet receipt = client.create_payment_receipt(\n    vec![data1.clone(), data2.clone()].into_iter(), \n    &amp;wallet\n).await?;\nlet payment = receipt.into();  // Converts to PaymentOption\n\n// Use receipt for puts\nlet addr1 = client.data_put_public(data1.into(), payment.clone()).await?;\nlet addr2 = client.data_put_public(data2.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#cost-calculation","title":"Cost Calculation","text":"<p>The cost of storing data depends on several factors:</p> <ul> <li>Size of the data</li> <li>Network density</li> <li>Storage duration</li> <li>Current network conditions</li> </ul> <p>You can calculate the cost before performing a put operation:</p> <pre><code># Python\ncost = client.calculate_storage_cost(data)\nprint(f\"Storage will cost {cost} tokens\")\n</code></pre> <pre><code>// Node.js\nconst cost = await client.calculateStorageCost(data);\nconsole.log(`Storage will cost ${cost} tokens`);\n</code></pre> <pre><code>// Rust\nlet cost = client.calculate_storage_cost(&amp;data).await?;\nprintln!(\"Storage will cost {} tokens\", cost);\n</code></pre>"},{"location":"guides/payments/#token-management","title":"Token Management","text":"<p>Before you can pay for storage, you need to ensure your wallet has sufficient tokens and has approved the payment contract to spend them:</p> <pre><code># Python\n# Check balance\nbalance = wallet.get_balance()\n\n# Approve tokens if needed\nif not wallet.has_approved_tokens():\n    wallet.approve_tokens()\n</code></pre> <pre><code>// Node.js\n// Check balance\nconst balance = await wallet.getBalance();\n\n// Approve tokens if needed\nif (!await wallet.hasApprovedTokens()) {\n    await wallet.approveTokens();\n}\n</code></pre> <pre><code>// Rust\n// Check balance\nlet balance = wallet.get_balance().await?;\n\n// Approve tokens if needed\nif !wallet.has_approved_tokens().await? {\n    wallet.approve_tokens().await?;\n}\n</code></pre>"},{"location":"guides/payments/#error-handling","title":"Error Handling","text":"<p>Common payment-related errors you might encounter:</p> <ol> <li><code>InsufficientBalance</code> - Wallet doesn't have enough tokens</li> <li><code>TokenNotApproved</code> - Token spending not approved for the payment contract</li> <li><code>PaymentExpired</code> - Payment quote has expired (when using receipts)</li> <li><code>PaymentVerificationFailed</code> - Payment verification failed on the network</li> </ol> <p>Example error handling:</p> <pre><code># Python\ntry:\n    address = client.data_put_public(data, payment)\nexcept InsufficientBalance:\n    print(\"Not enough tokens in wallet\")\nexcept TokenNotApproved:\n    print(\"Need to approve token spending\")\nexcept PaymentError as e:\n    print(f\"Payment failed: {e}\")\n</code></pre> <pre><code>// Node.js\ntry {\n    const address = await client.dataPutPublic(data, payment);\n} catch (e) {\n    if (e instanceof InsufficientBalance) {\n        console.log(\"Not enough tokens in wallet\");\n    } else if (e instanceof TokenNotApproved) {\n        console.log(\"Need to approve token spending\");\n    } else {\n        console.log(`Payment failed: ${e}`);\n    }\n}\n</code></pre> <pre><code>// Rust\nmatch client.data_put_public(data.into(), payment).await {\n    Err(PutError::InsufficientBalance) =&gt; {\n        println!(\"Not enough tokens in wallet\");\n    }\n    Err(PutError::TokenNotApproved) =&gt; {\n        println!(\"Need to approve token spending\");\n    }\n    Err(e) =&gt; {\n        println!(\"Payment failed: {}\", e);\n    }\n    Ok(address) =&gt; {\n        println!(\"Data stored at {}\", address);\n    }\n}\n</code></pre>"},{"location":"guides/payments/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-approve Tokens: Approve token spending before starting put operations to avoid extra transactions.</p> </li> <li> <p>Use Receipts: When doing multiple put operations, use receipts to avoid making separate payments for each operation.</p> </li> <li> <p>Check Costs: Always check storage costs before proceeding with large data uploads.</p> </li> <li> <p>Handle Errors: Implement proper error handling for payment-related issues.</p> </li> <li> <p>Monitor Balance: Keep track of your wallet balance to ensure sufficient funds for operations.</p> </li> </ol>"},{"location":"guides/payments/#testing-payments","title":"Testing Payments","text":"<p>When testing your application, you can use the local development environment which provides a test EVM network with pre-funded wallets. See the Local Development Guide for details.</p>"},{"location":"guides/testing_guide/","title":"Testing Guide","text":"<p>This guide covers testing strategies for Autonomi applications across different languages and environments.</p>"},{"location":"guides/testing_guide/#test-environment-setup","title":"Test Environment Setup","text":""},{"location":"guides/testing_guide/#nodejs","title":"Node.js","text":"<pre><code>npm install --save-dev jest @types/jest ts-jest\n</code></pre>"},{"location":"guides/testing_guide/#python","title":"Python","text":"<pre><code>pip install pytest pytest-asyncio\n</code></pre>"},{"location":"guides/testing_guide/#rust","title":"Rust","text":"<pre><code>cargo install cargo-test\n</code></pre>"},{"location":"guides/testing_guide/#writing-tests","title":"Writing Tests","text":""},{"location":"guides/testing_guide/#nodejs-example","title":"Node.js Example","text":"<pre><code>import { Client, LinkedList } from '@autonomi/client';\n\ndescribe('LinkedList Operations', () =&gt; {\n  let client: Client;\n\n  beforeEach(() =&gt; {\n    client = new Client();\n  });\n\n  test('should store and retrieve linked list', async () =&gt; {\n    const list = new LinkedList();\n    list.append(\"test data\");\n\n    const address = await client.linkedListPut(list);\n    const retrieved = await client.linkedListGet(address);\n\n    expect(retrieved.toString()).toBe(\"test data\");\n  });\n});\n</code></pre>"},{"location":"guides/testing_guide/#python-example","title":"Python Example","text":"<pre><code>import pytest\nfrom autonomi import Client, LinkedList\n\n@pytest.mark.asyncio\nasync def test_linked_list_operations():\n    client = Client()\n\n    # Create and store list\n    list_obj = LinkedList()\n    list_obj.append(\"test data\")\n\n    address = await client.linked_list_put(list_obj)\n    retrieved = await client.linked_list_get(address)\n\n    assert str(retrieved) == \"test data\"\n</code></pre>"},{"location":"guides/testing_guide/#rust-example","title":"Rust Example","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_linked_list_operations() {\n        let client = Client::new();\n\n        let mut list = LinkedList::new();\n        list.append(\"test data\");\n\n        let address = client.linked_list_put(&amp;list).unwrap();\n        let retrieved = client.linked_list_get(&amp;address).unwrap();\n\n        assert_eq!(retrieved.to_string(), \"test data\");\n    }\n}\n</code></pre>"},{"location":"guides/testing_guide/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests</li> <li>Integration Tests</li> <li>Network Tests</li> <li>EVM Integration Tests</li> </ol>"},{"location":"guides/testing_guide/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>GitHub Actions configuration</li> <li>Test automation</li> <li>Coverage reporting</li> </ul>"},{"location":"guides/testing_guide/#best-practices","title":"Best Practices","text":"<ul> <li>Test isolation</li> <li>Mock network calls</li> <li>Error scenarios</li> <li>Performance testing</li> </ul>"}]}